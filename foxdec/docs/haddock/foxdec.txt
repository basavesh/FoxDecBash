-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Formally Verified x86-64 Decompilation
--   
--   This package contains tools for decompilation based on formal methods.
@package foxdec
@version 0.1.0.0


module Base

-- | Show the integer in hex.
showHex :: (Integral a, Show a) => a -> String

-- | Show an integer list as hex-list.
showHex_list :: (Integral a, Show a) => [a] -> [Char]

-- | Show an integer set as hex-list.
showHex_set :: IntSet -> [Char]

-- | Show an optional integer as an optional hex.
showHex_option :: (Integral a, Show a) => Maybe a -> [Char]

-- | Read an int from a string storing a hex.
readHex' :: (Eq a, Num a) => String -> a

-- | Lookup and produce error message if key does not exists in map.
im_lookup :: [Char] -> IntMap p -> Key -> p

-- | use a default value in case of <tt>Nothing</tt>
orElse :: Maybe p -> p -> p

-- | create a tuple
pair :: a -> b -> (a, b)

-- | Find the index of one string in another.
findString :: Eq a => [a] -> [a] -> Maybe Int

-- | Take until the occurrence of the string
takeUntilString :: String -> String -> String

-- | Strip outer parentheses from a string, if it has them.
strip_parentheses :: [Char] -> [Char]

-- | In little endian, convert a byte-list to a 64 bit word. Assume the
--   list is at most length 8.
bytes_to_word :: [Word8] -> Word64

-- | Convert first <tt>n</tt> bytes of a word to an integer. Assume
--   <tt>n&lt;8</tt>.
word_to_sint :: Int -> Word64 -> Int

-- | Generic graph with ints as vertices.
data Graph
Edges :: IntMap IntSet -> Graph

-- | add edges from v to all vertices vs
graph_add_edges :: Graph -> Key -> IntSet -> Graph

-- | delete all edges with v as parent or child
graph_delete :: Graph -> Key -> Graph

-- | is v parent of an edge?
graph_is_parent :: Graph -> Key -> Bool

-- | is v a vertex in the graph?
graph_is_vertex :: Graph -> Key -> Bool

-- | is (v0,v1) an edge?
graph_is_edge :: Graph -> Key -> Key -> Bool

-- | retrieve a non-trivial SCC, if any exists
graph_nontrivial_scc :: Graph -> IntSet

-- | find next vertex to consider: either a terminal vertex (if any) or the
--   head of an SCC
graph_find_next :: Graph -> Maybe Int

-- | decide whether text should be white or black based on background color
hex_color_of_text :: String -> String

-- | A list of RGB colors
hex_colors :: [[Char]]
allp :: [a -> Bool] -> a -> Bool
instance GHC.Show.Show Base.Graph
instance GHC.Generics.Generic Base.Graph
instance Data.Serialize.Serialize Base.Graph
instance Algorithm.SCC.IntGraph Base.Graph

module Algorithm.Dominance
domFrontier :: Graph -> Graph -> Int -> IntSet


module Config

-- | A datastructure storing all configurable options
data Config
Config :: Bool -> Bool -> Bool -> Bool -> Bool -> Natural -> Natural -> Natural -> Natural -> Natural -> Natural -> Config

-- | When encountering an unknown instruction do we either * report it to
--   stderr but continue (True), or * exit with an error message (False)?
--   Sane default: True
[continue_on_unknown_instruction] :: Config -> Bool

-- | Do we call graphviz to generate PDFs? Set to true for small examples,
--   false for larger ones.
[generate_pdfs] :: Config -> Bool

-- | Must the invariants be stored in the logs? Sane default: False
[verbose_logs] :: Config -> Bool

-- | Must preconditions be stored in the .report file? Set to true for
--   small examples, false for larger ones. Sane default: False
[store_preconditions_in_report] :: Config -> Bool

-- | Must assertions be stored in the .report file? Set to true for small
--   examples, false for larger ones. Sane default: False
[store_assertions_in_report] :: Config -> Bool

-- | The maximum verification time in seconds per function Sane default: 30
--   minutes = 000000 * 60 * 30 = 1800000000
[max_time] :: Config -> Natural

-- | The maximum number of separate concrete cases considered
--   non-deterministically, before abstraction is applied. Has no effect on
--   soundness, but lower values cause more abstraction. Sane default: 5
[max_num_of_cases] :: Config -> Natural

-- | The maximum number of pointer bases a bottom-expression may have,
--   before more asbtraction is applied. Has no effect on soundness, but
--   lower values cause more abstraction. Sane default: 25
[max_num_of_bases] :: Config -> Natural
[max_num_of_sources] :: Config -> Natural

-- | The maximum number of sources a bottom-expression may have, before
--   resorting to rock-bottom. Has no effect on soundness, but lower values
--   cause more abstraction. Sane default: 100
[max_jump_table_size] :: Config -> Natural

-- | The maximum size of an expression (counting each operator and each
--   leaf as 1), before a symbolic expression is abstracted to rock bottom.
--   Does not affect soundness, but if the value is set too low, then the
--   results becomes overly overapproximative. Sane default: 3000
[max_expr_size] :: Config -> Natural

-- | Given a filename, parse a config in the Dhall language See:
--   <a>https://dhall-lang.org</a>
parse_config :: String -> IO Config
instance GHC.Show.Show Config.Config
instance GHC.Generics.Generic Config.Config
instance Dhall.Marshal.Decode.FromDhall Config.Config
instance Data.Serialize.Serialize Config.Config

module Data.Binary

-- | Information on the sections in the binary
data SectionsInfo
SectionsInfo :: [(String, String, Word64, Word64)] -> Word64 -> Word64 -> SectionsInfo

-- | Sections: segment names, section names, addresses and sizes.
[si_sections] :: SectionsInfo -> [(String, String, Word64, Word64)]
[si_min_address] :: SectionsInfo -> Word64
[si_max_address] :: SectionsInfo -> Word64

-- | Relocations
data Relocation

-- | At address a0, address a1 has been written
R_X86_64_RELATIVE :: Word64 -> Word64 -> Relocation
pp_reloc :: Relocation -> [Char]

-- | Symbol Table
type SymbolTable = IntMap String
class BinaryClass a
binary_read_ro_data :: BinaryClass a => a -> Word64 -> Int -> Maybe [Word8]
binary_read_data :: BinaryClass a => a -> Word64 -> Int -> Maybe [Word8]
binary_get_sections_info :: BinaryClass a => a -> SectionsInfo
binary_get_relocs :: BinaryClass a => a -> [Relocation]
binary_get_symbols :: BinaryClass a => a -> SymbolTable
binary_pp :: BinaryClass a => a -> String
data Binary
Binary :: b -> Binary
instance GHC.Classes.Eq Data.Binary.SectionsInfo
instance GHC.Generics.Generic Data.Binary.SectionsInfo
instance GHC.Show.Show Data.Binary.SectionsInfo
instance GHC.Classes.Ord Data.Binary.Relocation
instance GHC.Classes.Eq Data.Binary.Relocation
instance GHC.Generics.Generic Data.Binary.Relocation
instance GHC.Show.Show Data.Binary.Relocation
instance Data.Binary.BinaryClass Data.Binary.Binary

module Data.BinaryElf
elf_read_file :: ByteString -> Elf
instance GHC.Generics.Generic Data.Elf.ElfMachine
instance GHC.Generics.Generic Data.Elf.ElfSegmentType
instance GHC.Generics.Generic Data.Elf.ElfSegmentFlag
instance GHC.Generics.Generic Data.Elf.ElfSegment
instance GHC.Generics.Generic Data.Elf.ElfType
instance GHC.Generics.Generic Data.Elf.ElfOSABI
instance GHC.Generics.Generic Data.Elf.ElfClass
instance GHC.Generics.Generic Data.Elf.ElfData
instance GHC.Generics.Generic Data.Elf.ElfSectionFlags
instance GHC.Generics.Generic Data.Elf.ElfSectionType
instance GHC.Generics.Generic Data.Elf.ElfSection
instance GHC.Generics.Generic Data.Elf.Elf
instance Data.Serialize.Serialize Data.Elf.ElfMachine
instance Data.Serialize.Serialize Data.Elf.ElfSegmentType
instance Data.Serialize.Serialize Data.Elf.ElfSegmentFlag
instance Data.Serialize.Serialize Data.Elf.ElfSegment
instance Data.Serialize.Serialize Data.Elf.ElfType
instance Data.Serialize.Serialize Data.Elf.ElfOSABI
instance Data.Serialize.Serialize Data.Elf.ElfClass
instance Data.Serialize.Serialize Data.Elf.ElfData
instance Data.Serialize.Serialize Data.Elf.ElfSectionFlags
instance Data.Serialize.Serialize Data.Elf.ElfSectionType
instance Data.Serialize.Serialize Data.Elf.ElfSection
instance Data.Serialize.Serialize Data.Elf.Elf
instance Data.Binary.BinaryClass Data.Elf.Elf

module Generic.Address

-- | An unresolved address, within the operand of an instruction, based on
--   polymorphic type <tt>storage</tt>.
data GenericAddress storage

-- | Reading a pointer from a storage
AddressStorage :: storage -> GenericAddress storage

-- | Immediate value
AddressImm :: Word64 -> GenericAddress storage

-- | Minus
AddressMinus :: GenericAddress storage -> GenericAddress storage -> GenericAddress storage

-- | Plus
AddressPlus :: GenericAddress storage -> GenericAddress storage -> GenericAddress storage

-- | Times
AddressTimes :: GenericAddress storage -> GenericAddress storage -> GenericAddress storage

-- | A type for encapsulating an immediate (allows to always show hex)
newtype AddressWord64
AddressWord64 :: Word64 -> AddressWord64
instance GHC.Generics.Generic Generic.Address.AddressWord64
instance GHC.Classes.Ord Generic.Address.AddressWord64
instance GHC.Classes.Eq Generic.Address.AddressWord64
instance GHC.Generics.Generic (Generic.Address.GenericAddress storage)
instance GHC.Classes.Ord storage => GHC.Classes.Ord (Generic.Address.GenericAddress storage)
instance GHC.Classes.Eq storage => GHC.Classes.Eq (Generic.Address.GenericAddress storage)
instance Data.Serialize.Serialize storage => Data.Serialize.Serialize (Generic.Address.GenericAddress storage)
instance GHC.Show.Show storage => GHC.Show.Show (Generic.Address.GenericAddress storage)
instance GHC.Base.Functor Generic.Address.GenericAddress
instance Data.Serialize.Serialize Generic.Address.AddressWord64
instance GHC.Show.Show Generic.Address.AddressWord64

module Generic.BasicBlock
newtype GenericBasicBlock instr
BasicBlock :: [instr] -> GenericBasicBlock instr
[instructions] :: GenericBasicBlock instr -> [instr]
instance GHC.Generics.Generic (Generic.BasicBlock.GenericBasicBlock instr)
instance GHC.Base.Monad Generic.BasicBlock.GenericBasicBlock
instance GHC.Base.Applicative Generic.BasicBlock.GenericBasicBlock
instance Data.Traversable.Traversable Generic.BasicBlock.GenericBasicBlock
instance Data.Foldable.Foldable Generic.BasicBlock.GenericBasicBlock
instance GHC.Base.Functor Generic.BasicBlock.GenericBasicBlock
instance GHC.Classes.Ord instr => GHC.Classes.Ord (Generic.BasicBlock.GenericBasicBlock instr)
instance GHC.Classes.Eq instr => GHC.Classes.Eq (Generic.BasicBlock.GenericBasicBlock instr)
instance Data.Serialize.Serialize instr => Data.Serialize.Serialize (Generic.BasicBlock.GenericBasicBlock instr)
instance GHC.Show.Show instr => GHC.Show.Show (Generic.BasicBlock.GenericBasicBlock instr)

module Generic.Program
data GenericProgram instr
Program :: IntMap (GenericBasicBlock instr) -> Rooted -> GenericProgram instr

-- | A mapping from blockIDs to lists of statements
[basicBlocks] :: GenericProgram instr -> IntMap (GenericBasicBlock instr)

-- | A graph based on integers (blockIDs)
[controlFlow] :: GenericProgram instr -> Rooted
mapBasicBlocks :: (GenericBasicBlock instr1 -> GenericBasicBlock instr2) -> GenericProgram instr1 -> GenericProgram instr2
mapInstructions :: (instr1 -> instr2) -> GenericProgram instr1 -> GenericProgram instr2
foldBasicBlocks :: (a -> GenericBasicBlock instr -> a) -> a -> GenericProgram instr -> a
foldInstructions :: (instr -> a -> a) -> a -> GenericProgram instr -> a
instance GHC.Base.Functor Generic.Program.GenericProgram
instance Data.Foldable.Foldable Generic.Program.GenericProgram
instance GHC.Show.Show instr => GHC.Show.Show (Generic.Program.GenericProgram instr)

module Typeclasses.HasAddress
class HasAddress a
addressof :: HasAddress a => a -> Word64

module Typeclasses.HasSize

-- | Class for things that have a size
class HasSize a
sizeof :: HasSize a => a -> Int

module Generic.Operand

-- | A generic statepart, based on polymorphic type <tt>storage</tt>.
data GenericOperand storage

-- | A region in memory, whose address is stored in the given state part
--   and whose size in bytes is given in the Int
Memory :: GenericAddress storage -> Int -> GenericOperand storage

-- | An address itself, but not the value stored at the address.
EffectiveAddress :: GenericAddress storage -> GenericOperand storage

-- | A storage location such as a register or a variable
Storage :: storage -> GenericOperand storage

-- | An immediate value
Immediate :: Word64 -> GenericOperand storage
instance GHC.Generics.Generic (Generic.Operand.GenericOperand storage)
instance GHC.Classes.Ord storage => GHC.Classes.Ord (Generic.Operand.GenericOperand storage)
instance GHC.Classes.Eq storage => GHC.Classes.Eq (Generic.Operand.GenericOperand storage)
instance Data.Serialize.Serialize storage => Data.Serialize.Serialize (Generic.Operand.GenericOperand storage)
instance GHC.Show.Show storage => GHC.Show.Show (Generic.Operand.GenericOperand storage)
instance Typeclasses.HasSize.HasSize storage => Typeclasses.HasSize.HasSize (Generic.Operand.GenericOperand storage)
instance GHC.Base.Functor Generic.Operand.GenericOperand

module Generic.Instruction

-- | A generic instruction
data GenericInstruction label storage prefix opcode annotation
Instruction :: label -> Maybe prefix -> opcode -> Maybe (GenericOperand storage) -> [GenericOperand storage] -> Maybe annotation -> GenericInstruction label storage prefix opcode annotation

-- | unique identifier of the instruction: can be an immediate address, or
--   a string label
[label] :: GenericInstruction label storage prefix opcode annotation -> label

-- | optional: prefix, e.g., lock or repz
[prefix] :: GenericInstruction label storage prefix opcode annotation -> Maybe prefix

-- | opcode/mnemonic
[opcode] :: GenericInstruction label storage prefix opcode annotation -> opcode

-- | destination operand, possibly none
[dest] :: GenericInstruction label storage prefix opcode annotation -> Maybe (GenericOperand storage)

-- | source operands, possibly empty
[srcs] :: GenericInstruction label storage prefix opcode annotation -> [GenericOperand storage]

-- | optional: an annotation, such as the instruction size
[annot] :: GenericInstruction label storage prefix opcode annotation -> Maybe annotation
instance GHC.Generics.Generic (Generic.Instruction.GenericInstruction label storage prefix opcode annotation)
instance (GHC.Classes.Ord label, GHC.Classes.Ord prefix, GHC.Classes.Ord opcode, GHC.Classes.Ord storage, GHC.Classes.Ord annotation) => GHC.Classes.Ord (Generic.Instruction.GenericInstruction label storage prefix opcode annotation)
instance (GHC.Classes.Eq label, GHC.Classes.Eq prefix, GHC.Classes.Eq opcode, GHC.Classes.Eq storage, GHC.Classes.Eq annotation) => GHC.Classes.Eq (Generic.Instruction.GenericInstruction label storage prefix opcode annotation)
instance (Data.Serialize.Serialize label, Data.Serialize.Serialize storage, Data.Serialize.Serialize prefix, Data.Serialize.Serialize opcode, Data.Serialize.Serialize annotation) => Data.Serialize.Serialize (Generic.Instruction.GenericInstruction label storage prefix opcode annotation)
instance (GHC.Show.Show storage, GHC.Show.Show label, GHC.Show.Show prefix, GHC.Show.Show opcode, GHC.Show.Show annotation) => GHC.Show.Show (Generic.Instruction.GenericInstruction label storage prefix opcode annotation)

module X86.Flag

-- | Flags
data Flag
ZF :: Flag
CF :: Flag
SF :: Flag
OF :: Flag
PF :: Flag
InvalidFlag :: Flag
instance GHC.Classes.Ord X86.Flag.Flag
instance GHC.Classes.Eq X86.Flag.Flag
instance GHC.Show.Show X86.Flag.Flag

module X86.Opcode

-- | Opcodes / mnemonics
data Opcode
InvalidOpcode :: Opcode
AAA :: Opcode
AAD :: Opcode
AAM :: Opcode
AAS :: Opcode
ADC :: Opcode
ADD :: Opcode
ADDPD :: Opcode
ADDPS :: Opcode
ADDSD :: Opcode
ADDSS :: Opcode
ADDSUBPD :: Opcode
ADDUBPS :: Opcode
AND :: Opcode
ANDNPD :: Opcode
ANDNPS :: Opcode
ANDPD :: Opcode
ANDPS :: Opcode
ARPL :: Opcode
BLENDVPD :: Opcode
BLENDVPS :: Opcode
BOUND :: Opcode
BSF :: Opcode
BSR :: Opcode
BT :: Opcode
BTC :: Opcode
BTR :: Opcode
BTS :: Opcode
CALL :: Opcode
CALLF :: Opcode
CBW :: Opcode
CDQ :: Opcode
CDQE :: Opcode
CLC :: Opcode
CLD :: Opcode
CLFLUSH :: Opcode
CLI :: Opcode
CLTS :: Opcode
CMC :: Opcode
CMOVA :: Opcode
CMOVAE :: Opcode
CMOVB :: Opcode
CMOVBE :: Opcode
CMOVC :: Opcode
CMOVE :: Opcode
CMOVG :: Opcode
CMOVGE :: Opcode
CMOVL :: Opcode
CMOVLE :: Opcode
CMOVNA :: Opcode
CMOVNAE :: Opcode
CMOVNB :: Opcode
CMOVNBE :: Opcode
CMOVNC :: Opcode
CMOVNE :: Opcode
CMOVNG :: Opcode
CMOVNGE :: Opcode
CMOVNL :: Opcode
CMOVNLE :: Opcode
CMOVNO :: Opcode
CMOVNP :: Opcode
CMOVNS :: Opcode
CMOVNZ :: Opcode
CMOVO :: Opcode
CMOVP :: Opcode
CMOVPE :: Opcode
CMOVPO :: Opcode
CMOVS :: Opcode
CMOVZ :: Opcode
CMP :: Opcode
CMPEQSD :: Opcode
CMPNEQSD :: Opcode
CMPNLESD :: Opcode
CMPLTSD :: Opcode
CMPS :: Opcode
CMPSB :: Opcode
CMPSD :: Opcode
CMPSW :: Opcode
CMPXCHG :: Opcode
CMPXCHG16B :: Opcode
CMPXCHG8B :: Opcode
COMISD :: Opcode
COMISS :: Opcode
CPUID :: Opcode
CQO :: Opcode
CVTDQ2PD :: Opcode
CVTSD2SS :: Opcode
CVTSI2SD :: Opcode
CVTSI2SS :: Opcode
CVTSS2SD :: Opcode
CVTTSD2SI :: Opcode
CVTTSS2SI :: Opcode
CVTTPD2DQ :: Opcode
CWD :: Opcode
CWDE :: Opcode
DAA :: Opcode
DAS :: Opcode
DEC :: Opcode
DIV :: Opcode
DIVPD :: Opcode
DIVPS :: Opcode
DIVSD :: Opcode
DIVSS :: Opcode
EMMS :: Opcode
ENDBR64 :: Opcode
ENTER :: Opcode
EXTRACTPS :: Opcode
FABS :: Opcode
FADD :: Opcode
FADDP :: Opcode
FBLD :: Opcode
FBSTP :: Opcode
FCHS :: Opcode
FCLEX :: Opcode
FCMOVB :: Opcode
FCMOVBE :: Opcode
FCMOVE :: Opcode
FCMOVNB :: Opcode
FCMOVNBE :: Opcode
FCMOVNE :: Opcode
FCMOVNU :: Opcode
FCMOVU :: Opcode
FCOM :: Opcode
FCOMI :: Opcode
FCOMIP :: Opcode
FCOMP :: Opcode
FCOMPI :: Opcode
FCOMPP :: Opcode
FCOS :: Opcode
FDIV :: Opcode
FDIVP :: Opcode
FDIVR :: Opcode
FDIVRP :: Opcode
FFREE :: Opcode
FRNDINT :: Opcode
FIADD :: Opcode
FICOM :: Opcode
FICOMP :: Opcode
FIDIV :: Opcode
FIDIVR :: Opcode
FILD :: Opcode
FIMUL :: Opcode
FINIT :: Opcode
FIST :: Opcode
FISTP :: Opcode
FISTPP :: Opcode
FISTTP :: Opcode
FISUB :: Opcode
FISUBR :: Opcode
FLD :: Opcode
FLD1 :: Opcode
FLDCW :: Opcode
FLDENV :: Opcode
FLDL2E :: Opcode
FLDL2T :: Opcode
FLDLG2 :: Opcode
FLDLN2 :: Opcode
FLDPI :: Opcode
FLDZ :: Opcode
FMUL :: Opcode
FMULP :: Opcode
FNOP :: Opcode
FNINIT :: Opcode
FNSTCW :: Opcode
FPREM1 :: Opcode
FRSTOR :: Opcode
FSAVE :: Opcode
FSIN :: Opcode
FSINCOS :: Opcode
FSCALE :: Opcode
FSQRT :: Opcode
FST :: Opcode
FSTCW :: Opcode
FSTENV :: Opcode
FSTP :: Opcode
FSTSW :: Opcode
FSUB :: Opcode
FSUBP :: Opcode
FSUBR :: Opcode
FSUBRP :: Opcode
FTST :: Opcode
FUCOM :: Opcode
FUCOMI :: Opcode
FUCOMIP :: Opcode
FUCOMP :: Opcode
FUCOMPI :: Opcode
FUCOMPP :: Opcode
FXAM :: Opcode
FXCH :: Opcode
FXRSTOR :: Opcode
FXSAVE :: Opcode
FXTRACT :: Opcode
HADDPD :: Opcode
HADDPS :: Opcode
HLT :: Opcode
HSUBPD :: Opcode
HSUBPS :: Opcode
IDIV :: Opcode
IMUL :: Opcode
BSWAP :: Opcode
IN :: Opcode
INC :: Opcode
INS :: Opcode
INSD :: Opcode
INT :: Opcode
INT3 :: Opcode
INTO :: Opcode
INVD :: Opcode
INVLPG :: Opcode
INVPCID :: Opcode
IRET :: Opcode
IRETD :: Opcode
IRETQ :: Opcode
JA :: Opcode
JAE :: Opcode
JB :: Opcode
JBE :: Opcode
JC :: Opcode
JCXZ :: Opcode
JE :: Opcode
JECXZ :: Opcode
JG :: Opcode
JGE :: Opcode
JL :: Opcode
JLE :: Opcode
JMP :: Opcode
JMPF :: Opcode
JMPN :: Opcode
JNAE :: Opcode
JNA :: Opcode
JNB :: Opcode
JNBE :: Opcode
JNC :: Opcode
JNG :: Opcode
JNE :: Opcode
JNGE :: Opcode
JNLE :: Opcode
JNL :: Opcode
JNO :: Opcode
JNP :: Opcode
JNS :: Opcode
JNZ :: Opcode
JO :: Opcode
JP :: Opcode
JPE :: Opcode
JPO :: Opcode
JRCXZ :: Opcode
JS :: Opcode
JZ :: Opcode
LAHF :: Opcode
LAR :: Opcode
LDDQU :: Opcode
LDMXCSR :: Opcode
LDS :: Opcode
LEA :: Opcode
LEAVE :: Opcode
LES :: Opcode
LFENCE :: Opcode
LFS :: Opcode
LGDT :: Opcode
LGS :: Opcode
LIDT :: Opcode
LLDT :: Opcode
LMSW :: Opcode
LODS :: Opcode
LODSB :: Opcode
LODSD :: Opcode
LODSW :: Opcode
LOOP :: Opcode
LOOPE :: Opcode
LOOPNE :: Opcode
LSL :: Opcode
LSS :: Opcode
LTR :: Opcode
MASKMOVQ :: Opcode
MAXPD :: Opcode
MAXPS :: Opcode
MAXSD :: Opcode
MAXSS :: Opcode
MFENCE :: Opcode
MINPD :: Opcode
MINPS :: Opcode
MINSD :: Opcode
MINSS :: Opcode
MONITOR :: Opcode
MOV :: Opcode
MOVABS :: Opcode
MOVAPD :: Opcode
MOVAPS :: Opcode
MOVD :: Opcode
MOVDDUP :: Opcode
MOVDQA :: Opcode
MOVDQU :: Opcode
MOVHLPS :: Opcode
MOVHPD :: Opcode
MOVHPS :: Opcode
MOVLHPS :: Opcode
MOVLPD :: Opcode
MOVLPS :: Opcode
MOVLSDUP :: Opcode
MOVMSKPD :: Opcode
MOVMSKPS :: Opcode
MOVNTDQ :: Opcode
MOVNTPD :: Opcode
MOVNTPS :: Opcode
MOVNTQ :: Opcode
MOVQ :: Opcode
MOVS :: Opcode
MOVSB :: Opcode
MOVSD :: Opcode
MOVSLDUP :: Opcode
MOVSS :: Opcode
MOVSQ :: Opcode
MOVSX :: Opcode
MOVSXB :: Opcode
MOVSXD :: Opcode
MOVSXW :: Opcode
MOVUPD :: Opcode
MOVUPS :: Opcode
MOVZX :: Opcode
MOVZXB :: Opcode
MOVZXW :: Opcode
MUL :: Opcode
MULPD :: Opcode
MULPS :: Opcode
MULSD :: Opcode
MULSS :: Opcode
MWAIT :: Opcode
NEG :: Opcode
NOP :: Opcode
NOT :: Opcode
OR :: Opcode
ORPD :: Opcode
ORPS :: Opcode
OUT :: Opcode
OUTS :: Opcode
PALIGNR :: Opcode
PACKSSDW :: Opcode
PACKSSWB :: Opcode
PADDB :: Opcode
PADDD :: Opcode
PADDQ :: Opcode
PADDSB :: Opcode
PADDSW :: Opcode
PADDUSB :: Opcode
PADDUSW :: Opcode
PADDW :: Opcode
PAND :: Opcode
PANDN :: Opcode
PAUSE :: Opcode
PAVGB :: Opcode
PAVGW :: Opcode
PBLENDW :: Opcode
PCLMULQDQ :: Opcode
PCMPEQB :: Opcode
PCMPEQD :: Opcode
PCMPGTB :: Opcode
PCMPGTD :: Opcode
PEXTRB :: Opcode
PEXTRD :: Opcode
PEXTRQ :: Opcode
PHADDD :: Opcode
PINSRB :: Opcode
PINSRD :: Opcode
PINSRQ :: Opcode
PMADDWD :: Opcode
PMAXSD :: Opcode
PMAXSW :: Opcode
PMAXUB :: Opcode
PMAXUD :: Opcode
PMAXUQ :: Opcode
PMINSD :: Opcode
PMINSW :: Opcode
PMINUB :: Opcode
PMINUD :: Opcode
PMOVMSKB :: Opcode
PMOVSXDQ :: Opcode
PMOVZXDQ :: Opcode
PMOVSXBD :: Opcode
PMOVZXBD :: Opcode
PMULLD :: Opcode
PMULLQ :: Opcode
PMULHUW :: Opcode
PMULHW :: Opcode
PMULLW :: Opcode
PMULUDQ :: Opcode
POP :: Opcode
POPA :: Opcode
POPAD :: Opcode
POPF :: Opcode
POPFD :: Opcode
POPFQ :: Opcode
POR :: Opcode
PREFETCHNTA :: Opcode
PREFETCHT0 :: Opcode
PREFETCHT1 :: Opcode
PREFETCHT2 :: Opcode
PSADBW :: Opcode
PSHUFB :: Opcode
PSHUFD :: Opcode
PSHUFLW :: Opcode
PSLLD :: Opcode
PSLLDQ :: Opcode
PSLLQ :: Opcode
PSLLW :: Opcode
PSRAD :: Opcode
PSRAW :: Opcode
PSRLD :: Opcode
PSRLDQ :: Opcode
PSRLQ :: Opcode
PSRLW :: Opcode
PSUBB :: Opcode
PSUBD :: Opcode
PSUBQ :: Opcode
PSUBSB :: Opcode
PSUBSQ :: Opcode
PSUBUSB :: Opcode
PSUBUSW :: Opcode
PSUBW :: Opcode
PTEST :: Opcode
PUNPCKLBW :: Opcode
PUNPCKLWD :: Opcode
PUNPCKLDQ :: Opcode
PUNPCKLQDQ :: Opcode
PUSH :: Opcode
PUSHA :: Opcode
PUSHAD :: Opcode
PUSHF :: Opcode
PUSHFD :: Opcode
PUSHFQ :: Opcode
PXOR :: Opcode
RCL :: Opcode
RCPPS :: Opcode
RCPSS :: Opcode
RCR :: Opcode
RDMSR :: Opcode
RDPMC :: Opcode
RDTSC :: Opcode
RET :: Opcode
RETF :: Opcode
RETN :: Opcode
ROL :: Opcode
ROR :: Opcode
ROUNDSD :: Opcode
ROUNDSS :: Opcode
RSM :: Opcode
RSQRTPS :: Opcode
RSQRTSS :: Opcode
SAHF :: Opcode
SAL :: Opcode
SAR :: Opcode
SBB :: Opcode
SCAS :: Opcode
SCASB :: Opcode
SCASD :: Opcode
SETA :: Opcode
SETAE :: Opcode
SETB :: Opcode
SETBE :: Opcode
SETC :: Opcode
SETE :: Opcode
SETG :: Opcode
SETGE :: Opcode
SETL :: Opcode
SETLE :: Opcode
SETNA :: Opcode
SETNAE :: Opcode
SETNB :: Opcode
SETNBE :: Opcode
SETNC :: Opcode
SETNE :: Opcode
SETNG :: Opcode
SETNGE :: Opcode
SETNL :: Opcode
SETNLE :: Opcode
SETNO :: Opcode
SETNP :: Opcode
SETNS :: Opcode
SETNZ :: Opcode
SETO :: Opcode
SETP :: Opcode
SETPE :: Opcode
SETPO :: Opcode
SETS :: Opcode
SETZ :: Opcode
SFENCE :: Opcode
SGDT :: Opcode
SHL :: Opcode
SHLD :: Opcode
SHR :: Opcode
SHRD :: Opcode
SHUFPS :: Opcode
SIDT :: Opcode
SLDT :: Opcode
SMSW :: Opcode
SQRTPD :: Opcode
SQRTPS :: Opcode
SQRTSD :: Opcode
SQRTSS :: Opcode
STC :: Opcode
STD :: Opcode
STI :: Opcode
STMXCSR :: Opcode
STOS :: Opcode
STOSB :: Opcode
STOSD :: Opcode
STOSQ :: Opcode
STR :: Opcode
SUB :: Opcode
SUBPD :: Opcode
SUBPS :: Opcode
SUBSD :: Opcode
SUBSS :: Opcode
SWAPGS :: Opcode
SYSCALL :: Opcode
SYSENTER :: Opcode
SYSEXIT :: Opcode
SYSRET :: Opcode
TEST :: Opcode
UCOMISD :: Opcode
UCOMISS :: Opcode
UD2 :: Opcode
UNPCKHPD :: Opcode
UNPCKHPS :: Opcode
UNPCKLPD :: Opcode
UNPCKLPS :: Opcode
VANDPD :: Opcode
VANDPS :: Opcode
VADDPD :: Opcode
VADDPS :: Opcode
VBLENDPS :: Opcode
VERR :: Opcode
VERW :: Opcode
VEXTRACTI128 :: Opcode
VEXTRACTF128 :: Opcode
VINSERTF128 :: Opcode
VMCALL :: Opcode
VMCLEAR :: Opcode
VMLAUNCH :: Opcode
VMOVAPD :: Opcode
VMOVAPS :: Opcode
VMOVHPS :: Opcode
VMOVD :: Opcode
VMOVDQA :: Opcode
VMOVDQU :: Opcode
VMOVLHPS :: Opcode
VMPTRLD :: Opcode
VMPTRST :: Opcode
VMREAD :: Opcode
VMRESUME :: Opcode
VMWRITE :: Opcode
VMULPD :: Opcode
VMULPS :: Opcode
VMXOFF :: Opcode
VMXON :: Opcode
VPALIGNR :: Opcode
VPAND :: Opcode
VPANDN :: Opcode
VPCMPEQB :: Opcode
VPCMPEQW :: Opcode
VPERM2F128 :: Opcode
VPERM2I128 :: Opcode
VPERMILPS :: Opcode
VPOR :: Opcode
VPSHUFB :: Opcode
VPSHUFD :: Opcode
VPSLLW :: Opcode
VSHUFPS :: Opcode
VSHUFPD :: Opcode
VPXOR :: Opcode
VPUNPCKLWD :: Opcode
VPUNPCKHWD :: Opcode
VSUBPD :: Opcode
VSUBPS :: Opcode
VUNPCKHPS :: Opcode
VUNPCKLPS :: Opcode
VXORPD :: Opcode
VXORPS :: Opcode
VZEROUPPER :: Opcode
WAIT :: Opcode
WBINVD :: Opcode
WRFSBASE :: Opcode
WRGSBASE :: Opcode
WRMSR :: Opcode
XADD :: Opcode
XCHG :: Opcode
XGETBV :: Opcode
XLAT :: Opcode
XLATB :: Opcode
XSETBV :: Opcode
XSAVEOPT :: Opcode
XRSTOR :: Opcode
XOR :: Opcode
XORPD :: Opcode
XORPS :: Opcode

-- | Returns true iff m is the mnemonic of a jump
isJump :: Opcode -> Bool

-- | Returns true iff m is the mnemonic of a conditional jump
isCondJump :: Opcode -> Bool

-- | Returns true iff m is the mnemonic of a call
isCall :: Opcode -> Bool

-- | Returns true iff m is the mnemonic of a return
isRet :: Opcode -> Bool

-- | Returns true iff m is the mnemonic of a halting instruction
isHalt :: Opcode -> Bool
instance GHC.Generics.Generic X86.Opcode.Opcode
instance GHC.Classes.Ord X86.Opcode.Opcode
instance GHC.Classes.Eq X86.Opcode.Opcode
instance GHC.Show.Show X86.Opcode.Opcode
instance Data.Serialize.Serialize X86.Opcode.Opcode

module IR.Opcode
data Opcode
OpcodeX86 :: Opcode -> Opcode
OpcodePhi :: Opcode
OpcodeConvert :: Opcode
instance GHC.Generics.Generic IR.Opcode.Opcode
instance GHC.Classes.Ord IR.Opcode.Opcode
instance GHC.Classes.Eq IR.Opcode.Opcode
instance Data.Serialize.Serialize IR.Opcode.Opcode
instance GHC.Show.Show IR.Opcode.Opcode

module X86.Prefix
data Prefix
InvalidPrefix :: Prefix
REP :: Prefix
REPZ :: Prefix
REPNE :: Prefix
LOCK :: Prefix
BND :: Prefix
instance GHC.Generics.Generic X86.Prefix.Prefix
instance GHC.Read.Read X86.Prefix.Prefix
instance GHC.Classes.Ord X86.Prefix.Prefix
instance GHC.Classes.Eq X86.Prefix.Prefix
instance GHC.Show.Show X86.Prefix.Prefix
instance Data.Serialize.Serialize X86.Prefix.Prefix

module X86.Register
data Register
InvalidRegister :: Register
RIP :: Register
EIP :: Register
RAX :: Register
EAX :: Register
AX :: Register
AH :: Register
AL :: Register
RBX :: Register
EBX :: Register
BX :: Register
BH :: Register
BL :: Register
RCX :: Register
ECX :: Register
CX :: Register
CH :: Register
CL :: Register
RDX :: Register
EDX :: Register
DX :: Register
DH :: Register
DL :: Register
RDI :: Register
EDI :: Register
DI :: Register
DIL :: Register
RSI :: Register
ESI :: Register
SI :: Register
SIL :: Register
RSP :: Register
ESP :: Register
SP :: Register
SPL :: Register
RBP :: Register
EBP :: Register
BP :: Register
BPL :: Register
R15 :: Register
R15D :: Register
R15W :: Register
R15B :: Register
R14 :: Register
R14D :: Register
R14W :: Register
R14B :: Register
R13 :: Register
R13D :: Register
R13W :: Register
R13B :: Register
R12 :: Register
R12D :: Register
R12W :: Register
R12B :: Register
R11 :: Register
R11D :: Register
R11W :: Register
R11B :: Register
R10 :: Register
R10D :: Register
R10W :: Register
R10B :: Register
R9 :: Register
R9D :: Register
R9W :: Register
R9B :: Register
R8 :: Register
R8D :: Register
R8W :: Register
R8B :: Register
CS :: Register
DS :: Register
ES :: Register
FS :: Register
GS :: Register
SS :: Register
EIZ :: Register
RIZ :: Register
ST0 :: Register
ST1 :: Register
ST2 :: Register
ST3 :: Register
ST4 :: Register
ST5 :: Register
ST6 :: Register
ST7 :: Register
YMM0 :: Register
YMM1 :: Register
YMM2 :: Register
YMM3 :: Register
YMM4 :: Register
YMM5 :: Register
YMM6 :: Register
YMM7 :: Register
YMM8 :: Register
YMM9 :: Register
YMM10 :: Register
YMM11 :: Register
YMM12 :: Register
YMM13 :: Register
YMM14 :: Register
YMM15 :: Register
XMM0 :: Register
XMM1 :: Register
XMM2 :: Register
XMM3 :: Register
XMM4 :: Register
XMM5 :: Register
XMM6 :: Register
XMM7 :: Register
XMM8 :: Register
XMM9 :: Register
XMM10 :: Register
XMM11 :: Register
XMM12 :: Register
XMM13 :: Register
XMM14 :: Register
XMM15 :: Register

-- | List of 8 bit registers
reg8 :: [Register]

-- | List of 16 bit registers
reg16 :: [Register]

-- | List of 32 bit registers
reg32 :: [Register]

-- | List of 64 bit registers
reg64 :: [Register]

-- | List of 80 bit registers
reg80 :: [Register]

-- | List of 128 bit registers
reg128 :: [Register]

-- | List of 256 bit registers
reg256 :: [Register]

-- | Matches register names to the real registers E.g.: EAX is actually a
--   part of RAX
real :: Register -> Register

-- | Finds for a register all register that overlap with it. | These have
--   the same <a>real</a> register (apart from special cases). | For
--   example, RAX is overlapping with EAX, AX, AL, AH | AH is only
--   overlapping with RAX, EAX, AX; but not AL
overlapping :: Register -> [Register]
instance GHC.Enum.Bounded X86.Register.Register
instance GHC.Enum.Enum X86.Register.Register
instance GHC.Generics.Generic X86.Register.Register
instance GHC.Classes.Ord X86.Register.Register
instance GHC.Read.Read X86.Register.Register
instance GHC.Classes.Eq X86.Register.Register
instance GHC.Show.Show X86.Register.Register
instance Data.Serialize.Serialize X86.Register.Register
instance Typeclasses.HasSize.HasSize X86.Register.Register

module X86.Operand
type Operand = GenericOperand Register

-- | A generic statepart, based on polymorphic type <tt>storage</tt>.
data GenericOperand storage

module X86.Instruction
type Instruction = GenericInstruction AddressWord64 Register Prefix Opcode Int

-- | Canonicalizes an instruction by making sure there is at most one
--   output and inputs/outputs are syntactically clear. | For example, the
--   IMUL instruction comes in different flavors that hide the actual
--   inputs and outputs to multiple registers
canonicalize :: Instruction -> [Instruction]
instance Typeclasses.HasSize.HasSize X86.Instruction.Instruction
instance Typeclasses.HasAddress.HasAddress X86.Instruction.Instruction

module X86.BasicBlock
type BasicBlock = GenericBasicBlock Instruction


module X86.Conventions

-- | A list of function names of functions that never return.
is_exiting_function_call :: [Char] -> Bool
strip_GLIBC :: String -> String

-- | Overview of sections with instructions.
sections_with_instructions :: [([Char], [Char])]

-- | Sections in the following list are assumed not to be modifiable during
--   execution, i.e., constant.
section_is_unwritable :: ([Char], [Char]) -> Bool

-- | A list if registers that are non-volatile, i.e., that must be
--   preserved by a function (callee-saved)
callee_saved_registers :: [Register]

-- | A list of registers that may be used for return values
return_registers :: [Register]

-- | A list of registers used as parameters
parameter_registers :: [Register]

module X86.Address
type Address = GenericAddress Register

module Data.Variable

-- | A mutable or immutable variable
data Variable
Variable :: !String -> !Maybe Int -> !Int -> Variable

-- | Name of the variable
[name] :: Variable -> !String

-- | Index for immutable (SSA) variables, Nothing otherwise
[index] :: Variable -> !Maybe Int

-- | Size in byte
[size] :: Variable -> !Int

-- | Copies the value of one variable to another while extracting (or
--   extending) the correct bits
data VariableConversion
VariableConversion :: !Variable -> !Variable -> !Bool -> VariableConversion

-- | The variable to copy from
[source] :: VariableConversion -> !Variable

-- | The variable to copy to
[destination] :: VariableConversion -> !Variable

-- | Used when we don't want to extract the lowest 8 bits, but rather the
--   highest 8 of the lowest 16 bits
[isLow] :: VariableConversion -> !Bool
isSSA :: Variable -> Bool
fromRegister :: Register -> Variable
instance GHC.Generics.Generic Data.Variable.Variable
instance GHC.Classes.Ord Data.Variable.Variable
instance GHC.Classes.Eq Data.Variable.Variable
instance GHC.Generics.Generic Data.Variable.VariableConversion
instance GHC.Classes.Ord Data.Variable.VariableConversion
instance GHC.Classes.Eq Data.Variable.VariableConversion
instance Data.Serialize.Serialize Data.Variable.VariableConversion
instance GHC.Show.Show Data.Variable.VariableConversion
instance Data.Serialize.Serialize Data.Variable.Variable
instance GHC.Show.Show Data.Variable.Variable

module IR.Operand
type Operand = GenericOperand Variable

module IR.Instruction
type Instruction = GenericInstruction AddressWord64 Variable Prefix Opcode Void
instance Typeclasses.HasAddress.HasAddress IR.Instruction.Instruction

module IR.Program
type Program = GenericProgram Instruction

module IR.BasicBlock
type BasicBlock = GenericBasicBlock Instruction

module IR.Address
type Address = GenericAddress Variable

module Data.Phi

-- | Phi node with one destination and multiple sources
data Phi
Phi :: !Variable -> ![Variable] -> Phi
[destination] :: Phi -> !Variable
[sources] :: Phi -> ![Variable]

-- | Creates an initial Phi node for the variable with n incoming edges
phiForVariable :: Variable -> Int -> Phi
instance GHC.Classes.Ord Data.Phi.Phi
instance GHC.Classes.Eq Data.Phi.Phi
instance GHC.Show.Show Data.Phi.Phi


-- | A datatype for symbolic predicates, tailored to storing information on
--   equalities between the current values stored in state parts (lhs) and
--   constant expressions (rhs).
module Data.SimplePred

-- | A symbolic predicate consists of:
--   
--   <ul>
--   <li>A mapping from stateparts to symbolic expressions.</li>
--   <li>The status of the flags.</li>
--   <li>A set of verification conditions.</li>
--   </ul>
data Pred
Predicate :: Map StatePart SimpleExpr -> FlagStatus -> Pred

-- | A statepart is either a register or a region in memory
data StatePart

-- | The stack pointer of the given function
SP_StackPointer :: String -> StatePart

-- | A register
SP_Reg :: Register -> StatePart

-- | A region with a symbolic address and an immediate size.
SP_Mem :: SimpleExpr -> Int -> StatePart

-- | A symbolic expression with as leafs either immediates, variables, live
--   values of stateparts, or malloced addresses. A variable is a constant
--   representing some initial value, e.g., RDI_0, or [RSP_0,8]_0. A
--   statepart evaluates to its current value, e.g., RDI or [RSP,8].
data SimpleExpr

-- | An immediate word
SE_Immediate :: Word64 -> SimpleExpr

-- | A variable representing the initial value stored in the statepart
--   (e.g., RSP0)
SE_Var :: StatePart -> SimpleExpr

-- | The value stored currently in the statepart
SE_StatePart :: StatePart -> SimpleExpr

-- | A malloc return value with possibly an ID
SE_Malloc :: Maybe Word64 -> Maybe String -> SimpleExpr

-- | Application of an <tt><a>Operator</a></tt> to the list of arguments
SE_Op :: Operator -> [SimpleExpr] -> SimpleExpr

-- | Taking the lower bits of a value
SE_Bit :: Int -> SimpleExpr -> SimpleExpr

-- | Sign extension
SE_SExtend :: Int -> Int -> SimpleExpr -> SimpleExpr

-- | Overwriting certain bits of a value with bits from another value
SE_Overwrite :: Int -> SimpleExpr -> SimpleExpr -> SimpleExpr

-- | Bottom (unknown value)
Bottom :: BotTyp -> SimpleExpr

-- | Symbolically represent the status of all flags in the current state
data FlagStatus

-- | No information known, flags could have any value
None :: FlagStatus

-- | The flags are set by the x86 CMP instruction applied to the given
--   operands.
FS_CMP :: Maybe Bool -> Operand -> Operand -> FlagStatus

-- | Bot represents an unknown (bottom) value. We annotate each occurence
--   of Bot with a BotTyp. This type indicates where the bottom value
--   originates from. The latter six are all equal, we just use them for
--   debugging and information. They indicate that the value is unknown,
--   but was computed using the set of sources.
data BotTyp

-- | The expression evaluates to one of the expressions in the set
FromNonDeterminism :: Set SimpleExpr -> BotTyp

-- | The expression is a pointer-computation with known base(s)
FromPointerBases :: Set PointerBase -> BotTyp

-- | Return value of a function call
FromCall :: String -> BotTyp

-- | The expression is some computation based on sources.
FromSources :: Set BotSrc -> BotTyp

-- | A read from two possibly overlapping regions
FromOverlap :: Set BotSrc -> BotTyp

-- | A write to two possibly overlapping regions
FromMemWrite :: Set BotSrc -> BotTyp

-- | An instruction with unknown semantics
FromSemantics :: Set BotSrc -> BotTyp

-- | Should not happen, but if a register writes to a registeralias with
--   unknown bit size
FromBitMode :: Set BotSrc -> BotTyp

-- | Reading from memory not written to yet
FromUninitializedMemory :: Set BotSrc -> BotTyp

-- | Sources that may be used to compute an expression. That is, the inputs
--   to an expression.
data BotSrc

-- | An initial variable, i.e., a constant
Src_Var :: StatePart -> BotSrc

-- | The stack pointer of the given function
Src_StackPointer :: String -> BotSrc

-- | A malloced address
Src_Malloc :: Maybe Word64 -> Maybe String -> BotSrc

-- | An immediate used in the computation of the pointer
Src_ImmediateAddress :: Word64 -> BotSrc

-- | A return value from a function
Src_Function :: String -> BotSrc

-- | An operator is a pure operation over bit-vectors, annotated with the
--   bit-size of its operands. For example, <tt>Plus 64</tt> denotes 64-bit
--   addition. <tt>Udiv</tt> and <tt>Times</tt> are operators op type <tt>w
--   -&gt; w -&gt; w</tt> with all words same length. <tt>Div</tt> and
--   <tt>Div_Rem</tt> are operators of type <tt>w -&gt; w -&gt; w -&gt;
--   w</tt> performing concatenation of the first two words and then doing
--   division/remainder.
data Operator
Minus :: Int -> Operator
Plus :: Int -> Operator
Times :: Int -> Operator
And :: Int -> Operator
Or :: Int -> Operator
Xor :: Int -> Operator
Not :: Int -> Operator
SetXX :: Operator
Bsr :: Int -> Operator
Div_Rem :: Int -> Operator
Div :: Int -> Operator
Shl :: Int -> Operator
Shr :: Int -> Operator
Sar :: Int -> Operator
Udiv :: Int -> Operator
Ror :: Int -> Operator
Rol :: Int -> Operator
Bswap :: Int -> Operator
Pextr :: Int -> Operator

-- | A pointerbase is a positive addend of a symbolic expression that may
--   represent a pointer.
data PointerBase

-- | The stack frame of the given function
StackPointer :: String -> PointerBase

-- | A malloc (at the <i>heap</i>) at a given address (hash is unused for
--   now)
Malloc :: Maybe Word64 -> Maybe String -> PointerBase

-- | A <i>global</i> address in the range of the sections of the binary.
GlobalAddress :: Word64 -> PointerBase

-- | An address with an associated symbol.
PointerToSymbol :: Word64 -> String -> PointerBase

-- | Returns true iff the expression is an immediate value
is_immediate :: SimpleExpr -> Bool

-- | Is the statepart memory?
is_mem_sp :: StatePart -> Bool

-- | Is the statepart a register?
is_reg_sp :: StatePart -> Bool

-- | Returns true iff the expression contains Bot
contains_bot :: SimpleExpr -> Bool

-- | Returns true iff the statepart contains Bot
contains_bot_sp :: StatePart -> Bool

-- | Do all occurences of Bottom satisfy the given predicate?
all_bot_satisfy :: (BotTyp -> Bool) -> SimpleExpr -> Bool

-- | Simplification of symbolic expressions.
--   
--   Must always produce an expression logically equivalent to the
--   original. TODO:
--   overwrite(8,Bot[src|RSP_0x1000070ec,malloc<tt>100007204()|],b8(Bot[m|RSP_0x1000070ec,malloc</tt>100007204()|]))
simp :: SimpleExpr -> SimpleExpr

-- | The lowest botom element
rock_bottom :: SimpleExpr

-- | Pretty print expression, showing Bottom expressions only as Bot
pp_expr :: SimpleExpr -> [Char]

-- | Pretty print predicate, showing Bottom expressions only as Bot
pp_pred :: Pred -> String

expr_size :: SimpleExpr -> Int
instance GHC.Classes.Ord Data.SimplePred.PointerBase
instance GHC.Classes.Eq Data.SimplePred.PointerBase
instance GHC.Generics.Generic Data.SimplePred.PointerBase
instance GHC.Generics.Generic Data.SimplePred.Operator
instance GHC.Classes.Ord Data.SimplePred.Operator
instance GHC.Classes.Eq Data.SimplePred.Operator
instance GHC.Generics.Generic Data.SimplePred.BotSrc
instance GHC.Classes.Ord Data.SimplePred.BotSrc
instance GHC.Classes.Eq Data.SimplePred.BotSrc
instance GHC.Generics.Generic Data.SimplePred.BotTyp
instance GHC.Classes.Ord Data.SimplePred.BotTyp
instance GHC.Classes.Eq Data.SimplePred.BotTyp
instance GHC.Generics.Generic Data.SimplePred.SimpleExpr
instance GHC.Classes.Ord Data.SimplePred.SimpleExpr
instance GHC.Classes.Eq Data.SimplePred.SimpleExpr
instance GHC.Generics.Generic Data.SimplePred.StatePart
instance GHC.Classes.Ord Data.SimplePred.StatePart
instance GHC.Classes.Eq Data.SimplePred.StatePart
instance GHC.Classes.Ord Data.SimplePred.FlagStatus
instance GHC.Classes.Eq Data.SimplePred.FlagStatus
instance GHC.Generics.Generic Data.SimplePred.FlagStatus
instance GHC.Classes.Ord Data.SimplePred.Pred
instance GHC.Classes.Eq Data.SimplePred.Pred
instance GHC.Generics.Generic Data.SimplePred.Pred
instance Data.Serialize.Serialize Data.SimplePred.Pred
instance GHC.Show.Show Data.SimplePred.Pred
instance Data.Serialize.Serialize Data.SimplePred.FlagStatus
instance GHC.Show.Show Data.SimplePred.FlagStatus
instance GHC.Show.Show Data.SimplePred.BotSrc
instance GHC.Show.Show Data.SimplePred.BotTyp
instance GHC.Show.Show Data.SimplePred.SimpleExpr
instance GHC.Show.Show Data.SimplePred.StatePart
instance Data.Serialize.Serialize Data.SimplePred.BotTyp
instance Data.Serialize.Serialize Data.SimplePred.BotSrc
instance Data.Serialize.Serialize Data.SimplePred.StatePart
instance Data.Serialize.Serialize Data.SimplePred.SimpleExpr
instance GHC.Show.Show Data.SimplePred.Operator
instance Data.Serialize.Serialize Data.SimplePred.Operator
instance GHC.Show.Show Data.SimplePred.PointerBase
instance Data.Serialize.Serialize Data.SimplePred.PointerBase


-- | The context stores, among others, information obtained during
--   verification, such as CFGs, invariants, etc. (see
--   <tt><a>Context</a></tt>). Module <a>VerificationReportInterface</a>
--   provides functions for obtaining and interfacing with a
--   <tt>Context</tt>.
module Analysis.Context
read_binary :: String -> IO (Maybe Binary)

-- | A control flow graph with blocks and edges. A blockID (represented as
--   an <tt>Int</tt>) is a unique identifier of a basic block. We store
--   basic blocks twice: once as addresses, and once as instructions.
data CFG
CFG :: IntMap [Int] -> IntMap IntSet -> IntMap Int -> Int -> IntMap [Instruction] -> CFG

-- | A mapping of blockIDs to instruction addresses
[cfg_blocks] :: CFG -> IntMap [Int]

-- | A mapping of blockIDs to sets of blocKIDs
[cfg_edges] :: CFG -> IntMap IntSet

-- | A mapping of instruction addresses to blockIDs
[cfg_addr_to_blockID] :: CFG -> IntMap Int

-- | A fresh blockID
[cfg_fresh] :: CFG -> Int

-- | A mapping of blockIDs to lists of disassembled instructions.
[cfg_instrs] :: CFG -> IntMap [Instruction]

-- | A jump table Let the actual indirection be <tt>JMP RAX</tt>, implying
--   jt_trgt_operand == RAX. This jump table can be implemented with
--   inserting this instruction before the indirection:
--   
--   MOV jt_trgt_operand, QWORD PTR [jt_address + 8*jt_index_operand]
data JumpTable
JumpTable :: Operand -> Operand -> [Int] -> JumpTable

-- | The operand that is bounded by some immediate, serving as an index
--   into a table
[jt_index_operand] :: JumpTable -> Operand

-- | The operand of the jump
[jt_trgt_operand] :: JumpTable -> Operand

-- | An ordered list of instruction addresses to which is jumped
[jt_table_entries] :: JumpTable -> [Int]

-- | Resolving the operand of a jump/call can produce one of the following.
data ResolvedJumpTarget

-- | An indirect branch that has not been resolved yet
Unresolved :: ResolvedJumpTarget

-- | A call to external function f
External :: String -> ResolvedJumpTarget

-- | An internal call to the given address
ImmediateAddress :: Word64 -> ResolvedJumpTarget

-- | An indirection
data Indirection

-- | An indirection that could be resolved to one or more addresses
IndirectionResolved :: Set ResolvedJumpTarget -> Indirection

-- | An indirection based on a jump table
IndirectionJumpTable :: JumpTable -> Indirection

-- | Per instruction address, a a jump table
type Indirections = IntMap Indirection

-- | An enumeration indicating the result of verification over a function
data VerificationResult

-- | Function was succesfully verified
VerificationSuccess :: VerificationResult

-- | Function was succesfully verified, but required assertions
VerificationSuccesWithAssumptions :: VerificationResult

-- | Function contains an unresolved indirection
VerificationUnresolvedIndirection :: VerificationResult

-- | There was some verification error, e.g., return adresss overwrite
VerificationError :: String -> VerificationResult

-- | The function has not been verified.
Unverified :: VerificationResult

-- | Invariants: a mapping of blockIDs to predicates
type Invariants = IntMap Pred

-- | For each leaf-node in a CFG we store the following info.
data NodeInfo

-- | The basic block behaves normally, e.g., a ret
Normal :: NodeInfo

-- | The basic block ends in an unresolved indirection
UnresolvedIndirection :: NodeInfo

-- | The basic blocks ends with, e.g., a call to exit()
Terminal :: NodeInfo

-- | Postconditions: for each final block the <tt>NodeInfo</tt> and the
--   final predicate after execution of the block
type Postconditions = Set (NodeInfo, Pred)

-- | Identifies where a memwrite occurred TODO should be generalized, is a
--   StatePartWriteIdentifier
data MemWriteIdentifier

-- | A function with <tt>name</tt> at address <tt>i_a</tt> wrote to a
--   statepart
MemWriteFunction :: String -> Word64 -> StatePart -> MemWriteIdentifier

-- | An instruction wrote to an operand, resolving to an address
MemWriteInstruction :: Word64 -> Operand -> SimpleExpr -> MemWriteIdentifier

-- | A verification condition is either: * A precondition of the form: &gt;
--   Precondition (a0,si0) (a1,si1) This formulates that at the initial
--   state the two regions must be separate. * An assertion of the form:
--   &gt; Assertion a (a0,si0) (a1,si1) This formulates that dynamically,
--   whenever address a is executed, the two regions are asserted to be
--   separate. * A function constraint of the form: &gt; FunctionConstraint
--   foo [(RDI, v0), (RSI, v1), ...] { sp0,sp1,... } This formulates that a
--   function call to function foo with values v0, v1, ... stored in the
--   registers should not overwrite certain state parts.
data VerificationCondition

-- | Precondition: lhs SEP rhs
Precondition :: SimpleExpr -> Int -> SimpleExpr -> Int -> VerificationCondition

-- | Assertion: @address, lhs SEP rhs
Assertion :: SimpleExpr -> SimpleExpr -> Int -> SimpleExpr -> Int -> VerificationCondition

-- | Function name, address, of call, with param registers
FunctionConstraint :: String -> Word64 -> [(Register, SimpleExpr)] -> Set StatePart -> VerificationCondition

-- | A write to a statepart for which no information was available
SourcelessMemWrite :: MemWriteIdentifier -> VerificationCondition

-- | A set of function pointers passed to a function
FunctionPointers :: Word64 -> IntSet -> VerificationCondition

-- | An acornym for a set of verification conditions
type VCS = Set VerificationCondition

-- | An abstract domain for pointers
data PointerDomain
Domain_Bases :: Set PointerBase -> PointerDomain
Domain_Sources :: Set BotSrc -> PointerDomain

-- | A function initialisation consists of a mapping of stateparts to
--   expressions.
type FInit = Map StatePart SimpleExpr

-- | A function call
data FReturnBehavior

-- | The function does never return
Terminating :: FReturnBehavior

-- | The function returns withg the symbolic changes stored in the
--   predicate
ReturningWith :: Pred -> FReturnBehavior

-- | It is unknown whether the function returns or not
UnknownRetBehavior :: FReturnBehavior

-- | The context datastructure.
--   
--   <b>S</b>: Information <b>S</b>tatically obtained by reading from the
--   binary
--   
--   <b>D</b>: Information <b>D</b>ynamically updated during verification
data Context_
Context_ :: !Config -> !IntMap String -> !SectionsInfo -> !String -> !String -> !Int -> ![Relocation] -> !Graph -> !IntMap CFG -> !IntMap FReturnBehavior -> !IntMap Invariants -> !IntMap Postconditions -> !Indirections -> !IntMap FInit -> !IntMap VCS -> !IntMap VerificationResult -> !IntMap IntSet -> Context_

-- | <b>S</b>: the configuration file in ./config ctxt<b>data ::
--   !(IM.IntMap Word8), -- ^ </b>S__: mapping from addresses to bytes
--   (writable data section)
[ctxt__config] :: Context_ -> !Config

-- | <b>S</b>: the symbol table: a mapping of addresses to function names
--   for external functions
[ctxt__syms] :: Context_ -> !IntMap String

-- | <b>S</b>: information on segments/section
[ctxt__sections] :: Context_ -> !SectionsInfo

-- | <b>S</b>: the name of the directory where the .dump, .entry, .sections
--   and .symbols files reside
[ctxt__dirname] :: Context_ -> !String

-- | <b>S</b>: the name of the binary
[ctxt__name] :: Context_ -> !String

-- | <b>S</b>: the address of the _start symbol
[ctxt__start] :: Context_ -> !Int

-- | <b>S</b>: relocation entries
[ctxt__relocs] :: Context_ -> ![Relocation]

-- | <b>D</b>: a graph with an edge (e0,e1) if entry address e0 calls entry
--   address e1, and e0 and e1 have not been verified yet
[ctxt__entries] :: Context_ -> !Graph

-- | <b>D</b>: the currently known control flow graphs per function entry
[ctxt__cfgs] :: Context_ -> !IntMap CFG

-- | <b>D</b>: the currently known and verified entry addresses of
--   functions mapped to return-information
[ctxt__calls] :: Context_ -> !IntMap FReturnBehavior

-- | <b>D</b>: the currently known invariants
[ctxt__invs] :: Context_ -> !IntMap Invariants

-- | <b>D</b>: the currently known postconditions
[ctxt__posts] :: Context_ -> !IntMap Postconditions

-- | <b>D</b>: the currently known indirections
[ctxt__inds] :: Context_ -> !Indirections

-- | <b>D</b>: the currently known function initialisations
[ctxt__finits] :: Context_ -> !IntMap FInit

-- | <b>D</b>: the verification conditions
[ctxt__vcs] :: Context_ -> !IntMap VCS

-- | <b>D</b>: the verification result
[ctxt__results] :: Context_ -> !IntMap VerificationResult

-- | <b>D</b>: a mapping from function entries to the set of mutually
--   recursive functions entries they occur in
[ctxt__recursions] :: Context_ -> !IntMap IntSet
data Context
Context :: !Binary -> IORef (IntMap Instruction) -> !Context_ -> Context
[ctxt_binary] :: Context -> !Binary
[ctxt_ioref] :: Context -> IORef (IntMap Instruction)
[ctxt_ctxt_] :: Context -> !Context_
ctxt_config :: Context -> Config
ctxt_syms :: Context -> IntMap String
ctxt_sections :: Context -> SectionsInfo
ctxt_dirname :: Context -> String
ctxt_name :: Context -> String
ctxt_start :: Context -> Int
ctxt_relocs :: Context -> [Relocation]
ctxt_entries :: Context -> Graph
ctxt_cfgs :: Context -> IntMap CFG
ctxt_calls :: Context -> IntMap FReturnBehavior
ctxt_invs :: Context -> IntMap Invariants
ctxt_posts :: Context -> IntMap Postconditions
ctxt_inds :: Context -> Indirections
ctxt_finits :: Context -> IntMap FInit
ctxt_vcs :: Context -> IntMap VCS
ctxt_results :: Context -> IntMap VerificationResult
ctxt_recursions :: Context -> IntMap IntSet
set_ctxt_syms :: IntMap String -> Context -> Context
set_ctxt_sections :: SectionsInfo -> Context -> Context
set_ctxt_start :: Int -> Context -> Context
set_ctxt_entries :: Graph -> Context -> Context
set_ctxt_calls :: IntMap FReturnBehavior -> Context -> Context
set_ctxt_inds :: Indirections -> Context -> Context
set_ctxt_posts :: IntMap Postconditions -> Context -> Context
set_ctxt_vcs :: IntMap VCS -> Context -> Context
set_ctxt_finits :: IntMap FInit -> Context -> Context
set_ctxt_invs :: IntMap Invariants -> Context -> Context
set_ctxt_cfgs :: IntMap CFG -> Context -> Context
set_ctxt_relocs :: [Relocation] -> Context -> Context
set_ctxt_results :: IntMap VerificationResult -> Context -> Context
set_ctxt_recursions :: IntMap IntSet -> Context -> Context

-- | intialize an empty context based on the command-line parameters
init_context :: Binary -> IORef (IntMap Instruction) -> Config -> String -> String -> Context

-- | purge the context before exporting it (may save a lot of disk space)
purge_context :: Context -> Context_

-- | Reading from a read-only data section.
--   
--   Reads maximally up to 8 bytes. Returns <tt>Nothing</tt> if the given
--   address is out-of-range.
read_from_ro_datasection :: Context -> Word64 -> Int -> Maybe Word64

-- | Is the immediate roughly in range to be an address?
is_roughly_an_address :: Context -> Word64 -> Bool

-- | Find a section for an address (see <tt><a>SectionsInfo</a></tt>)
find_section_for_address :: Context -> Word64 -> Maybe (String, String, Word64, Word64)

-- | Fetching an instruction
--   
--   Returns <tt>Nothing</tt> if the given address is out-of-range.
fetch_instruction :: Context -> Word64 -> IO (Maybe Instruction)

-- | Pretty printing an instruction
pp_instruction :: Context -> Instruction -> String

-- | Show function initialisaExpr
show_finit :: FInit -> String

-- | Is the given verification condition an assertion?
is_assertion :: VerificationCondition -> Bool

-- | Is the given verification condition a precondition?
is_precondition :: VerificationCondition -> Bool

-- | Is the given verification condition a function constraint?
is_func_constraint :: VerificationCondition -> Bool

-- | Is the given verification condition a sourceless memwrite?
is_sourceless_memwrite :: VerificationCondition -> Bool

-- | Is the given verification condition a function pointer introduction?
is_functionpointers :: VerificationCondition -> Bool

-- | Count the number of assertions in the set of verification conditions.
count_instructions_with_assertions :: Set VerificationCondition -> Int

-- | Count the number of sourceless memory writes in the set of
--   verification conditions.
count_sourceless_memwrites :: Set VerificationCondition -> Int
ctxt_continue_on_unknown_instruction :: Context -> Bool
ctxt_generate_pdfs :: Context -> Bool
ctxt_verbose_logs :: Context -> Bool
ctxt_store_preconditions_in_report :: Context -> Bool
ctxt_store_assertions_in_report :: Context -> Bool
ctxt_max_time :: Context -> Int
ctxt_max_num_of_cases :: Context -> Int
ctxt_max_num_of_bases :: Context -> Int
ctxt_max_num_of_sources :: Context -> Int
ctxt_max_jump_table_size :: Context -> Int
ctxt_max_expr_size :: Context -> Int
instance GHC.Classes.Eq Analysis.Context.CFG
instance GHC.Generics.Generic Analysis.Context.CFG
instance GHC.Show.Show Analysis.Context.CFG
instance GHC.Classes.Eq Analysis.Context.JumpTable
instance GHC.Generics.Generic Analysis.Context.JumpTable
instance GHC.Show.Show Analysis.Context.JumpTable
instance GHC.Classes.Ord Analysis.Context.ResolvedJumpTarget
instance GHC.Generics.Generic Analysis.Context.ResolvedJumpTarget
instance GHC.Show.Show Analysis.Context.ResolvedJumpTarget
instance GHC.Classes.Eq Analysis.Context.ResolvedJumpTarget
instance GHC.Classes.Eq Analysis.Context.Indirection
instance GHC.Generics.Generic Analysis.Context.Indirection
instance GHC.Show.Show Analysis.Context.Indirection
instance GHC.Generics.Generic Analysis.Context.VerificationResult
instance GHC.Classes.Eq Analysis.Context.VerificationResult
instance GHC.Classes.Ord Analysis.Context.NodeInfo
instance GHC.Classes.Eq Analysis.Context.NodeInfo
instance GHC.Generics.Generic Analysis.Context.NodeInfo
instance GHC.Show.Show Analysis.Context.NodeInfo
instance GHC.Classes.Ord Analysis.Context.MemWriteIdentifier
instance GHC.Classes.Eq Analysis.Context.MemWriteIdentifier
instance GHC.Generics.Generic Analysis.Context.MemWriteIdentifier
instance GHC.Classes.Ord Analysis.Context.VerificationCondition
instance GHC.Classes.Eq Analysis.Context.VerificationCondition
instance GHC.Generics.Generic Analysis.Context.VerificationCondition
instance GHC.Classes.Ord Analysis.Context.PointerDomain
instance GHC.Classes.Eq Analysis.Context.PointerDomain
instance GHC.Generics.Generic Analysis.Context.PointerDomain
instance GHC.Classes.Ord Analysis.Context.FReturnBehavior
instance GHC.Classes.Eq Analysis.Context.FReturnBehavior
instance GHC.Generics.Generic Analysis.Context.FReturnBehavior
instance GHC.Show.Show Analysis.Context.FReturnBehavior
instance GHC.Generics.Generic Analysis.Context.Context_
instance Data.Serialize.Serialize Analysis.Context.Context_
instance Data.Serialize.Serialize Analysis.Context.FReturnBehavior
instance Data.Serialize.Serialize Analysis.Context.PointerDomain
instance GHC.Show.Show Analysis.Context.PointerDomain
instance Data.Serialize.Serialize Analysis.Context.VerificationCondition
instance GHC.Show.Show Analysis.Context.VerificationCondition
instance Data.Serialize.Serialize Analysis.Context.MemWriteIdentifier
instance GHC.Show.Show Analysis.Context.MemWriteIdentifier
instance Data.Serialize.Serialize Analysis.Context.NodeInfo
instance Data.Serialize.Serialize Analysis.Context.VerificationResult
instance GHC.Show.Show Analysis.Context.VerificationResult
instance Data.Serialize.Serialize Analysis.Context.Indirection
instance Data.Serialize.Serialize Analysis.Context.ResolvedJumpTarget
instance Data.Serialize.Serialize Analysis.Context.JumpTable
instance Data.Serialize.Serialize Analysis.Context.CFG
instance Data.Serialize.Serialize Data.Binary.SectionsInfo
instance Data.Serialize.Serialize Data.Binary.Relocation


-- | Provides a taxonomy for output generated by FoxDec. The output is a
--   JSON object, whose schema is defined by the <a>JSON</a> datatype
--   below. That datatype provides its fields, such as <a>instructions</a>
--   and <a>control_flow</a>. This is an overview of some of the
--   information retrievable from FoxDec. For example, we have omitted
--   control flow graphs and per-instruction invariants to keep the size of
--   the JSON object manageable. However, if more information is required,
--   or if there is a request for information in a different form, then let
--   us know.
--   
--   On the right hand side, unfold the <b>synopsis</b> for an overview.
module Data.JSON_Taxonomy

-- | The top-level JSON datastructure consists of the following fields:
--   
--   <ul>
--   <li><a>instructions</a>: All instructions with their addresses and
--   sizes.</li>
--   <li><a>control_flow</a>: For each instruction address, this provides
--   the set of successor instruction addresses. This includes
--   indirections, if they were resolved.</li>
--   <li><a>function_boundaries</a>: For each function entry address, this
--   provides an overview of all instruction addresses belonging to that
--   function.</li>
--   <li><a>function_summaries</a>: For each function entry address, this
--   provides a pre- and postcondition.</li>
--   <li><a>invariants</a>: For each each instruction address, for each
--   function address that contains the instruction, this provides an
--   invariant.</li>
--   <li><a>pointer_domains</a>: For each each instruction address, for
--   each function address that contains the instruction, this provides a
--   symbolic expression for the pointer of each memory operand.</li>
--   </ul>
--   
--   Example of the entire JSON output:
--   
--   <pre>
--   { "instructions": [...], "control_flow": [...], ... }
--   </pre>
data JSON
JSON :: [Instruction] -> ControlFlow -> [(Word64, FunctionBoundary)] -> [(Word64, FunctionSummary)] -> [(Word64, [Invariant])] -> [(Word64, Word64, [Maybe SimpleExpr])] -> JSON

-- | A list of <a>Instruction</a>s.
[instructions] :: JSON -> [Instruction]

-- | The <b><a>ControlFlow</a></b> essentially is graph with as nodes
--   instruction addresses.
[control_flow] :: JSON -> ControlFlow

-- | A mapping from function entry addresses to pretty-printed
--   <b><a>FunctionBoundary</a></b>s.
[function_boundaries] :: JSON -> [(Word64, FunctionBoundary)]

-- | A mapping from function entry addresses to
--   <b><a>FunctionSummary</a></b>s.
[function_summaries] :: JSON -> [(Word64, FunctionSummary)]

-- | A mapping from instruction addresses to <b><a>Invariant</a></b>s.
[invariants] :: JSON -> [(Word64, [Invariant])]

-- | Per instruction address, per function entry, the
--   <b><a>PointerDomain</a></b> for each memory operand.
[pointer_domains] :: JSON -> [(Word64, Word64, [Maybe SimpleExpr])]

-- | The <b>ControlFlow</b> is provided as a mapping from instruction
--   addresses to lists of instruction addresses.
--   
--   Example of JSON output:
--   
--   <pre>
--   [5907,[5909,5929]]
--   </pre>
--   
--   This states the instruction at address 5907 has two possible successor
--   instruction addresses (5909 and 5929).
type ControlFlow = [(Word64, [Word64])]

-- | The <b>FunctionBoundary</b> is provided as a pretty-printed
--   representation of all instruction addresses covered by the function.
--   
--   Example of JSON output:
--   
--   <pre>
--   "1200--&gt;1238 ; 1280--&gt;1284"
--   </pre>
--   
--   This <b>Function Boundary</b> states that the function spans two
--   non-consecutive ranges of instruction addresses.
type FunctionBoundary = String

-- | A <b>FunctionSummary</b> contains:
--   
--   <ul>
--   <li>a preconditon: a <b><a>Predicate</a></b> that holds whenever the
--   function is called within the binary.</li>
--   <li>a postconditon: a <b><a>Postcondition</a></b> that holds whenever
--   the function is returning, if the function returns normally.</li>
--   </ul>
--   
--   Example of JSON output:
--   
--   <pre>
--   {"precondition" : [...], "postcondition" : [...]}
--   </pre>
data FunctionSummary
FunctionSummary :: Predicate -> Postcondition -> FunctionSummary
[precondition] :: FunctionSummary -> Predicate
[postcondition] :: FunctionSummary -> Postcondition

-- | An <b>Invariant</b> contains:
--   
--   <ul>
--   <li>the entry address of the function in which the instruction occurs.
--   Note that (rarely) the same instruction can occur in multiple
--   functions. Therefore, we provide an invariant per entry.</li>
--   <li>an invariant: a <a>Predicate</a>.</li>
--   </ul>
--   
--   Example of JSON output:
--   
--   <pre>
--   [4320,[[{"SP_Reg":"RIP"},{"SE_Immediate":4324}],[{"SP_Reg":"RAX"},...]]]
--   </pre>
--   
--   The instruction occurs in the function with entry address
--   <tt>4320</tt>. Register <tt>RIP</tt> is set to <tt>4324</tt>. Register
--   <tt>RAX</tt> is always equal to iths initial value.
type Invariant = (Word64, Predicate)

-- | A <b>Postcondition</b> provides information on the return status of a
--   function.
--   
--   Example of JSON output:
--   
--   <pre>
--   {"Terminating" : [] }
--   </pre>
data Postcondition

-- | The function does never return
Terminating :: Postcondition

-- | The function returns in a state satisfying the <b><a>Predicate</a></b>
ReturningWith :: Predicate -> Postcondition

-- | It is unknown whether the function returns or not
UnknownRetBehavior :: Postcondition

-- | A <b>Predicate</b> is a mapping from state parts (registers, memory,
--   flags) to symbolic expressions.
--   
--   Example of JSON output:
--   
--   <pre>
--   [
--     [{"SP_Reg":"RDI"},{"Bottom":{"FromPointerBases":[{"Malloc":[4420,""]}]}}],
--     [{"SP_Reg":"RSI"},{"SE_Immediate":8217}]
--   ]
--   </pre>
--   
--   This predicate states that register <tt>RDI</tt> is a pointer with as
--   base the return value of <tt>malloc</tt>, called at address
--   <tt>4420</tt>. Register <tt>RSI</tt> contains an immediate value.
type Predicate = Map StatePart SimpleExpr

-- | An <b>Instruction</b> has an address, a prefix (which may also be
--   <tt>null</tt>), a mnemonic/opcode, a list of operands (possibly empty)
--   and a size in bytes.
--   
--   Example of JSON output:
--   
--   <pre>
--   {"size":7,"prefix":"BND","addr":4420,"opcode":"JMP","operands":[{"Memory":[{"AddressImm":11869},8]}]}
--   </pre>
data Instruction
Instruction :: Word64 -> Maybe Prefix -> Opcode -> [Operand] -> Int -> Instruction

-- | address
[addr] :: Instruction -> Word64

-- | prefix, e.g., lock or repz
[prefix] :: Instruction -> Maybe Prefix

-- | opcode/mnemonic
[opcode] :: Instruction -> Opcode

-- | possibly empty list of operands
[operands] :: Instruction -> [Operand]

-- | size of instruction
[size] :: Instruction -> Int

-- | An <b>Operand</b> is either a memory operand, an effective address (in
--   case of <tt>LEA</tt>), a register or an immediate value.
--   
--   Example of JSON output:
--   
--   <pre>
--   {"Memory":[{"AddressPlus":[{"AddressRegister":"RIP"},{"AddressImm":11869}]},8]}
--   </pre>
data Operand

-- | A region in memory, with an <a>Address</a> and a size in bytes
Memory :: Address -> Int -> Operand

-- | An address itself, but not the value stored at the address.
EffectiveAddress :: Address -> Operand

-- | A storage location such as a register or a variable
Register :: Register -> Operand

-- | An immediate value
Immediate :: Word64 -> Operand

-- | An <b>Address</b> is the unresolved address computation in the memory
--   operand of an instruction.
--   
--   Example of JSON output:
--   
--   <pre>
--   {"AddressPlus":[{"AddressRegister":"RIP"},{"AddressImm":11869}]}
--   </pre>
data Address

-- | Reading a pointer from a storage
AddressRegister :: Register -> Address

-- | Immediate value
AddressImm :: Word64 -> Address

-- | Plus
AddressPlus :: Address -> Address -> Address

-- | Minus
AddressMinus :: Address -> Address -> Address

-- | Times
AddressTimes :: Address -> Address -> Address
instance GHC.Generics.Generic Data.JSON_Taxonomy.Postcondition
instance GHC.Generics.Generic Data.JSON_Taxonomy.FunctionSummary
instance GHC.Generics.Generic Data.JSON_Taxonomy.Address
instance GHC.Generics.Generic Data.JSON_Taxonomy.Operand
instance GHC.Generics.Generic Data.JSON_Taxonomy.Instruction
instance GHC.Generics.Generic Data.JSON_Taxonomy.JSON


module Data.JSON

-- | <b>Address</b>
data Address

-- | Reading a pointer from a storage
AddressRegister :: Register -> Address

-- | Immediate value
AddressImm :: Word64 -> Address

-- | Plus
AddressPlus :: Address -> Address -> Address

-- | Minus
AddressMinus :: Address -> Address -> Address

-- | Times
AddressTimes :: Address -> Address -> Address

-- | <b>Operand</b>
data Operand

-- | A region in memory, whose address is stored in the given state part
--   and whose size in bytes is given in the Int
Memory :: Address -> Int -> Operand

-- | An address itself, but not the value stored at the address.
EffectiveAddress :: Address -> Operand

-- | A storage location such as a register or a variable
Reg :: Register -> Operand

-- | An immediate value
Immediate :: Word64 -> Operand

-- | <b>Instruction</b>
data Instruction
Instruction :: Word64 -> Maybe Prefix -> Opcode -> Maybe Operand -> [Operand] -> Int -> Instruction

-- | address
[addr] :: Instruction -> Word64

-- | prefix, e.g., lock or repz
[prefix] :: Instruction -> Maybe Prefix

-- | opcode/mnemonic
[opcode] :: Instruction -> Opcode

-- | <ul>
--   <li>- ^ optional: destination operand</li>
--   </ul>
[dest] :: Instruction -> Maybe Operand

-- | optional: operand
[srcs] :: Instruction -> [Operand]

-- | size of instruction
[size] :: Instruction -> Int
instance GHC.Generics.Generic Data.JSON.Address
instance GHC.Generics.Generic Data.JSON.Operand


-- | Contains function relating to control flow, including functions for
--   resolving the targets of jumps and calls.
module Data.ControlFlow

-- | Resolving the operand of a jump/call can produce one of the following.
data ResolvedJumpTarget

-- | An indirect branch that has not been resolved yet
Unresolved :: ResolvedJumpTarget

-- | A call to external function f
External :: String -> ResolvedJumpTarget

-- | An internal call to the given address
ImmediateAddress :: Word64 -> ResolvedJumpTarget

-- | The set of next blocks from the given block in a CFG
post :: CFG -> Key -> IntSet

-- | Fetching an instruction list given a block ID
fetch_block :: CFG -> Int -> [Instruction]

-- | Returns true iff an instruction can be fetched from the address.
address_has_instruction :: Integral a => Context -> a -> Bool

-- | Returns true iff a symbol is associated with the address.
address_has_symbol :: Integral a => Context -> a -> Bool

-- | Returns true if the adress is external, i.e., has no instruction or
--   has a symbol.
address_is_external :: Integral a => Context -> a -> Bool

-- | many operands can statically be resolved, even though technically they
--   are indirect (relative to RIP). Examples:
--   
--   <tt>10005464e: call RIP + 1751660</tt> resolves to an immediate jump
--   target by resolving the RIP-relative addressing.
--   
--   <tt>10005464e: call qword ptr [RIP + 1751660]</tt> read from address
--   1002000c0, but address has a symbol associated to it. This function
--   call will resolve to an external function.
operand_static_resolve :: Context -> Instruction -> Operand -> ResolvedJumpTarget

-- | Resolves the first operand of a call or jump instruction. First tries
--   to see if the instruction is an indirection, that has already been
--   resolved. If not, try to statically resolve the first operand using
--   <tt><a>operand_static_resolve</a></tt>. If that resolves to an
--   immediate value, see if that immediate value corresponds to an
--   external function or an internal function.
--   
--   Returns a list of <tt><a>ResolvedJumpTarget</a></tt>, since an
--   indirection may be resolved to multiple targets.
resolve_jump_target :: Context -> Instruction -> [ResolvedJumpTarget]

-- | Given a resolved jump target, get a possibly empty list of internal
--   addresses to which the jump target can jump.
get_internal_addresses :: ResolvedJumpTarget -> [Int]

-- | Returns true iff the instruction resolves to external targets only.
instruction_jumps_to_external :: Context -> Instruction -> Bool

-- | Shows the block associated to the givern blockID.
show_block :: CFG -> Int -> String

-- | Shows invariants.
show_invariants :: CFG -> Invariants -> String

-- | Tries to retrieve a function name with an entry address. If the entry
--   matches a known symbol, return that. Otherwise, simply return the
--   entry address itself in hexadecimal notation. However, there is one
--   exception: if the first instruction at the entry address immediately
--   jumps to an external function, return the name of that external
--   function instead. This happens in a <tt>.got</tt> section.
function_name_of_entry :: Context -> Int -> String

-- | Tries to retrieve a function name for a <tt>call</tt>-instruction (see
--   <tt><a>function_name_of_entry</a></tt>).
--   
--   Returns the empty string if the given instruction is not a call or a
--   jump.
function_name_of_instruction :: Context -> Instruction -> String
isTerminal :: CFG -> Key -> Bool
instance Algorithm.SCC.IntGraph Analysis.Context.CFG

module X86.Program
type Program = GenericProgram Instruction

module Pass.Reg2Var
reg2var :: Program -> Program


module Data.Pointers

-- | The context augmented with information on the current function
data FContext
FContext :: Context -> Int -> String -> FInit -> FContext

-- | The context
[f_ctxt] :: FContext -> Context

-- | The entry address of the current function
[f_entry] :: FContext -> Int

-- | The name of the current function
[f_name] :: FContext -> String

-- | The initialization of the current function
[f_init] :: FContext -> FInit
mk_fcontext :: Context -> Int -> FContext
get_pointer_domain :: FContext -> SimpleExpr -> PointerDomain

-- | Returns true if the expression has known pointerbases.
expr_highly_likely_pointer :: FContext -> SimpleExpr -> Bool

-- | Returns true if the expression has a global pointerbase.
expr_is_global_pointer :: FContext -> SimpleExpr -> Bool

-- | Returns true if the expression has a local pointerbase, and no others.
expr_is_highly_likely_local_pointer :: FContext -> SimpleExpr -> Bool

-- | Returns true iff the expression is an immediate address falling into
--   the range of sections of the binary
expr_is_global_immediate :: Context -> SimpleExpr -> Bool

-- | Returns the set of sources (inputs used to compute the expression) of
--   an expression.
srcs_of_expr :: FContext -> SimpleExpr -> Set BotSrc

-- | Returns the set of sources (state parts used to compute the
--   expression) of two expressions.
srcs_of_exprs :: FContext -> [SimpleExpr] -> Set BotSrc
is_known_source :: BotSrc -> Bool
join_exprs :: [Char] -> FContext -> [SimpleExpr] -> SimpleExpr

-- | Abstraction for a single expression, even if the expression is
--   concrete.
join_single :: FContext -> SimpleExpr -> SimpleExpr

-- | Returns true iff the two given expressions can be shown to be
--   separate.
separate_pointer_domains :: (Integral a1, Integral a2) => FContext -> Bool -> SimpleExpr -> a1 -> SimpleExpr -> a2 -> Bool
pointer_bases_separate_necessarily :: FContext -> PointerBase -> PointerBase -> Bool
pointer_bases_separate_possibly :: FContext -> PointerBase -> PointerBase -> Bool
sources_separate_necessarily :: FContext -> BotSrc -> BotSrc -> Bool
sources_separate_possibly :: FContext -> BotSrc -> BotSrc -> Bool

-- | Returns true iff the given symbolic regions are necessarily equal. For
--   example: <tt>[RSP-16,4]</tt> is enclosed in <tt>[RSP-16,4]</tt>
--   
--   Will return <tt>False</tt> if the expressions contain bottom.
necessarily_equal :: SimpleExpr -> SimpleExpr -> Bool

-- | Returns true iff the given symbolic stateparts are necessarily equal.
necessarily_equal_stateparts :: StatePart -> StatePart -> Bool

-- | Returns true iff the given symbolic regions are ncessarily separate.
--   For example: <tt>[RSP-16,4]</tt> is separate from <tt>[RSP-12,8]</tt>
--   <tt>[RSP+8,4]</tt> is separate from <tt>[RSP,8]</tt>
--   
--   If none of the cases apply where it can be shjown arithmetically that
--   the expressions are separate, we check whether the expressions can be
--   proven separate based on their domains (see
--   <a>separate_pointer_domains</a>).
necessarily_separate :: Integral a => FContext -> SimpleExpr -> a -> SimpleExpr -> a -> Bool

-- | Returns true iff the given symbolic stateparts are necessarily
--   separate.
necessarily_separate_stateparts :: FContext -> StatePart -> StatePart -> Bool

-- | Returns true iff the given symbolic region is necessarily enclosed in
--   the other. For example: <tt>[RSP-16,4]</tt> is enclosed in
--   <tt>[RSP-18,8]</tt> <tt>[RSP+4,4]</tt> is enclosed in <tt>[RSP,8]</tt>
--   
--   Will return <tt>False</tt> if the expressions contain bottom.
necessarily_enclosed :: Integral a => SimpleExpr -> a -> SimpleExpr -> a -> Bool

-- | Unfold an expression with non-determinisism to a list of expressions.
--   Keep an eye on the produced size, as this may cause blow-up.
unfold_non_determinism :: FContext -> SimpleExpr -> [SimpleExpr]

-- | If the size of an expression becomes too large, we simply turn it into
--   Bottom.
trim_expr :: FContext -> SimpleExpr -> SimpleExpr


-- | These functions are defined using the <tt>State (Pred,VCS)</tt> monad.
--   Both the read- and write function may update the current predicate, as
--   well as introduce new verification conditions.
module Data.MachineState

-- | Read from a register
read_reg :: FContext -> Register -> State (Pred, VCS) SimpleExpr

-- | Write to a register
write_reg :: FContext -> Word64 -> Register -> SimpleExpr -> State (Pred, VCS) ()

-- | Read from memory
read_mem :: FContext -> Operand -> State (Pred, VCS) SimpleExpr

-- | Write to memory Each memory write is accomponied with a
--   <a>MemWriteIdentifier</a> so that we can log memory writes to unknown
--   locations.
write_mem :: FContext -> MemWriteIdentifier -> SimpleExpr -> Int -> SimpleExpr -> State (Pred, VCS) ()

-- | Read from an operand of an instruction
read_operand :: FContext -> Operand -> State (Pred, VCS) SimpleExpr

-- | Write to an operand of an instruction
write_operand :: FContext -> Word64 -> Operand -> SimpleExpr -> State (Pred, VCS) ()

-- | Read from an statepart
read_sp :: FContext -> StatePart -> State (Pred, VCS) SimpleExpr

-- | Write to a statepart
write_sp :: FContext -> Word64 -> (Word64 -> StatePart -> MemWriteIdentifier) -> (StatePart, SimpleExpr) -> State (Pred, VCS) ()

-- | Returns true if a pointer is not suitable for writing to memory. This
--   may happen if the symbolic expression provides no information, i.e.,
--   it has <tt>Bottom</tt> without known pointerbases, and without any
--   sources.
invalid_bottom_pointer :: FContext -> SimpleExpr -> Bool

-- | An address is considered "unwritable" only if it is an immediate
--   address that belongs to a section that is considered unwritable
--   according to Conventions (see <a>section_is_unwritable</a>)
address_is_unwritable :: Context -> SimpleExpr -> Bool

-- | Given the address of an operand of an instruction, resolve it given
--   the current state.
resolve_address :: FContext -> Address -> State (Pred, VCS) SimpleExpr
instance GHC.Classes.Eq Data.MachineState.SeparationStatus


-- | We assume a class where we can do predicate transformation through
--   function <tt>tau</tt>, and we can merge two predicates through
--   function <tt>join</tt>. Moreover, we assume an implementation of a
--   function <tt>implies</tt> that implements symbolic implication. Given
--   these functions, we provide a generic abstract interpretation
--   algorithm.
module Analysis.Propagation

-- | A class that allows propagation of predicates over a CFG.
class (Show pred) => Propagator ctxt pred

-- | Predicate transformation for an edge in in a CFG, over a basic blocks.
tau :: Propagator ctxt pred => ctxt -> [Instruction] -> Maybe [Instruction] -> pred -> (pred, Set VerificationCondition)

-- | A lattice-join
join :: Propagator ctxt pred => ctxt -> pred -> pred -> pred

-- | Symbolic implication
implies :: Propagator ctxt pred => ctxt -> pred -> pred -> Bool

-- | Start propagation at the given entry address with the given initial
--   predicate. Returns a set of invariants, i.e., a mapping of instruction
--   addresses to predicates.
do_prop :: Propagator ctxt pred => ctxt -> CFG -> Int -> pred -> (IntMap pred, Set VerificationCondition)

-- | The supremum of a list of predicates
supremum :: Propagator ctxt pred => ctxt -> [pred] -> pred


module Analysis.SymbolicExecution

-- | Do predicate transformation over a basic block in a CFG. Given an edge
--   in the CFG from none block to another, perform predicate
--   transformation. Parameter insts' is needed to set the flags properly.
--   If <tt>Nothing</tt> is supplied, the flags are overapproximatively set
--   to <tt><a>None</a></tt>.
tau_block :: FContext -> [Instruction] -> Maybe [Instruction] -> Pred -> (Pred, VCS)

-- | The initial predicate.
init_pred :: FContext -> Invariants -> Set (NodeInfo, Pred) -> Pred

-- | Given the currently known invariants and postconditions, gather all
--   stateparts occurring in the current function.
gather_stateparts :: Invariants -> Set (NodeInfo, Pred) -> Set StatePart

-- | Convert the current invariant into a function initialisation
invariant_to_finit :: FContext -> Pred -> FInit

-- | The join between two function initialisations
join_finit :: FContext -> FInit -> FInit -> FInit

-- | Get the invariant for a given instruction address for a given function
--   entry
get_invariant :: FContext -> Int -> Maybe Pred
instance Analysis.Propagation.Propagator Data.Pointers.FContext Data.SimplePred.Pred


module Pass.CFG_Gen

-- | Produce a CFG
--   
--   Given the entry point of the function, generate either a CFG, or a set
--   of new entry points to be analyzed first. The set of new entry points
--   are function entries called by the current function, but for which we
--   do not know yet whether they terminate or not. If a CFG is returned,
--   then all function calls in that CFG have already been analyzed.
cfg_gen :: Context -> Int -> IO (Set (Instruction, Int), CFG)

-- | Export a CFG to .dot file
--   
--   Strongly connected components get the same color.
cfg_to_dot :: Context -> CFG -> String

-- | Returns true if the given blockID is a leaf-node in the given CFG.
is_end_node :: CFG -> Int -> Bool

-- | Returns the <tt><a>NodeInfo</a></tt> of a given blockID.
--   
--   Assumes the given blockID corresponds to a leaf-node.
node_info_of :: Context -> CFG -> Int -> NodeInfo

-- | An abstract step function
--   
--   Given the entry address of the function currently under investigation,
--   and the instruction address of the current instruction, try to get the
--   set of next instruction addresses.
--   
--   This returns either: * a set of tuples <tt>(i,a)</tt> where <tt>i</tt>
--   is an instruction and <tt>a</tt> its address. All these instructions
--   are function calls that need to be analyzed before this current
--   function entry can continue. * a list of tuples <tt>(a,b)</tt> where
--   <tt>a</tt> is an instruction address that may follow the current
--   instruction, and <tt>b</tt> is a Bool indicating whether that address
--   belongs to a <tt>call</tt>
--   
--   TODO the Lefts are ignored so need no to return them
stepA :: Context -> Int -> Int -> IO (Either (Set (Instruction, Int)) [(Int, Bool)])


-- | The interface to the <tt>.report</tt> generated after running FoxDec.
--   After running FoxDec, a "verification report" (an object of type
--   <tt><a>Context</a></tt>) can be retrieved from the generated .report
--   file (see function <tt>ctxt_read_report</tt>). Essentially, this
--   module provides hooks into some of the information retrieved and
--   derived from the binary, including instructions, invariants, function
--   entry points, etc.
--   
--   A verification report is represented by the type
--   <tt><a>Context</a></tt>, as internally it is just the context passed
--   around and maintained during verification.
--   
--   The main flow is to read the .report file and use these functions to
--   retrieve information. The following example reads in a .report file
--   provided as first command-line parameter and outputs the function
--   entries:
--   
--   <pre>
--   main = do
--     args &lt;- getArgs
--     ctxt &lt;- ctxt_read_report (args !! 0) (args !! 1)
--     putStrLn $ show $ ctxt_get_function_entries ctxt
--   </pre>
--   
--   Some of the information is automatically also exported in plain-text
--   format, for easy access.
module VerificationReportInterface

-- | The return type when retrieving information from a verification
--   report: either an error message or a result.
type Retrieve a = Context -> Either String a

-- | Function Entries are simply integers
type FunctionEntry = Int

-- | Instruction Addresses are simply integers
type InstructionAddress = Int

-- | Read in the .report file from a file with the given file name. May
--   produce an error if no report can be read from the file. Returns the
--   verification report stored in the .report file.
ctxt_read_report :: String -> String -> IO Context

-- | Retrieve information from a <tt><a>Context</a></tt> read from a
--   .report file, or die with an error message. For example:
--   
--   <pre>
--   retrieve_io $ ctxt_get_instruction a ctxt
--   </pre>
--   
--   This code reads in a .report file with the given <tt>filename</tt>,
--   and reads the instruction at address <tt>a</tt> if any.
retrieve_io :: Either String a -> IO a

-- | Retrieve all function entries.
--   
--   Returns a set of funtion entries.
ctxt_get_function_entries :: Retrieve (Set FunctionEntry)

-- | Retrieve all instruction addresses.
--   
--   Returns a set of instruction addresses.
ctxt_get_instruction_addresses :: Retrieve (Set InstructionAddress)

-- | Retrieve all indirections
--   
--   Returns a mapping that provides for some instruction addresses a set
--   of jump targets.
ctxt_get_indirections :: Retrieve Indirections

-- | Retrieve instruction for a given instruction address, both as
--   datastructure and pretty-printed
ctxt_get_instruction :: InstructionAddress -> Retrieve (Instruction, String)

-- | Retrieve invariant for a given function entry and instruction address
--   
--   An invariant is a predicate provding information over registers,
--   memory, flags, and verification conditions.
ctxt_get_invariant :: FunctionEntry -> InstructionAddress -> Retrieve Pred

-- | Retrieve all internal function calls for a given function entry
--   
--   Returns a set of function entries.
ctxt_get_internal_function_calls :: FunctionEntry -> Retrieve (Set FunctionEntry)

-- | Retrieve a CFG for a given function entry
ctxt_get_cfg :: FunctionEntry -> Retrieve CFG

-- | Retrieve a function initialization for a given function entry
ctxt_get_function_init :: FunctionEntry -> Retrieve FInit

-- | Retrieve a function initialization for a given function entry
ctxt_get_postcondition :: FunctionEntry -> Retrieve FReturnBehavior
