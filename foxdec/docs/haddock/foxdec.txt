-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Formally Verified x86-64 Decompilation
--   
--   This package contains tools for decompilation based on formal methods.
@package foxdec
@version 0.1.0.0


module Base
class IntGraph g
intgraph_post :: IntGraph g => g -> Int -> IntSet
intgraph_V :: IntGraph g => g -> IntSet

-- | Show the integer in hex.
showHex :: Integral a => a -> String

-- | Show an integer list as hex-list.
showHex_list :: Integral a => [a] -> [Char]

-- | Show an integer set as hex-list.
showHex_set :: IntSet -> [Char]

-- | Show an optional integer as an optional hex.
showHex_option :: Integral a => Maybe a -> String

-- | Read an int from a string storing a hex.
readHex' :: (Eq a, Num a) => String -> a
show_set :: (Foldable t, Show a) => t a -> String

-- | Lookup and produce error message if key does not exists in map.
im_lookup :: [Char] -> IntMap a -> Key -> a

-- | use a default value in case of <tt>Nothing</tt>
orElse :: Eq a => Maybe a -> a -> a

-- | try something else if first result failed
orTry :: Eq a => Maybe a -> Maybe a -> Maybe a
orElseM :: Monad m => m (Maybe a) -> m a -> m a
orTryM :: Monad m => m (Maybe a) -> m (Maybe a) -> m (Maybe a)

-- | return only if Bool holds
onlyWhen :: Bool -> a -> Maybe a

-- | A value exists (is not Nothing) and satisfies the predicate
existsAndSatisfies :: Maybe t -> (t -> Bool) -> Bool

-- | Takes computations returnings <tt>Maybes</tt>; tries each one in
--   order. The first one to return a <tt>Just</tt> wins. Returns
--   <tt>Nothing</tt> if all computations return <tt>Nothing</tt>.
firstJustsM :: (Monad m, Foldable f) => f (m (Maybe a)) -> m (Maybe a)

-- | create a tuple
pair :: a -> b -> (a, b)

-- | Find the index of one string in another.
findString :: Eq a => [a] -> [a] -> Maybe Int

-- | Take until the occurrence of the string
takeUntilString :: String -> String -> String

-- | Strip outer parentheses from a string, if it has them.
strip_parentheses :: [Char] -> [Char]

-- | Uses a function to determine which of two output lists an input
--   element should join
partitionWith :: (a -> Either b c) -> [a] -> ([b], [c])

-- | In little endian, convert a byte-list to a 64 bit word. Assume the
--   list is at most length 8.
bytes_to_word :: [Word8] -> Word64

-- | Convert first <tt>n</tt> bytes of a word to an integer. Assume
--   <tt>n&lt;8</tt>.
word_to_sint :: Int -> Word64 -> Int

-- | average of list of numbers
average :: (Real a, Fractional b) => [a] -> b
crossProduct :: [[a]] -> [[a]]
crossProduct_size :: Foldable t => [t a] -> Int
neFromList :: Ord a => [a] -> NESet a
neSetToList :: NESet a -> [a]
quotientBy :: Ord a => (a -> a -> Bool) -> Set a -> Set (Set a)
quotientByL :: Ord a => (a -> a -> Bool) -> [a] -> [[a]]

-- | Sign-extension from 32 to 64 bits
sextend_32_64 :: (Bits a, Num a) => a -> a

-- | Sign-extension from 16 to 64 bits
sextend_16_64 :: (Bits a, Num a) => a -> a

-- | Sign-extension from 8 to 64 bits
sextend_8_64 :: (Bits a, Num a) => a -> a

-- | Sign-extension from 16 to 32 bits
sextend_16_32 :: (Bits a, Num a) => a -> a

-- | Sign-extension from 8 to 32 bits
sextend_8_32 :: (Bits a, Num a) => a -> a

-- | Sign-extension from 8 to 16 bits
sextend_8_16 :: (Bits a, Num a) => a -> a
round2dp :: Double -> Double

-- | Generic graph with ints as vertices.
data Graph
Edges :: IntMap IntSet -> Graph

-- | add edges from v to all vertices vs
graph_add_edges :: Graph -> Key -> IntSet -> Graph

-- | delete all edges with v as parent or child
graph_delete :: Graph -> Key -> Graph

-- | is v parent of an edge?
graph_is_parent :: Graph -> Key -> Bool

-- | is v a vertex in the graph?
graph_is_vertex :: Graph -> Key -> Bool

-- | is (v0,v1) an edge?
graph_is_edge :: Graph -> Key -> Key -> Bool

-- | Find an end (terminal node) reachable from the given node v0
try_find_end_node_from_node :: Graph -> Int -> Maybe Int
putNESetOf :: Putter a -> Putter (NESet a)

-- | Read as a list of elements.
getNESetOf :: Ord a => Get a -> Get (NESet a)

-- | decide whether text should be white or black based on background color
hex_color_of_text :: String -> String

-- | A list of RGB colors
hex_colors :: [String]
allp :: [a -> Bool] -> a -> Bool
instance GHC.Show.Show Base.Graph
instance GHC.Generics.Generic Base.Graph
instance Data.Serialize.Serialize Base.Graph
instance Control.DeepSeq.NFData Base.Graph
instance Base.IntGraph Base.Graph
instance (GHC.Classes.Ord a, Data.Serialize.Serialize a) => Data.Serialize.Serialize (Data.Set.NonEmpty.Internal.NESet a)


-- | Generating strongly connected components:
--   <a>https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm</a>
--   
--   The only modification is that this algorithm considers SCCs wrt to
--   some <i>frontier</i>. A frontier is a set of nodes that is not passed,
--   i.e., we consider a subgraph bounded by (up to not including) the
--   frontier.
--   
--   We assume the existence of a function post :: G -&gt; Int -&gt;
--   IS.IntSet that returns, given the graph and the current node, a set of
--   next nodes. We also assume the existence of a function V :: G -&gt;
--   IS.IntSet that returns all vertices.
--   
--   I could get none of the Data.Graph functions to work properly, hence
--   this reimplementation.
module Algorithm.SCC
data SCC_state
SCC_State :: IntMap Int -> IntMap Int -> Int -> [Int] -> [IntSet] -> SCC_state
[scc_indices] :: SCC_state -> IntMap Int
[scc_lowlinks] :: SCC_state -> IntMap Int
[scc_index] :: SCC_state -> Int
[scc_stack] :: SCC_state -> [Int]
[scc_return] :: SCC_state -> [IntSet]
set_index_of :: Key -> (SCC_state -> Int) -> SCC_state -> SCC_state
set_lowlink_of :: Key -> (SCC_state -> Int) -> SCC_state -> SCC_state
set_index :: (SCC_state -> Int) -> SCC_state -> SCC_state
push :: Int -> SCC_state -> SCC_state
pop_and_return :: Int -> SCC_state -> SCC_state
strongconnect :: IntGraph g => g -> Int -> IntSet -> State SCC_state ()
compute_all_sccs :: IntGraph g => g -> IntSet -> State SCC_state ()
init_scc_state :: SCC_state
scc_of :: IntGraph g => g -> Int -> IntSet -> [IntSet]
all_sccs :: IntGraph g => g -> IntSet -> [IntSet]

-- | retrieve a non-trivial SCC, if any exists
graph_nontrivial_scc :: Graph -> IntSet

-- | find next vertex to consider: either a terminal vertex (if any) or the
--   head of an SCC
graph_find_next :: Graph -> Maybe Int


-- | Computes the dominance frontier: see
--   <a>https://www.ed.tus.ac.jp/j-mune/keio/m/ssa2.pdf</a>.
module Algorithm.Dominance
domFrontier :: Graph -> Graph -> Int -> IntSet


module Config

-- | A datastructure storing all configurable options
data Config
Config :: Bool -> Bool -> Bool -> Bool -> Bool -> Natural -> Natural -> Natural -> Natural -> Natural -> Natural -> Bool -> Config

-- | When encountering an unknown instruction do we either * report it to
--   stderr but continue (True), or * exit with an error message (False)?
--   Sane default: True
[continue_on_unknown_instruction] :: Config -> Bool

-- | Do we call graphviz to generate PDFs? Set to true for small examples,
--   false for larger ones.
[generate_pdfs] :: Config -> Bool

-- | Must the invariants be stored in the logs? Sane default: False
[verbose_logs] :: Config -> Bool

-- | Must preconditions be stored in the .L0 file? Set to true for small
--   examples, false for larger ones. Sane default: False
[store_preconditions_in_L0] :: Config -> Bool

-- | Must assertions be stored in the .L0 file? Set to true for small
--   examples, false for larger ones. Sane default: False
[store_assertions_in_L0] :: Config -> Bool

-- | The maximum verification time in seconds per function Sane default: 30
--   minutes = 000000 * 60 * 30 = 1800000000
[max_time] :: Config -> Natural

-- | The maximum number of separate concrete cases considered
--   non-deterministically, before abstraction is applied. Has no effect on
--   soundness, but lower values cause more abstraction. Sane default: 5
[max_num_of_cases] :: Config -> Natural

-- | The maximum number of pointer bases a bottom-expression may have,
--   before more asbtraction is applied. Has no effect on soundness, but
--   lower values cause more abstraction. Sane default: 25
[max_num_of_bases] :: Config -> Natural
[max_num_of_sources] :: Config -> Natural

-- | The maximum number of sources a bottom-expression may have, before
--   resorting to rock-bottom. Has no effect on soundness, but lower values
--   cause more abstraction. Sane default: 100
[max_jump_table_size] :: Config -> Natural

-- | The maximum size of an expression (counting each operator and each
--   leaf as 1), before a symbolic expression is abstracted to rock bottom.
--   Does not affect soundness, but if the value is set too low, then the
--   results becomes overly overapproximative. Sane default: 3000
[max_expr_size] :: Config -> Natural

-- | If set to True, then the NASM code will have longer labels (less
--   readable) but always correct. If set to False, labels may occur twice
--   preventing compilation. Sane default: True
[nasm_with_safe_labels] :: Config -> Bool

-- | Given a filename, parse a config in the Dhall language See:
--   <a>https://dhall-lang.org</a>
parse_config :: String -> IO Config
instance GHC.Show.Show Config.Config
instance GHC.Generics.Generic Config.Config
instance Dhall.Marshal.Decode.FromDhall Config.Config
instance Data.Serialize.Serialize Config.Config
instance Control.DeepSeq.NFData Config.Config


module Data.JumpTarget

-- | Resolving the operand of a jump/call can produce one of the following.
data ResolvedJumpTarget

-- | An indirect branch that has not been resolved yet
Unresolved :: ResolvedJumpTarget

-- | A call to external function f
External :: String -> ResolvedJumpTarget

-- | A call to external function whose entry address is stored at the
--   label: *[l,8] = fptr
ExternalDeref :: String -> ResolvedJumpTarget

-- | An internal call to the given address
ImmediateAddress :: Word64 -> ResolvedJumpTarget

-- | The function returns (treat as a nop) or terminates
Returns :: Bool -> ResolvedJumpTarget
instance GHC.Classes.Ord Data.JumpTarget.ResolvedJumpTarget
instance GHC.Generics.Generic Data.JumpTarget.ResolvedJumpTarget
instance GHC.Classes.Eq Data.JumpTarget.ResolvedJumpTarget
instance GHC.Show.Show Data.JumpTarget.ResolvedJumpTarget
instance Data.Serialize.Serialize Data.JumpTarget.ResolvedJumpTarget
instance Control.DeepSeq.NFData Data.JumpTarget.ResolvedJumpTarget

module Data.Size
data BitSize
BitSize :: Int -> BitSize
data ByteSize
ByteSize :: Int -> ByteSize
byteSize :: ByteSize -> Int
instance GHC.Generics.Generic Data.Size.BitSize
instance GHC.Classes.Ord Data.Size.BitSize
instance GHC.Classes.Eq Data.Size.BitSize
instance GHC.Show.Show Data.Size.BitSize
instance GHC.Generics.Generic Data.Size.ByteSize
instance GHC.Classes.Ord Data.Size.ByteSize
instance GHC.Classes.Eq Data.Size.ByteSize
instance GHC.Show.Show Data.Size.ByteSize
instance Data.Serialize.Serialize Data.Size.ByteSize
instance Control.DeepSeq.NFData Data.Size.ByteSize
instance Data.Serialize.Serialize Data.Size.BitSize
instance Control.DeepSeq.NFData Data.Size.BitSize

module Data.Symbol

-- | An address a0 can have a symbol.
--   
--   PointerToFunction: E.g: 0xcfe0 --&gt; malloc Means that reading 8
--   bytes from address 0xcfe0 produces a pointer to malloc. Thus an
--   instruction: "CALL qword ptr [0xcfe0]" can be seen as "CALL malloc".
--   
--   PointerToObject: E.g.: 0xd0a8 --&gt; stdout Means that "mov rdi,QWORD
--   PTR [0xd0a8]" can be seen as "mov rdi, QWORD PTR [stdout]"
--   
--   Relocated_ResolvedObject E.g.: 0xc0fc0 "environ" -&gt; 0xc1340
--   Sometimes, a relocation has been resolved during linking. In that
--   case, it is no longer an external object. For example, there may be a
--   relocation that maps address 0xc0fc0 to symbol "environ". However,
--   that symbol is an object with an address (e.g., 0xc1340) that itself
--   has been relocated. Symbol "environ" now no longer is an external
--   symbol. Instead, we have *environ = &amp;object, where "object" is the
--   object that 0xc1340 is relocated to.
data Symbol

-- | Address a0 is a pointer to memory storing the entry of a function
PointerToLabel :: String -> Bool -> Symbol

-- | Address a0 can be replaced by the GOT entry of the string, e.g.,
--   "stdout wrt ..got" or "optind wrt ..got"
PointerToObject :: String -> Bool -> Symbol

-- | Address a0 can be replaced by the string, e.g., "stdout" or "optind"
AddressOfObject :: String -> Bool -> Symbol

-- | Address a0 can be replaced by the string.
AddressOfLabel :: String -> Bool -> Symbol

-- | At linking time internally resolved relocation
Relocated_ResolvedObject :: String -> Word64 -> Symbol
show_ex :: Bool -> String
instance GHC.Classes.Ord Data.Symbol.Symbol
instance GHC.Classes.Eq Data.Symbol.Symbol
instance GHC.Generics.Generic Data.Symbol.Symbol
instance GHC.Show.Show Data.Symbol.Symbol
instance Data.Serialize.Serialize Data.Symbol.Symbol

module Data.VerificationCondition
data PointerAnalysisResult v
PointerAnalysisResult :: Maybe v -> [Maybe v] -> PointerAnalysisResult v
[pa_mem_write] :: PointerAnalysisResult v -> Maybe v
[pa_mem_reads] :: PointerAnalysisResult v -> [Maybe v]
show_pars :: Show a => [Maybe a] -> [Char]
data VerificationCondition v

-- | A set of function pointers passed to a function
FunctionPointers :: Word64 -> IntSet -> VerificationCondition v

-- | A pointer analysis result for the instruction at the address
PointerAnalysis :: Word64 -> PointerAnalysisResult v -> VerificationCondition v
type VCS v = Set (VerificationCondition v)
gather_pa_results :: VCS v -> IntMap (PointerAnalysisResult v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (Data.VerificationCondition.PointerAnalysisResult v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Data.VerificationCondition.PointerAnalysisResult v)
instance GHC.Generics.Generic (Data.VerificationCondition.PointerAnalysisResult v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (Data.VerificationCondition.VerificationCondition v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Data.VerificationCondition.VerificationCondition v)
instance GHC.Generics.Generic (Data.VerificationCondition.VerificationCondition v)
instance GHC.Show.Show v => GHC.Show.Show (Data.VerificationCondition.VerificationCondition v)
instance Data.Serialize.Serialize v => Data.Serialize.Serialize (Data.VerificationCondition.VerificationCondition v)
instance Control.DeepSeq.NFData v => Control.DeepSeq.NFData (Data.VerificationCondition.VerificationCondition v)
instance GHC.Show.Show v => GHC.Show.Show (Data.VerificationCondition.PointerAnalysisResult v)
instance Data.Serialize.Serialize v => Data.Serialize.Serialize (Data.VerificationCondition.PointerAnalysisResult v)
instance Control.DeepSeq.NFData v => Control.DeepSeq.NFData (Data.VerificationCondition.PointerAnalysisResult v)

module Data.X86.Opcode

-- | Opcodes / mnemonics
data Opcode
InvalidOpcode :: Opcode
AAA :: Opcode
AAD :: Opcode
AAM :: Opcode
AAS :: Opcode
ADC :: Opcode
ADD :: Opcode
ADDPD :: Opcode
ADDPS :: Opcode
ADDSD :: Opcode
ADDSS :: Opcode
ADDSUBPD :: Opcode
ADDUBPS :: Opcode
AND :: Opcode
ANDNPD :: Opcode
ANDNPS :: Opcode
ANDPD :: Opcode
ANDPS :: Opcode
ARPL :: Opcode
BLENDVPD :: Opcode
BLENDVPS :: Opcode
BOUND :: Opcode
BSF :: Opcode
BSR :: Opcode
BT :: Opcode
BTC :: Opcode
BTR :: Opcode
BTS :: Opcode
CALL :: Opcode
CALLF :: Opcode
CBW :: Opcode
CDQ :: Opcode
CDQE :: Opcode
CLC :: Opcode
CLD :: Opcode
CLFLUSH :: Opcode
CLI :: Opcode
CLTS :: Opcode
CMC :: Opcode
CMOVA :: Opcode
CMOVAE :: Opcode
CMOVB :: Opcode
CMOVBE :: Opcode
CMOVC :: Opcode
CMOVE :: Opcode
CMOVG :: Opcode
CMOVGE :: Opcode
CMOVL :: Opcode
CMOVLE :: Opcode
CMOVNA :: Opcode
CMOVNAE :: Opcode
CMOVNB :: Opcode
CMOVNBE :: Opcode
CMOVNC :: Opcode
CMOVNE :: Opcode
CMOVNG :: Opcode
CMOVNGE :: Opcode
CMOVNL :: Opcode
CMOVNLE :: Opcode
CMOVNO :: Opcode
CMOVNP :: Opcode
CMOVNS :: Opcode
CMOVNZ :: Opcode
CMOVO :: Opcode
CMOVP :: Opcode
CMOVPE :: Opcode
CMOVPO :: Opcode
CMOVS :: Opcode
CMOVZ :: Opcode
CMP :: Opcode
CMPEQSD :: Opcode
CMPNEQSD :: Opcode
CMPNLESD :: Opcode
CMPNLESS :: Opcode
CMPLTSD :: Opcode
CMPLTSS :: Opcode
CMPS :: Opcode
CMPSB :: Opcode
CMPSD :: Opcode
CMPSS :: Opcode
CMPSW :: Opcode
CMPXCHG :: Opcode
CMPXCHG16B :: Opcode
CMPXCHG8B :: Opcode
COMISD :: Opcode
COMISS :: Opcode
CPUID :: Opcode
CQO :: Opcode
CVTDQ2PD :: Opcode
CVTSD2SS :: Opcode
CVTSI2SD :: Opcode
CVTSI2SS :: Opcode
CVTSS2SD :: Opcode
CVTTSD2SI :: Opcode
CVTTSS2SI :: Opcode
CVTTPD2DQ :: Opcode
CWD :: Opcode
CWDE :: Opcode
DAA :: Opcode
DAS :: Opcode
DEC :: Opcode
DIV :: Opcode
DIV_LO :: Opcode
DIV_HI :: Opcode
DIVPD :: Opcode
DIVPS :: Opcode
DIVSD :: Opcode
DIVSS :: Opcode
EMMS :: Opcode
ENDBR64 :: Opcode
ENTER :: Opcode
EXTRACTPS :: Opcode
FABS :: Opcode
FADD :: Opcode
FADDP :: Opcode
FBLD :: Opcode
FBSTP :: Opcode
FCHS :: Opcode
FCLEX :: Opcode
FCMOVB :: Opcode
FCMOVBE :: Opcode
FCMOVE :: Opcode
FCMOVNB :: Opcode
FCMOVNBE :: Opcode
FCMOVNE :: Opcode
FCMOVNU :: Opcode
FCMOVU :: Opcode
FCOM :: Opcode
FCOMI :: Opcode
FCOMIP :: Opcode
FCOMP :: Opcode
FCOMPI :: Opcode
FCOMPP :: Opcode
FCOS :: Opcode
FDIV :: Opcode
FDIVP :: Opcode
FDIVR :: Opcode
FDIVRP :: Opcode
FFREE :: Opcode
FRNDINT :: Opcode
FIADD :: Opcode
FICOM :: Opcode
FICOMP :: Opcode
FIDIV :: Opcode
FIDIVR :: Opcode
FILD :: Opcode
FIMUL :: Opcode
FINIT :: Opcode
FIST :: Opcode
FISTP :: Opcode
FISTPP :: Opcode
FISTTP :: Opcode
FISUB :: Opcode
FISUBR :: Opcode
FLD :: Opcode
FLD1 :: Opcode
FLDCW :: Opcode
FLDENV :: Opcode
FLDL2E :: Opcode
FLDL2T :: Opcode
FLDLG2 :: Opcode
FLDLN2 :: Opcode
FLDPI :: Opcode
FLDZ :: Opcode
FMUL :: Opcode
FMULP :: Opcode
FNOP :: Opcode
FNINIT :: Opcode
FNSTCW :: Opcode
FPREM1 :: Opcode
FRSTOR :: Opcode
FSAVE :: Opcode
FSIN :: Opcode
FSINCOS :: Opcode
FSCALE :: Opcode
FSQRT :: Opcode
FST :: Opcode
FSTCW :: Opcode
FSTENV :: Opcode
FSTP :: Opcode
FSTSW :: Opcode
FSUB :: Opcode
FSUBP :: Opcode
FSUBR :: Opcode
FSUBRP :: Opcode
FTST :: Opcode
FUCOM :: Opcode
FUCOMI :: Opcode
FUCOMIP :: Opcode
FUCOMP :: Opcode
FUCOMPI :: Opcode
FUCOMPP :: Opcode
FXAM :: Opcode
FXCH :: Opcode
FXRSTOR :: Opcode
FXSAVE :: Opcode
FXTRACT :: Opcode
HADDPD :: Opcode
HADDPS :: Opcode
HLT :: Opcode
HSUBPD :: Opcode
HSUBPS :: Opcode
IDIV :: Opcode
IDIV_LO :: Opcode
IDIV_HI :: Opcode
IMUL :: Opcode
IMUL_LO :: Opcode
IMUL_HI :: Opcode
BSWAP :: Opcode
IN :: Opcode
INC :: Opcode
INS :: Opcode
INSD :: Opcode
INT :: Opcode
INT3 :: Opcode
INTO :: Opcode
INVD :: Opcode
INVLPG :: Opcode
INVPCID :: Opcode
IRET :: Opcode
IRETD :: Opcode
IRETQ :: Opcode
JA :: Opcode
JAE :: Opcode
JB :: Opcode
JBE :: Opcode
JC :: Opcode
JCXZ :: Opcode
JE :: Opcode
JECXZ :: Opcode
JG :: Opcode
JGE :: Opcode
JL :: Opcode
JLE :: Opcode
JMP :: Opcode
JMPF :: Opcode
JMPN :: Opcode
JNAE :: Opcode
JNA :: Opcode
JNB :: Opcode
JNBE :: Opcode
JNC :: Opcode
JNG :: Opcode
JNE :: Opcode
JNGE :: Opcode
JNLE :: Opcode
JNL :: Opcode
JNO :: Opcode
JNP :: Opcode
JNS :: Opcode
JNZ :: Opcode
JO :: Opcode
JP :: Opcode
JPE :: Opcode
JPO :: Opcode
JRCXZ :: Opcode
JS :: Opcode
JZ :: Opcode
LAHF :: Opcode
LAR :: Opcode
LDDQU :: Opcode
LDMXCSR :: Opcode
LDS :: Opcode
LEA :: Opcode
LEAVE :: Opcode
LES :: Opcode
LFENCE :: Opcode
LFS :: Opcode
LGDT :: Opcode
LGS :: Opcode
LIDT :: Opcode
LLDT :: Opcode
LMSW :: Opcode
LODS :: Opcode
LODSB :: Opcode
LODSD :: Opcode
LODSW :: Opcode
LOOP :: Opcode
LOOPE :: Opcode
LOOPNE :: Opcode
LSL :: Opcode
LSS :: Opcode
LTR :: Opcode
MASKMOVQ :: Opcode
MAXPD :: Opcode
MAXPS :: Opcode
MAXSD :: Opcode
MAXSS :: Opcode
MFENCE :: Opcode
MINPD :: Opcode
MINPS :: Opcode
MINSD :: Opcode
MINSS :: Opcode
MONITOR :: Opcode
MOV :: Opcode
MOVABS :: Opcode
MOVAPD :: Opcode
MOVAPS :: Opcode
MOVD :: Opcode
MOVDDUP :: Opcode
MOVDQA :: Opcode
MOVDQU :: Opcode
MOVHLPS :: Opcode
MOVHPD :: Opcode
MOVHPS :: Opcode
MOVLHPS :: Opcode
MOVLPD :: Opcode
MOVLPS :: Opcode
MOVLSDUP :: Opcode
MOVMSKPD :: Opcode
MOVMSKPS :: Opcode
MOVNTDQ :: Opcode
MOVNTPD :: Opcode
MOVNTPS :: Opcode
MOVNTQ :: Opcode
MOVQ :: Opcode
MOVS :: Opcode
MOVSB :: Opcode
MOVSD :: Opcode
MOVSLDUP :: Opcode
MOVSS :: Opcode
MOVSW :: Opcode
MOVSQ :: Opcode
MOVSX :: Opcode
MOVSXB :: Opcode
MOVSXD :: Opcode
MOVSXW :: Opcode
MOVUPD :: Opcode
MOVUPS :: Opcode
MOVZX :: Opcode
MOVZXB :: Opcode
MOVZXW :: Opcode
MUL :: Opcode
MUL_LO :: Opcode
MUL_HI :: Opcode
MULPD :: Opcode
MULPS :: Opcode
MULSD :: Opcode
MULSS :: Opcode
MWAIT :: Opcode
NEG :: Opcode
NOP :: Opcode
NOT :: Opcode
OR :: Opcode
ORPD :: Opcode
ORPS :: Opcode
OUT :: Opcode
OUTS :: Opcode
PALIGNR :: Opcode
PACKSSDW :: Opcode
PACKSSWB :: Opcode
PADDB :: Opcode
PADDD :: Opcode
PADDQ :: Opcode
PADDSB :: Opcode
PADDSW :: Opcode
PADDUSB :: Opcode
PADDUSW :: Opcode
PADDW :: Opcode
PAND :: Opcode
PANDN :: Opcode
PAUSE :: Opcode
PAVGB :: Opcode
PAVGW :: Opcode
PBLENDW :: Opcode
PCLMULQDQ :: Opcode
PCMPEQB :: Opcode
PCMPEQD :: Opcode
PCMPGTB :: Opcode
PCMPGTD :: Opcode
PEXTRB :: Opcode
PEXTRD :: Opcode
PEXTRQ :: Opcode
PHADDD :: Opcode
PINSRB :: Opcode
PINSRD :: Opcode
PINSRQ :: Opcode
PMADDWD :: Opcode
PMAXSD :: Opcode
PMAXSW :: Opcode
PMAXUB :: Opcode
PMAXUD :: Opcode
PMAXUQ :: Opcode
PMINSD :: Opcode
PMINSW :: Opcode
PMINUB :: Opcode
PMINUD :: Opcode
PMOVMSKB :: Opcode
PMOVSXDQ :: Opcode
PMOVZXDQ :: Opcode
PMOVSXBD :: Opcode
PMOVZXBD :: Opcode
PMULLD :: Opcode
PMULLQ :: Opcode
PMULHUW :: Opcode
PMULHW :: Opcode
PMULLW :: Opcode
PMULUDQ :: Opcode
POP :: Opcode
POPA :: Opcode
POPAD :: Opcode
POPF :: Opcode
POPFD :: Opcode
POPFQ :: Opcode
POR :: Opcode
PREFETCHNTA :: Opcode
PREFETCHT0 :: Opcode
PREFETCHT1 :: Opcode
PREFETCHT2 :: Opcode
PSADBW :: Opcode
PSHUFB :: Opcode
PSHUFD :: Opcode
PSHUFLW :: Opcode
PSLLD :: Opcode
PSLLDQ :: Opcode
PSLLQ :: Opcode
PSLLW :: Opcode
PSRAD :: Opcode
PSRAW :: Opcode
PSRLD :: Opcode
PSRLDQ :: Opcode
PSRLQ :: Opcode
PSRLW :: Opcode
PSUBB :: Opcode
PSUBD :: Opcode
PSUBQ :: Opcode
PSUBSB :: Opcode
PSUBSQ :: Opcode
PSUBUSB :: Opcode
PSUBUSW :: Opcode
PSUBW :: Opcode
PTEST :: Opcode
PUNPCKLBW :: Opcode
PUNPCKLWD :: Opcode
PUNPCKLDQ :: Opcode
PUNPCKLQDQ :: Opcode
PUSH :: Opcode
PUSHA :: Opcode
PUSHAD :: Opcode
PUSHF :: Opcode
PUSHFD :: Opcode
PUSHFQ :: Opcode
PXOR :: Opcode
RCL :: Opcode
RCPPS :: Opcode
RCPSS :: Opcode
RCR :: Opcode
RDMSR :: Opcode
RDPMC :: Opcode
RDTSC :: Opcode
RET :: Opcode
RETF :: Opcode
RETN :: Opcode
ROL :: Opcode
ROR :: Opcode
ROUNDSD :: Opcode
ROUNDSS :: Opcode
RSM :: Opcode
RSQRTPS :: Opcode
RSQRTSS :: Opcode
SAHF :: Opcode
SAL :: Opcode
SAR :: Opcode
SBB :: Opcode
SCAS :: Opcode
SCASB :: Opcode
SCASD :: Opcode
SETA :: Opcode
SETAE :: Opcode
SETB :: Opcode
SETBE :: Opcode
SETC :: Opcode
SETE :: Opcode
SETG :: Opcode
SETGE :: Opcode
SETL :: Opcode
SETLE :: Opcode
SETNA :: Opcode
SETNAE :: Opcode
SETNB :: Opcode
SETNBE :: Opcode
SETNC :: Opcode
SETNE :: Opcode
SETNG :: Opcode
SETNGE :: Opcode
SETNL :: Opcode
SETNLE :: Opcode
SETNO :: Opcode
SETNP :: Opcode
SETNS :: Opcode
SETNZ :: Opcode
SETO :: Opcode
SETP :: Opcode
SETPE :: Opcode
SETPO :: Opcode
SETS :: Opcode
SETZ :: Opcode
SFENCE :: Opcode
SGDT :: Opcode
SHL :: Opcode
SHLD :: Opcode
SHR :: Opcode
SHRD :: Opcode
SHUFPS :: Opcode
SIDT :: Opcode
SLDT :: Opcode
SMSW :: Opcode
SQRTPD :: Opcode
SQRTPS :: Opcode
SQRTSD :: Opcode
SQRTSS :: Opcode
STC :: Opcode
STD :: Opcode
STI :: Opcode
STMXCSR :: Opcode
STOS :: Opcode
STOSB :: Opcode
STOSD :: Opcode
STOSW :: Opcode
STOSQ :: Opcode
STR :: Opcode
SUB :: Opcode
SUBPD :: Opcode
SUBPS :: Opcode
SUBSD :: Opcode
SUBSS :: Opcode
SWAPGS :: Opcode
SYSCALL :: Opcode
SYSENTER :: Opcode
SYSEXIT :: Opcode
SYSRET :: Opcode
TEST :: Opcode
UCOMISD :: Opcode
UCOMISS :: Opcode
UD2 :: Opcode
UNPCKHPD :: Opcode
UNPCKHPS :: Opcode
UNPCKLPD :: Opcode
UNPCKLPS :: Opcode
VANDPD :: Opcode
VANDPS :: Opcode
VADDPD :: Opcode
VADDPS :: Opcode
VBLENDPS :: Opcode
VERR :: Opcode
VERW :: Opcode
VEXTRACTI128 :: Opcode
VEXTRACTF128 :: Opcode
VINSERTF128 :: Opcode
VMCALL :: Opcode
VMCLEAR :: Opcode
VMLAUNCH :: Opcode
VMOVAPD :: Opcode
VMOVAPS :: Opcode
VMOVHPS :: Opcode
VMOVD :: Opcode
VMOVDQA :: Opcode
VMOVDQU :: Opcode
VMOVLHPS :: Opcode
VMPTRLD :: Opcode
VMPTRST :: Opcode
VMREAD :: Opcode
VMRESUME :: Opcode
VMWRITE :: Opcode
VMULPD :: Opcode
VMULPS :: Opcode
VMXOFF :: Opcode
VMXON :: Opcode
VPALIGNR :: Opcode
VPAND :: Opcode
VPANDN :: Opcode
VPCMPEQB :: Opcode
VPCMPEQW :: Opcode
VPERM2F128 :: Opcode
VPERM2I128 :: Opcode
VPERMILPS :: Opcode
VPOR :: Opcode
VPSHUFB :: Opcode
VPSHUFD :: Opcode
VPSLLW :: Opcode
VSHUFPS :: Opcode
VSHUFPD :: Opcode
VPXOR :: Opcode
VPUNPCKLWD :: Opcode
VPUNPCKHWD :: Opcode
VSUBPD :: Opcode
VSUBPS :: Opcode
VUNPCKHPS :: Opcode
VUNPCKLPS :: Opcode
VXORPD :: Opcode
VXORPS :: Opcode
VZEROUPPER :: Opcode
WAIT :: Opcode
WBINVD :: Opcode
WRFSBASE :: Opcode
WRGSBASE :: Opcode
WRMSR :: Opcode
XADD :: Opcode
XCHG :: Opcode
XGETBV :: Opcode
XLAT :: Opcode
XLATB :: Opcode
XSETBV :: Opcode
XSAVEOPT :: Opcode
XRSTOR :: Opcode
XOR :: Opcode
XORPD :: Opcode
XORPS :: Opcode

-- | Returns true iff m is the mnemonic of a conditional jump
isCondJump :: Opcode -> Bool

-- | Returns true iff m is the mnemonic of a halting instruction
isHalt :: Opcode -> Bool

-- | Returns true iff m is the mnemonic of a jump
isJump :: Opcode -> Bool

-- | Returns true iff m is the mnemonic of a call
isCall :: Opcode -> Bool

-- | Returns true iff m is the mnemonic of a return
isRet :: Opcode -> Bool
read_opcode :: String -> Opcode
instance GHC.Generics.Generic Data.X86.Opcode.Opcode
instance GHC.Classes.Ord Data.X86.Opcode.Opcode
instance GHC.Classes.Eq Data.X86.Opcode.Opcode
instance GHC.Show.Show Data.X86.Opcode.Opcode
instance Data.Serialize.Serialize Data.X86.Opcode.Opcode
instance Control.DeepSeq.NFData Data.X86.Opcode.Opcode

module Data.X86.Register
data Register
RegNone :: Register
Reg8 :: GPR -> RegHalf -> Register
Reg16 :: GPR -> Register
Reg32 :: GPR -> Register
Reg64 :: GPR -> Register
Reg128 :: SSEReg -> Register
RegSeg :: SReg -> Register
RegFPU :: FPUReg -> Register
RegTemp :: Register
data GPR
RAX :: GPR
RCX :: GPR
RDX :: GPR
RBX :: GPR
RSP :: GPR
RBP :: GPR
RSI :: GPR
RDI :: GPR
R8 :: GPR
R9 :: GPR
R10 :: GPR
R11 :: GPR
R12 :: GPR
R13 :: GPR
R14 :: GPR
R15 :: GPR
RIP :: GPR
data SReg
ES :: SReg
CS :: SReg
SS :: SReg
DS :: SReg
FS :: SReg
GS :: SReg
SR6 :: SReg
SR7 :: SReg
data FPUReg
ST0 :: FPUReg
ST1 :: FPUReg
ST2 :: FPUReg
ST3 :: FPUReg
ST4 :: FPUReg
ST5 :: FPUReg
ST6 :: FPUReg
ST7 :: FPUReg
data SSEReg
XMM0 :: SSEReg
XMM1 :: SSEReg
XMM2 :: SSEReg
XMM3 :: SSEReg
XMM4 :: SSEReg
XMM5 :: SSEReg
XMM6 :: SSEReg
XMM7 :: SSEReg
XMM8 :: SSEReg
XMM9 :: SSEReg
XMM10 :: SSEReg
XMM11 :: SSEReg
XMM12 :: SSEReg
XMM13 :: SSEReg
XMM14 :: SSEReg
XMM15 :: SSEReg
data RegHalf
HalfL :: RegHalf
HalfH :: RegHalf
real_reg :: Register -> Register
regSize :: Register -> ByteSize
instance GHC.Generics.Generic Data.X86.Register.GPR
instance GHC.Classes.Ord Data.X86.Register.GPR
instance GHC.Classes.Eq Data.X86.Register.GPR
instance GHC.Show.Show Data.X86.Register.GPR
instance GHC.Generics.Generic Data.X86.Register.SReg
instance GHC.Classes.Ord Data.X86.Register.SReg
instance GHC.Classes.Eq Data.X86.Register.SReg
instance GHC.Show.Show Data.X86.Register.SReg
instance GHC.Generics.Generic Data.X86.Register.FPUReg
instance GHC.Classes.Ord Data.X86.Register.FPUReg
instance GHC.Classes.Eq Data.X86.Register.FPUReg
instance GHC.Show.Show Data.X86.Register.FPUReg
instance GHC.Generics.Generic Data.X86.Register.SSEReg
instance GHC.Classes.Ord Data.X86.Register.SSEReg
instance GHC.Classes.Eq Data.X86.Register.SSEReg
instance GHC.Show.Show Data.X86.Register.SSEReg
instance GHC.Generics.Generic Data.X86.Register.RegHalf
instance GHC.Classes.Ord Data.X86.Register.RegHalf
instance GHC.Classes.Eq Data.X86.Register.RegHalf
instance GHC.Show.Show Data.X86.Register.RegHalf
instance GHC.Generics.Generic Data.X86.Register.Register
instance GHC.Classes.Ord Data.X86.Register.Register
instance GHC.Classes.Eq Data.X86.Register.Register
instance GHC.Show.Show Data.X86.Register.Register
instance Data.Serialize.Serialize Data.X86.Register.Register
instance Control.DeepSeq.NFData Data.X86.Register.Register
instance Data.Serialize.Serialize Data.X86.Register.RegHalf
instance Control.DeepSeq.NFData Data.X86.Register.RegHalf
instance Data.Serialize.Serialize Data.X86.Register.SSEReg
instance Control.DeepSeq.NFData Data.X86.Register.SSEReg
instance Data.Serialize.Serialize Data.X86.Register.FPUReg
instance Control.DeepSeq.NFData Data.X86.Register.FPUReg
instance Data.Serialize.Serialize Data.X86.Register.SReg
instance Control.DeepSeq.NFData Data.X86.Register.SReg
instance Data.Serialize.Serialize Data.X86.Register.GPR
instance Control.DeepSeq.NFData Data.X86.Register.GPR

module Data.X86.Instruction
data Instruction
Instruction :: Word64 -> [Prefix] -> Opcode -> Maybe Operand -> [Operand] -> Int -> Instruction
[inAddress] :: Instruction -> Word64
[inPrefix] :: Instruction -> [Prefix]
[inOperation] :: Instruction -> Opcode
[inDest] :: Instruction -> Maybe Operand
[inOperands] :: Instruction -> [Operand]
[inSize] :: Instruction -> Int
data Prefix
PrefixO16 :: Prefix
PrefixA32 :: Prefix
PrefixRepNE :: Prefix
PrefixRep :: Prefix
PrefixLock :: Prefix
PrefixSeg :: SReg -> Prefix
PrefixRex :: Word8 -> Prefix
data Operand
Op_Mem :: BitSize -> BitSize -> Register -> Register -> Word8 -> Int -> Maybe SReg -> Operand
[mSize] :: Operand -> BitSize
[mASize] :: Operand -> BitSize
[mReg] :: Operand -> Register
[mIdx] :: Operand -> Register
[mScale] :: Operand -> Word8
[mDisp] :: Operand -> Int
[mSeg] :: Operand -> Maybe SReg
Op_Reg :: Register -> Operand
Op_Imm :: Immediate -> Operand
Op_Jmp :: Immediate -> Operand
Op_Const :: Int -> Operand
Op_Near :: Operand -> Operand
Op_Far :: Operand -> Operand
data Immediate
Immediate :: BitSize -> Word64 -> Immediate
[iSize] :: Immediate -> BitSize
[iValue] :: Immediate -> Word64
operand_size :: Operand -> ByteSize
mk_RSP_mem_operand :: ByteSize -> Operand
srcs :: Instruction -> [Operand]

-- | Canonicalizes an instruction by making sure there is at most one
--   output and inputs/outputs are syntactically clear. | For example, the
--   IMUL instruction comes in different flavors that hide the actual
--   inputs and outputs to multiple registers
canonicalize :: Instruction -> [Instruction]
canonicalize_sextend1 :: Instruction -> [Instruction]
canonicalize_sextend2 :: Instruction -> [Instruction]
canonicalize_mul :: Instruction -> [Instruction]
canonicalize_div :: Instruction -> [Instruction]
mnemonic_reads_from_all_operands :: Opcode -> Bool
mnemonic_reads_from_all_but_first_operands :: Opcode -> Bool
remove_destination :: Opcode -> Bool
do_not_modify :: Opcode -> Bool
lowpart :: Opcode -> Opcode
hipart :: Opcode -> Opcode
instance GHC.Classes.Ord Data.X86.Instruction.Prefix
instance GHC.Generics.Generic Data.X86.Instruction.Prefix
instance GHC.Classes.Eq Data.X86.Instruction.Prefix
instance GHC.Show.Show Data.X86.Instruction.Prefix
instance GHC.Generics.Generic Data.X86.Instruction.Immediate
instance GHC.Classes.Ord Data.X86.Instruction.Immediate
instance GHC.Classes.Eq Data.X86.Instruction.Immediate
instance GHC.Generics.Generic Data.X86.Instruction.Operand
instance GHC.Classes.Ord Data.X86.Instruction.Operand
instance GHC.Classes.Eq Data.X86.Instruction.Operand
instance GHC.Classes.Ord Data.X86.Instruction.Instruction
instance GHC.Generics.Generic Data.X86.Instruction.Instruction
instance GHC.Classes.Eq Data.X86.Instruction.Instruction
instance GHC.Show.Show Data.X86.Instruction.Instruction
instance Data.Serialize.Serialize Data.X86.Instruction.Instruction
instance Control.DeepSeq.NFData Data.X86.Instruction.Instruction
instance GHC.Show.Show Data.X86.Instruction.Operand
instance Data.Serialize.Serialize Data.X86.Instruction.Operand
instance Control.DeepSeq.NFData Data.X86.Instruction.Operand
instance GHC.Show.Show Data.X86.Instruction.Immediate
instance Data.Serialize.Serialize Data.X86.Instruction.Immediate
instance Control.DeepSeq.NFData Data.X86.Instruction.Immediate
instance Data.Serialize.Serialize Data.X86.Instruction.Prefix
instance Control.DeepSeq.NFData Data.X86.Instruction.Prefix

module Data.Indirection

-- | A jump table with : index: an operand containing a bounded index at
--   the beginning of execution of the block bound: the bound on idx trgt:
--   the operand containg the jump target at the end of execution of the
--   block tbl: a table from values of idx to resulting jump targets
data JumpTable
JumpTable :: Operand -> Int -> Operand -> IntMap Word64 -> JumpTable
[jtbl_index] :: JumpTable -> Operand
[jtbl_bound] :: JumpTable -> Int
[jtbl_target] :: JumpTable -> Operand
[jtbl_table] :: JumpTable -> IntMap Word64

-- | An indirection is either a jump table or a set of resolved jump
--   targets
data Indirection
Indirection_JumpTable :: JumpTable -> Indirection
Indirection_Resolved :: ResolvedJumpTarget -> Indirection
Indirection_Unresolved :: Indirection
type Indirections = Set Indirection
instance GHC.Classes.Ord Data.Indirection.JumpTable
instance GHC.Classes.Eq Data.Indirection.JumpTable
instance GHC.Generics.Generic Data.Indirection.JumpTable
instance GHC.Classes.Ord Data.Indirection.Indirection
instance GHC.Classes.Eq Data.Indirection.Indirection
instance GHC.Generics.Generic Data.Indirection.Indirection
instance GHC.Show.Show Data.Indirection.Indirection
instance Data.Serialize.Serialize Data.Indirection.Indirection
instance Control.DeepSeq.NFData Data.Indirection.Indirection
instance GHC.Show.Show Data.Indirection.JumpTable
instance Data.Serialize.Serialize Data.Indirection.JumpTable
instance Control.DeepSeq.NFData Data.Indirection.JumpTable

module Data.CFG

-- | A control flow graph with blocks and edges. A blockID (represented as
--   an <tt>Int</tt>) is a unique identifier of a basic block. We store
--   basic blocks twice: once as addresses, and once as instructions.
data CFG
CFG :: IntMap [Int] -> IntMap IntSet -> IntMap Int -> Int -> IntMap [Instruction] -> CFG

-- | A mapping of blockIDs to instruction addresses
[cfg_blocks] :: CFG -> IntMap [Int]

-- | A mapping of blockIDs to sets of blocKIDs
[cfg_edges] :: CFG -> IntMap IntSet

-- | A mapping of instruction addresses to blockIDs
[cfg_addr_to_blockID] :: CFG -> IntMap Int

-- | A fresh blockID
[cfg_fresh] :: CFG -> Int

-- | A mapping of blockIDs to instructions
[cfg_instrs] :: CFG -> IntMap [Instruction]
num_of_instructions :: CFG -> Int
init_cfg :: Integral a => a -> CFG

-- | Returns true if the given blockID is a leaf-node in the given CFG.
is_end_node :: CFG -> Int -> Bool

-- | The set of next blocks from the given block in a CFG
post :: CFG -> Int -> IntSet

-- | Fetching an instruction list given a block ID
fetch_block :: CFG -> Int -> [Instruction]
instance GHC.Classes.Eq Data.CFG.CFG
instance GHC.Generics.Generic Data.CFG.CFG
instance GHC.Show.Show Data.CFG.CFG
instance Data.Serialize.Serialize Data.CFG.CFG
instance Control.DeepSeq.NFData Data.CFG.CFG


module Conventions

-- | A list of function names of functions that never return.
is_exiting_function_call :: [Char] -> Bool
strip_GLIBC :: String -> String

-- | Overview of sections with instructions.
sections_with_instructions :: [(String, String)]

-- | Sections in the following list are assumed not to be modifiable during
--   execution, i.e., constant.
section_is_unwritable :: (String, String) -> Bool

-- | A list if registers that are non-volatile, i.e., that must be
--   preserved by a function (callee-saved)
callee_saved_registers :: [Register]

-- | A list of registers that may be used for return values
return_registers :: [Register]

-- | A list of registers used as parameters
parameter_registers :: [Register]

module Disassembler.Disassembler
disassemble0 :: Word64 -> ByteString -> Maybe Instruction

module Binary.Generic

-- | Information on the sections in the binary
data SectionsInfo
SectionsInfo :: ![(String, String, Word64, Word64, Word64)] -> !Word64 -> !Word64 -> SectionsInfo

-- | Sections: segment names, section names, addresses, sizes, and
--   alignment.
[si_sections] :: SectionsInfo -> ![(String, String, Word64, Word64, Word64)]
[si_min_address] :: SectionsInfo -> !Word64
[si_max_address] :: SectionsInfo -> !Word64
data SymbolTable
SymbolTable :: !IntMap Symbol -> !Set String -> SymbolTable
[symboltable_symbols] :: SymbolTable -> !IntMap Symbol
[symboltable_exterbals] :: SymbolTable -> !Set String
data Relocation

-- | 8: At address a0, address a1 has been written, i.e., qword ptr[a0] ==
--   a1
Relocation :: Word64 -> Word64 -> Relocation
class BinaryClass a
binary_read_bytestring :: BinaryClass a => a -> Word64 -> Int -> Maybe ByteString
binary_read_ro_data :: BinaryClass a => a -> Word64 -> Int -> Maybe [Word8]
binary_read_data :: BinaryClass a => a -> Word64 -> Int -> Maybe [Word8]
binary_get_sections_info :: BinaryClass a => a -> SectionsInfo
binary_get_symbols :: BinaryClass a => a -> SymbolTable
binary_get_relocations :: BinaryClass a => a -> Set Relocation
binary_pp :: BinaryClass a => a -> String
binary_entry :: BinaryClass a => a -> Word64
binary_text_section_size :: BinaryClass a => a -> Int
binary_dir_name :: BinaryClass a => a -> String
binary_file_name :: BinaryClass a => a -> String
data Binary
Binary :: b -> Binary
binary_get_symbol_table :: BinaryClass a => a -> IntMap Symbol
binary_get_global_symbols :: BinaryClass a => a -> Set String
symbol_to_name :: Symbol -> String

-- | Is the immediate roughly in range to be an address?
is_roughly_an_address :: BinaryClass bin => bin -> Word64 -> Bool

-- | Find a section for an address (see <tt><a>SectionsInfo</a></tt>)
find_section_for_address :: BinaryClass bin => bin -> Word64 -> Maybe (String, String, Word64, Word64, Word64)

-- | Reading from a read-only data section.
--   
--   Reads maximally up to 8 bytes. Returns <tt>Nothing</tt> if the given
--   address is out-of-range.
read_from_ro_datasection :: BinaryClass bin => bin -> Word64 -> Int -> Maybe Word64

-- | Find a section ending at address (see <tt><a>SectionsInfo</a></tt>)
find_section_ending_at :: BinaryClass bin => bin -> Word64 -> Maybe (String, String, Word64, Word64, Word64)

-- | Fetching an instruction Returns <tt>Nothing</tt> if the given address
--   is out-of-range.
fetch_instruction :: BinaryClass bin => bin -> Word64 -> Maybe Instruction

-- | Returns true iff an instruction can be fetched from the address.
address_has_instruction :: BinaryClass bin => bin -> Word64 -> Bool
instance GHC.Classes.Eq Binary.Generic.SectionsInfo
instance GHC.Generics.Generic Binary.Generic.SectionsInfo
instance GHC.Show.Show Binary.Generic.SectionsInfo
instance GHC.Classes.Eq Binary.Generic.SymbolTable
instance GHC.Generics.Generic Binary.Generic.SymbolTable
instance GHC.Classes.Ord Binary.Generic.Relocation
instance GHC.Classes.Eq Binary.Generic.Relocation
instance GHC.Generics.Generic Binary.Generic.Relocation
instance Binary.Generic.BinaryClass Binary.Generic.Binary
instance GHC.Show.Show Binary.Generic.Relocation
instance Data.Serialize.Serialize Binary.Generic.Relocation
instance GHC.Show.Show Binary.Generic.SymbolTable
instance Data.Serialize.Serialize Binary.Generic.SymbolTable
instance Data.Serialize.Serialize Binary.Generic.SectionsInfo


-- | A datatype for symbolic predicates, tailored to storing information on
--   equalities between the current values stored in state parts (lhs) and
--   constant expressions (rhs).
module Data.SymbolicExpression

-- | A statepart is either a register or a region in memory
data StatePart

-- | A register
SP_Reg :: Register -> StatePart

-- | A region with a symbolic address and an immediate size.
SP_Mem :: SimpleExpr -> Int -> StatePart

-- | A symbolic expression with as leafs either immediates, variables, live
--   values of stateparts, or malloced addresses. A variable is a constant
--   representing some initial value, e.g., RDI_0, or [RSP_0,8]_0. A
--   statepart evaluates to its current value, e.g., RDI or [RSP,8].
data SimpleExpr

-- | An immediate word
SE_Immediate :: Word64 -> SimpleExpr

-- | A variable representing the initial value stored in the statepart
--   (e.g., RSP0)
SE_Var :: StatePart -> SimpleExpr

-- | The value stored currently in the statepart
SE_StatePart :: StatePart -> Maybe String -> SimpleExpr

-- | A malloc return value with possibly an ID
SE_Malloc :: Maybe Word64 -> Maybe String -> SimpleExpr

-- | Application of an <tt><a>Operator</a></tt> to the list of arguments
SE_Op :: Operator -> Int -> [SimpleExpr] -> SimpleExpr

-- | Taking the lower bits of a value
SE_Bit :: Int -> SimpleExpr -> SimpleExpr

-- | Sign extension
SE_SExtend :: Int -> Int -> SimpleExpr -> SimpleExpr

-- | Overwriting certain bits of a value with bits from another value
SE_Overwrite :: Int -> SimpleExpr -> SimpleExpr -> SimpleExpr

-- | Bottom (unknown value)
Bottom :: BotTyp -> SimpleExpr

-- | Symbolically represent the status of all flags in the current state
data FlagStatus

-- | No information known, flags could have any value
None :: FlagStatus

-- | The flags are set by the x86 CMP instruction applied to the given
--   operands.
FS_CMP :: Maybe Bool -> Operand -> Operand -> FlagStatus

-- | Bot represents an unknown (bottom) value. We annotate each occurence
--   of Bot with a BotTyp. This type indicates where the bottom value
--   originates from. The latter six are all equal, we just use them for
--   debugging and information. They indicate that the value is unknown,
--   but was computed using the set of sources.
data BotTyp

-- | The expression evaluates to one of the expressions in the set
FromNonDeterminism :: NESet SimpleExpr -> BotTyp

-- | The expression is a pointer-computation with known base(s)
FromPointerBases :: NESet PointerBase -> BotTyp

-- | Return value of a function call
FromCall :: String -> BotTyp

-- | The expression is some computation based on sources.
FromSources :: NESet BotSrc -> BotTyp

-- | A read from two possibly overlapping regions
FromOverlap :: NESet BotSrc -> BotTyp

-- | A write to two possibly overlapping regions
FromMemWrite :: NESet BotSrc -> BotTyp

-- | An instruction with unknown semantics
FromSemantics :: NESet BotSrc -> BotTyp

-- | Should not happen, but if a register writes to a registeralias with
--   unknown bit size
FromBitMode :: NESet BotSrc -> BotTyp

-- | Reading from memory not written to yet
FromUninitializedMemory :: NESet BotSrc -> BotTyp
RockBottom :: BotTyp

-- | Sources that may be used to compute an expression. That is, the inputs
--   to an expression.
data BotSrc

-- | An initial variable, i.e., a constant
Src_Var :: StatePart -> BotSrc

-- | The stack pointer of the given function
Src_StackPointer :: BotSrc

-- | A malloced address
Src_Malloc :: Maybe Word64 -> Maybe String -> BotSrc

-- | An immediate used in the computation of the pointer
Src_ImmediateAddress :: Word64 -> BotSrc

-- | A return value from a function
Src_Function :: String -> BotSrc

-- | reading from memory
Src_Mem :: NESet BotSrc -> BotSrc

-- | Some immediate value
Src_ImmediateConstants :: BotSrc

-- | An operator is a pure operation over bit-vectors, annotated with the
--   bit-size of its operands. For example, <tt>Plus 64</tt> denotes 64-bit
--   addition.
data Operator
Minus :: Operator
Plus :: Operator
Times :: Operator
And :: Operator
Or :: Operator
Xor :: Operator
Not :: Operator
Bsr :: Operator

-- | The high part after sign-extension from $n$ bits, thus producing
--   $n$-bit value
SExtHi :: Int -> Operator
IMulLo :: Operator
IMulHi :: Operator
UdivHi :: Operator
UdivLo :: Operator
Udiv :: Operator
SdivHi :: Operator
SdivLo :: Operator
Sdiv :: Operator
Shl :: Operator
Shr :: Operator
Sar :: Operator
Ror :: Operator
Rol :: Operator
Bswap :: Operator
Pextr :: Operator
Sbb :: Operator
Adc :: Operator
Cmov :: Operator
ZeroOne :: Operator

-- | A pointerbase is a positive addend of a symbolic expression that may
--   represent a pointer.
data PointerBase

-- | The stack frame of the given function
StackPointer :: PointerBase

-- | A malloc (at the <i>heap</i>) at a given address (hash is unused for
--   now)
Malloc :: Maybe Word64 -> Maybe String -> PointerBase

-- | A <i>global</i> address in the range of the sections of the binary.
GlobalAddress :: Word64 -> PointerBase

-- | A pointer to the thread-local-storage (e.g., FS register)
ThreadLocalStorage :: PointerBase

-- | A statepart that is known to contain a pointer
BaseIsStatePart :: StatePart -> PointerBase

-- | Returns true iff the expression is an immediate value
is_immediate :: SimpleExpr -> Bool

-- | Is the statepart memory?
is_mem_sp :: StatePart -> Bool

-- | Is the statepart a register?
is_reg_sp :: StatePart -> Bool

-- | Returns true iff the expression contains Bot
contains_bot :: SimpleExpr -> Bool

-- | Returns true iff the statepart contains Bot
contains_bot_sp :: StatePart -> Bool

-- | concatMap function p over all bottom values in the expression
all_bot_satisfy :: (BotTyp -> Bool) -> SimpleExpr -> Bool

-- | Simplification of symbolic expressions.
--   
--   Must always produce an expression logically equivalent to the
--   original.
simp :: SimpleExpr -> SimpleExpr

-- | Pretty print expression, showing Bottom expressions only as Bot
pp_expr :: SimpleExpr -> [Char]

expr_size :: SimpleExpr -> Int

-- | Sign-extension from 32 to 64 bits
sextend_32_64 :: (Bits a, Num a) => a -> a

-- | Sign-extension from 16 to 64 bits
sextend_16_64 :: (Bits a, Num a) => a -> a

-- | Sign-extension from 8 to 64 bits
sextend_8_64 :: (Bits a, Num a) => a -> a
addends :: SimpleExpr -> Map SimpleExpr Word64
instance GHC.Generics.Generic Data.SymbolicExpression.Operator
instance GHC.Classes.Ord Data.SymbolicExpression.Operator
instance GHC.Classes.Eq Data.SymbolicExpression.Operator
instance GHC.Classes.Ord Data.SymbolicExpression.PointerBase
instance GHC.Classes.Eq Data.SymbolicExpression.PointerBase
instance GHC.Generics.Generic Data.SymbolicExpression.PointerBase
instance GHC.Generics.Generic Data.SymbolicExpression.BotSrc
instance GHC.Classes.Ord Data.SymbolicExpression.BotSrc
instance GHC.Classes.Eq Data.SymbolicExpression.BotSrc
instance GHC.Generics.Generic Data.SymbolicExpression.BotTyp
instance GHC.Classes.Ord Data.SymbolicExpression.BotTyp
instance GHC.Classes.Eq Data.SymbolicExpression.BotTyp
instance GHC.Generics.Generic Data.SymbolicExpression.SimpleExpr
instance GHC.Classes.Ord Data.SymbolicExpression.SimpleExpr
instance GHC.Classes.Eq Data.SymbolicExpression.SimpleExpr
instance GHC.Generics.Generic Data.SymbolicExpression.StatePart
instance GHC.Classes.Ord Data.SymbolicExpression.StatePart
instance GHC.Classes.Eq Data.SymbolicExpression.StatePart
instance GHC.Classes.Ord Data.SymbolicExpression.FlagStatus
instance GHC.Classes.Eq Data.SymbolicExpression.FlagStatus
instance GHC.Generics.Generic Data.SymbolicExpression.FlagStatus
instance GHC.Show.Show Data.SymbolicExpression.FlagStatus
instance Data.Serialize.Serialize Data.SymbolicExpression.FlagStatus
instance Control.DeepSeq.NFData Data.SymbolicExpression.FlagStatus
instance GHC.Show.Show Data.SymbolicExpression.BotSrc
instance GHC.Show.Show Data.SymbolicExpression.BotTyp
instance GHC.Show.Show Data.SymbolicExpression.SimpleExpr
instance GHC.Show.Show Data.SymbolicExpression.StatePart
instance GHC.Show.Show Data.SymbolicExpression.PointerBase
instance Data.Serialize.Serialize Data.SymbolicExpression.PointerBase
instance Data.Serialize.Serialize Data.SymbolicExpression.BotTyp
instance Data.Serialize.Serialize Data.SymbolicExpression.BotSrc
instance Data.Serialize.Serialize Data.SymbolicExpression.StatePart
instance Data.Serialize.Serialize Data.SymbolicExpression.SimpleExpr
instance Control.DeepSeq.NFData Data.SymbolicExpression.PointerBase
instance Control.DeepSeq.NFData Data.SymbolicExpression.BotTyp
instance Control.DeepSeq.NFData Data.SymbolicExpression.BotSrc
instance Control.DeepSeq.NFData Data.SymbolicExpression.StatePart
instance Control.DeepSeq.NFData Data.SymbolicExpression.SimpleExpr
instance GHC.Show.Show Data.SymbolicExpression.Operator
instance Data.Serialize.Serialize Data.SymbolicExpression.Operator
instance Control.DeepSeq.NFData Data.SymbolicExpression.Operator
instance Control.DeepSeq.NFData Data.Symbol.Symbol


module Data.SValue
data SValue
SConcrete :: NESet SimpleExpr -> SValue
SAddends :: NESet SimpleExpr -> SValue
Top :: SValue
instance GHC.Classes.Ord Data.SValue.SValue
instance GHC.Classes.Eq Data.SValue.SValue
instance GHC.Generics.Generic Data.SValue.SValue
instance Data.Serialize.Serialize Data.SValue.SValue
instance Control.DeepSeq.NFData Data.SValue.SValue
instance GHC.Show.Show Data.SValue.SValue


module Data.SPointer
data SPointer
Ptr_Concrete :: SimpleExpr -> SPointer
Ptr_Base :: SimpleExpr -> SPointer
Ptr_Top :: SPointer
instance GHC.Generics.Generic Data.SPointer.SPointer
instance GHC.Classes.Ord Data.SPointer.SPointer
instance GHC.Classes.Eq Data.SPointer.SPointer
instance GHC.Show.Show Data.SPointer.SPointer
instance Data.Serialize.Serialize Data.SPointer.SPointer
instance Control.DeepSeq.NFData Data.SPointer.SPointer

module Data.L0
data Postcondition pred
ReturnsWith :: pred -> Postcondition pred
HasUnresolvedIndirections :: [Int] -> Postcondition pred
Terminates :: Postcondition pred
TimeOut :: Postcondition pred
VerificationError :: [(Int, pred)] -> Postcondition pred
data FResult pred v
FResult :: CFG -> Postcondition pred -> Set Word64 -> Set (VerificationCondition v) -> IntMap (PointerAnalysisResult v) -> FResult pred v
[result_cfg] :: FResult pred v -> CFG
[result_post] :: FResult pred v -> Postcondition pred
[result_calls] :: FResult pred v -> Set Word64
[result_vcs] :: FResult pred v -> Set (VerificationCondition v)
[result_pa] :: FResult pred v -> IntMap (PointerAnalysisResult v)
data L0 pred finit v
L0 :: IntMap (finit, Maybe (FResult pred v)) -> IntMap Indirections -> String -> L0 pred finit v
[l0_functions] :: L0 pred finit v -> IntMap (finit, Maybe (FResult pred v))
[l0_indirections] :: L0 pred finit v -> IntMap Indirections
[l0_time] :: L0 pred finit v -> String
l0_insert_new_entry :: Key -> finit -> L0 pred finit v -> L0 pred finit v
l0_adjust_result :: Integral a => a -> Maybe (FResult pred v) -> L0 pred finit v -> L0 pred finit v
l0_lookup_entry :: Integral a => a -> L0 pred finit v -> Maybe (finit, Maybe (FResult pred v))
l0_lookup_indirection :: Integral a => a -> L0 pred finit v -> Maybe Indirections
l0_insert_indirection :: Integral a => a -> Indirections -> L0 pred finit v -> L0 pred finit v
empty_result :: FResult pred v
l0_get_cfgs :: L0 pred finit v -> IntMap CFG
l0_get_function_entries :: L0 pred finit v -> Set Int
l0_get_pars :: L0 pred finit v -> IntMap (IntMap (PointerAnalysisResult v))
type Lifting bin pred finit v = (bin, Config, L0 pred finit v)
type LiftingEntry bin pred finit v = (bin, Config, L0 pred finit v, Word64)
show_indirections :: IntMap Indirections -> String
instance GHC.Classes.Eq pred => GHC.Classes.Eq (Data.L0.Postcondition pred)
instance GHC.Generics.Generic (Data.L0.Postcondition pred)
instance GHC.Generics.Generic (Data.L0.FResult pred v)
instance GHC.Generics.Generic (Data.L0.L0 pred finit v)
instance (Data.Serialize.Serialize pred, Data.Serialize.Serialize finit, Data.Serialize.Serialize v, GHC.Classes.Ord v) => Data.Serialize.Serialize (Data.L0.L0 pred finit v)
instance (Control.DeepSeq.NFData pred, Control.DeepSeq.NFData finit, Control.DeepSeq.NFData v) => Control.DeepSeq.NFData (Data.L0.L0 pred finit v)
instance (Data.Serialize.Serialize v, Data.Serialize.Serialize pred, GHC.Classes.Ord v) => Data.Serialize.Serialize (Data.L0.FResult pred v)
instance (Control.DeepSeq.NFData v, Control.DeepSeq.NFData pred) => Control.DeepSeq.NFData (Data.L0.FResult pred v)
instance GHC.Show.Show pred => GHC.Show.Show (Data.L0.Postcondition pred)
instance Data.Serialize.Serialize pred => Data.Serialize.Serialize (Data.L0.Postcondition pred)
instance Control.DeepSeq.NFData pred => Control.DeepSeq.NFData (Data.L0.Postcondition pred)


-- | Contains function relating to control flow, including functions for
--   resolving the targets of jumps and calls.
module Binary.FunctionNames

-- | Tries to retrieve a function name with an entry address. If the entry
--   matches a known symbol, return that. Otherwise, simply return the
--   entry address itself in hexadecimal notation. However, there is one
--   exception: if the first instruction at the entry address immediately
--   jumps to an external function, return the name of that external
--   function instead. This happens in a <tt>.got</tt> section.
try_plt_target_for_entry :: BinaryClass bin => bin -> Word64 -> Maybe ResolvedJumpTarget

-- | Given an instruction that calls or jumps, try to find a jump target
jump_target_for_instruction :: BinaryClass bin => bin -> Instruction -> ResolvedJumpTarget

-- | many operands can statically be resolved, even though technically they
--   are indirect (relative to RIP). Examples:
--   
--   <tt>10005464e: call RIP + 1751660</tt> resolves to an immediate jump
--   target by resolving the RIP-relative addressing.
--   
--   <tt>10005464e: call qword ptr [RIP + 1751660]</tt> read from address
--   1002000c0, but address has a symbol associated to it. This function
--   call will resolve to an external function.
operand_static_resolve :: BinaryClass bin => bin -> Instruction -> Operand -> ResolvedJumpTarget
try_read_function_pointer :: (Show p, BinaryClass p) => p -> p -> Word64 -> ResolvedJumpTarget
function_name_of_entry :: BinaryClass bin => bin -> Word64 -> String

-- | Tries to retrieve a function name for a <tt>call</tt>-instruction (see
--   <tt><a>function_name_of_entry</a></tt>).
--   
--   Returns the empty string if the given instruction is not a call or a
--   jump.
function_name_of_instruction :: BinaryClass bin => bin -> Instruction -> String

module Binary.Elf
data NamedElf
NamedElf :: !Elf -> !String -> !String -> !SectionsInfo -> !SymbolTable -> !Set Relocation -> NamedElf
[elf] :: NamedElf -> !Elf
[elf_dir_name] :: NamedElf -> !String
[elf_file_name] :: NamedElf -> !String
[elf_sections_info] :: NamedElf -> !SectionsInfo
[elf_symbol_table] :: NamedElf -> !SymbolTable
[elf_relocs] :: NamedElf -> !Set Relocation

-- | Overview of sections with read only data.
sections_ro_data :: [(String, String)]
sections_data :: [(String, String)]
sections_bss :: [(String, String)]
sections_text :: [(String, String)]
isRelevantElfSection :: ElfSection -> Bool
isAllocated :: ElfSection -> Bool
read_bytes_section :: Word64 -> Int -> ElfSection -> [Word8]
contains_address :: Word64 -> ElfSection -> Bool
elf_read_bytestring :: Elf -> Word64 -> Int -> Maybe ByteString
elf_read_ro_data :: Elf -> Word64 -> Int -> Maybe [Word8]
elf_read_data :: Elf -> Word64 -> Int -> Maybe [Word8]
elf_get_relocs :: Elf -> Set Relocation
elf_get_symbol_table :: Elf -> SymbolTable
get_string_from_steName :: (a, Maybe ByteString) -> String
elf_min_address :: Elf -> Word64
elf_max_address :: Elf -> Word64
elf_read_file :: ByteString -> Elf
pp_elf_section :: ElfSection -> [Char]
pp_elf :: Elf -> [Char]
elf_get_sections_info :: Elf -> SectionsInfo
elf_text_section_size :: Elf -> Int
instance GHC.Generics.Generic Data.Elf.ElfMachine
instance GHC.Generics.Generic Data.Elf.ElfSegmentType
instance GHC.Generics.Generic Data.Elf.ElfSegmentFlag
instance GHC.Generics.Generic Data.Elf.ElfSegment
instance GHC.Generics.Generic Data.Elf.ElfType
instance GHC.Generics.Generic Data.Elf.ElfOSABI
instance GHC.Generics.Generic Data.Elf.ElfClass
instance GHC.Generics.Generic Data.Elf.ElfData
instance GHC.Generics.Generic Data.Elf.ElfSectionFlags
instance GHC.Generics.Generic Data.Elf.ElfSectionType
instance GHC.Generics.Generic Data.Elf.ElfSection
instance GHC.Generics.Generic Data.Elf.Elf
instance GHC.Generics.Generic Binary.Elf.NamedElf
instance Data.Serialize.Serialize Binary.Elf.NamedElf
instance Binary.Generic.BinaryClass Binary.Elf.NamedElf
instance Data.Serialize.Serialize Data.Elf.ElfMachine
instance Data.Serialize.Serialize Data.Elf.ElfSegmentType
instance Data.Serialize.Serialize Data.Elf.ElfSegmentFlag
instance Data.Serialize.Serialize Data.Elf.ElfSegment
instance Data.Serialize.Serialize Data.Elf.ElfType
instance Data.Serialize.Serialize Data.Elf.ElfOSABI
instance Data.Serialize.Serialize Data.Elf.ElfClass
instance Data.Serialize.Serialize Data.Elf.ElfData
instance Data.Serialize.Serialize Data.Elf.ElfSectionFlags
instance Data.Serialize.Serialize Data.Elf.ElfSectionType
instance Data.Serialize.Serialize Data.Elf.ElfSection
instance Data.Serialize.Serialize Data.Elf.Elf


module OutputGeneration.NASM.NASM

-- | NASM contains external symbols, sections, and a footer
data NASM
NASM :: Set String -> Set String -> [NASM_Section] -> [String] -> NASM
[nasm_externals] :: NASM -> Set String
[nasm_globals] :: NASM -> Set String
[nasm_sections] :: NASM -> [NASM_Section]
[nasm_footer] :: NASM -> [String]

-- | A NASM label is either a string, or a macro. The latter is used when
--   referring to addresses within data sections. For example:
--   
--   Macro "" ".data" 0x4000 0x23
--   
--   refers to segment "", and the section ".data" that starts at immediate
--   address 0x4000. So the real adress was 0x4023.
data NASM_Label

-- | Normal label
Label :: Word64 -> String -> NASM_Label

-- | Macro into data section (segment, section, a0, offset)
Macro :: String -> String -> Word64 -> Word64 -> NASM_Label

-- | A NASM section is either a NASM text section or NASM data section
data NASM_Section
NASM_Section_Text :: NASM_TextSection -> NASM_Section
NASM_Section_Data :: [NASM_DataSection] -> NASM_Section

-- | An annotation consists of an address that is being symbolized to a
--   label and an offset. The offset will often be 0. For example: 0x1016
--   --&gt; L1000_2 0x4028 --&gt; L_.bss_0x4020 + 0x8 Annotations translate
--   to NASM comments, and have no effect on the actual NASM itself.
type Annot = [(Word64, NASM_Label, Word64)]

-- | A NASM text section contains a name and an **ordered** list of basic
--   blocks. Each basic block has an ID and a list of lines.
data NASM_TextSection
NASM_TextSection :: String -> [(Int, [NASM_Line])] -> IntMap IntSet -> NASM_TextSection
[nasm_function_name] :: NASM_TextSection -> String

-- | A mapping of blockIDs to instructions
[nasm_blocks] :: NASM_TextSection -> [(Int, [NASM_Line])]
[nasm_cfg] :: NASM_TextSection -> IntMap IntSet

-- | A NASM line is either a comment, an instruction or a label
data NASM_Line

-- | A comment with an indentation level (number of spaces)
NASM_Comment :: Int -> String -> NASM_Line

-- | An instruction with an annotation
NASM_Line :: NASM_Instruction -> NASM_Line

-- | A label
NASM_Label :: NASM_Label -> NASM_Line

-- | An instruction consists of a prefix, an opcode, a list of operands, a
--   comment (possibly empty) and an annotation (possibly empty).
data NASM_Instruction
NASM_Instruction :: Maybe Prefix -> Maybe Opcode -> [NASM_Operand] -> String -> Annot -> NASM_Instruction
[nasm_prefix] :: NASM_Instruction -> Maybe Prefix
[nasm_mnemonic] :: NASM_Instruction -> Maybe Opcode
[nasm_operands] :: NASM_Instruction -> [NASM_Operand]
[nasm_comment] :: NASM_Instruction -> String
[nasm_annot] :: NASM_Instruction -> Annot

-- | A size directive for a memory operand in bytes. For example (4,True)
--   is the size directive for a 4-byte memory operand. It can be
--   <a>False</a> to indicate that the operand should not be rendered (e.g,
--   in case of an LEA instruction).
type NASM_SizeDir = (Int, Bool)

-- | An address can either be a computation or some symbol.
data NASM_Address
NASM_Addr_Compute :: NASM_Address_Computation -> NASM_Address
NASM_Addr_Symbol :: Symbol -> NASM_Address
NASM_Addr_Label :: NASM_Label -> Maybe Word64 -> NASM_Address
NASM_JumpTarget :: ResolvedJumpTarget -> NASM_Address

-- | An address computation within an operand. The computation is: segment
--   + [base + index*scale + disp]
data NASM_Address_Computation
NASM_Address_Computation :: Maybe Register -> Maybe Register -> Word64 -> Maybe Register -> Maybe Word64 -> NASM_Address_Computation
[nasm_segment] :: NASM_Address_Computation -> Maybe Register
[nasm_index] :: NASM_Address_Computation -> Maybe Register
[nasm_scale] :: NASM_Address_Computation -> Word64
[nasm_base] :: NASM_Address_Computation -> Maybe Register
[nasm_displace] :: NASM_Address_Computation -> Maybe Word64

-- | A data section consists of a list of data section entries. Each
--   DataEntry stores its address and a value.
data NASM_DataEntry

-- | A single byte
DataEntry_Byte :: Word64 -> Word8 -> NASM_DataEntry

-- | A string of characters (Word8)
DataEntry_String :: Word64 -> [Word8] -> NASM_DataEntry

-- | A pointer (a label or external symbol)
DataEntry_Pointer :: Word64 -> (NASM_Address, Annot) -> NASM_DataEntry

-- | A BSS section with a given size in bytes
DataEntry_BSS :: Int -> NASM_DataEntry

-- | A data section then consists of:
data NASM_DataSection
NASM_DataSection :: (String, String, Word64) -> Int -> IntMap (Set NASM_Label) -> [NASM_DataEntry] -> NASM_DataSection

-- | (segment,section,address)
[nasm_data_section] :: NASM_DataSection -> (String, String, Word64)

-- | The alignment (0 if unknown)
[nasm_data_section_align] :: NASM_DataSection -> Int

-- | Used internally only
[nasm_data_section_labels] :: NASM_DataSection -> IntMap (Set NASM_Label)

-- | A list of DataEntries
[nasm_data_section_data] :: NASM_DataSection -> [NASM_DataEntry]
instance GHC.Generics.Generic OutputGeneration.NASM.NASM.NASM_Label
instance GHC.Classes.Ord OutputGeneration.NASM.NASM.NASM_Label
instance GHC.Classes.Eq OutputGeneration.NASM.NASM.NASM_Label
instance GHC.Generics.Generic OutputGeneration.NASM.NASM.NASM_Address_Computation
instance GHC.Classes.Eq OutputGeneration.NASM.NASM.NASM_Address_Computation
instance GHC.Generics.Generic OutputGeneration.NASM.NASM.NASM_Address
instance GHC.Classes.Eq OutputGeneration.NASM.NASM.NASM_Address
instance GHC.Generics.Generic OutputGeneration.NASM.NASM.NASM_Operand
instance GHC.Classes.Eq OutputGeneration.NASM.NASM.NASM_Operand
instance GHC.Generics.Generic OutputGeneration.NASM.NASM.NASM_Instruction
instance GHC.Classes.Eq OutputGeneration.NASM.NASM.NASM_Instruction
instance GHC.Generics.Generic OutputGeneration.NASM.NASM.NASM_Line
instance GHC.Classes.Eq OutputGeneration.NASM.NASM.NASM_Line
instance GHC.Generics.Generic OutputGeneration.NASM.NASM.NASM_TextSection
instance GHC.Generics.Generic OutputGeneration.NASM.NASM.NASM_DataEntry
instance GHC.Generics.Generic OutputGeneration.NASM.NASM.NASM_DataSection
instance GHC.Generics.Generic OutputGeneration.NASM.NASM.NASM_Section
instance GHC.Generics.Generic OutputGeneration.NASM.NASM.NASM
instance GHC.Generics.Generic OutputGeneration.NASM.NASM.JSON_NASM_Function
instance Data.Aeson.Types.ToJSON.ToJSON OutputGeneration.NASM.NASM.JSON_NASM_Function
instance Data.Serialize.Serialize OutputGeneration.NASM.NASM.NASM
instance Data.Serialize.Serialize OutputGeneration.NASM.NASM.NASM_Section
instance Data.Serialize.Serialize OutputGeneration.NASM.NASM.NASM_DataSection
instance GHC.Show.Show OutputGeneration.NASM.NASM.NASM_DataSection
instance Data.Serialize.Serialize OutputGeneration.NASM.NASM.NASM_DataEntry
instance Data.Serialize.Serialize OutputGeneration.NASM.NASM.NASM_TextSection
instance GHC.Show.Show OutputGeneration.NASM.NASM.NASM_TextSection
instance Data.Serialize.Serialize OutputGeneration.NASM.NASM.NASM_Line
instance GHC.Show.Show OutputGeneration.NASM.NASM.NASM_Line
instance Data.Serialize.Serialize OutputGeneration.NASM.NASM.NASM_Instruction
instance GHC.Show.Show OutputGeneration.NASM.NASM.NASM_Instruction
instance Data.Serialize.Serialize OutputGeneration.NASM.NASM.NASM_Operand
instance GHC.Show.Show OutputGeneration.NASM.NASM.NASM_Operand
instance Data.Serialize.Serialize OutputGeneration.NASM.NASM.NASM_Address
instance GHC.Show.Show OutputGeneration.NASM.NASM.NASM_Address
instance Data.Serialize.Serialize OutputGeneration.NASM.NASM.NASM_Address_Computation
instance GHC.Show.Show OutputGeneration.NASM.NASM.NASM_Address_Computation
instance Data.Serialize.Serialize OutputGeneration.NASM.NASM.NASM_Label
instance GHC.Show.Show OutputGeneration.NASM.NASM.NASM_Label


module OutputGeneration.NASM.NASMToC

module Binary.Macho

-- | Read in all files needed to read in MACHO binary executable: data,
--   ro_data, symbols, sections, and entries.
macho_read_file :: String -> String -> IO Macho
instance Binary.Generic.BinaryClass Binary.Macho.Macho

module Binary.Read

-- | Reading a binary given a filename (ELF or MachO)
read_binary :: String -> String -> IO (Maybe Binary)

module WithAbstractPredicates.Class
class (Show v, Ord v, Eq pred, Eq finit, BinaryClass bin, Show pred, Show finit) => WithAbstractPredicates bin pred finit v | pred -> finit, pred -> v
symbolically_execute :: WithAbstractPredicates bin pred finit v => LiftingEntry bin pred finit v -> Bool -> [Instruction] -> Maybe [Instruction] -> State (pred, VCS v) ()
verify_postcondition :: WithAbstractPredicates bin pred finit v => LiftingEntry bin pred finit v -> pred -> Bool
finit_to_init_pred :: WithAbstractPredicates bin pred finit v => LiftingEntry bin pred finit v -> finit -> pred
pred_to_finit :: WithAbstractPredicates bin pred finit v => LiftingEntry bin pred finit v -> pred -> finit
resolve_indirection :: WithAbstractPredicates bin pred finit v => LiftingEntry bin pred finit v -> pred -> [Instruction] -> Indirections
is_weaker_than :: WithAbstractPredicates bin pred finit v => LiftingEntry bin pred finit v -> pred -> pred -> Bool
join_preds :: WithAbstractPredicates bin pred finit v => LiftingEntry bin pred finit v -> pred -> pred -> pred
join_finits :: WithAbstractPredicates bin pred finit v => LiftingEntry bin pred finit v -> finit -> finit -> finit
new_finit :: WithAbstractPredicates bin pred finit v => Lifting bin pred finit v -> finit
pp_finit :: WithAbstractPredicates bin pred finit v => Lifting bin pred finit v -> finit -> String


module WithAbstractPredicates.ControlFlow
data NextRips
JustRips :: [Word64] -> NextRips
UnresolvedTarget :: NextRips
Terminal :: NextRips
UnvisitedFunctionCall :: Word64 -> NextRips
next_rips :: (BinaryClass bin, Eq pred) => Lifting bin pred finit v -> Maybe Instruction -> NextRips
resolve_call :: (BinaryClass bin, Eq pred) => Lifting bin pred finit v -> Instruction -> NextRips

-- | Returns true iff the JUMP instruction is actually a CALL followed by
--   implicit RET
jump_is_actually_a_call :: BinaryClass bin => Lifting bin pred finit v -> Instruction -> Bool
get_known_jump_targets :: BinaryClass bin => Lifting bin pred finit v -> Instruction -> [ResolvedJumpTarget]

-- | Export a CFG to .dot file
--   
--   Strongly connected components get the same color.
cfg_to_dot :: BinaryClass bin => bin -> FResult pred v -> String
hex_color_of :: Key -> [IntSet] -> String

-- | Shows the block associated to the givern blockID.
show_block :: CFG -> Int -> String
instance GHC.Show.Show WithAbstractPredicates.ControlFlow.NextRips
instance GHC.Classes.Eq WithAbstractPredicates.ControlFlow.NextRips
instance Base.IntGraph Data.CFG.CFG

module WithAbstractPredicates.GenerateCFG

-- | Produce a CFG
generate_cfg :: WithAbstractPredicates bin pred finit v => Lifting bin pred finit v -> Word64 -> CFG
mk_graph :: WithAbstractPredicates bin pred finit v => Lifting bin pred finit v -> Word64 -> Set (Word64, Word64) -> CFG -> CFG
split_graph' :: Key -> CFG -> Maybe CFG
split_graph :: Key -> CFG -> Maybe CFG
add_edge_to_graph :: Key -> Key -> CFG -> Maybe CFG
add_to_intset :: Key -> Maybe IntSet -> Maybe IntSet
append_to_list :: a -> Maybe [a] -> Maybe [a]
add_edge :: Int -> Int -> Bool -> CFG -> CFG
fromJust' :: (Integral a, Show a) => a -> [a] -> Maybe a -> a
cfg_add_instrs :: WithAbstractPredicates bin pred finit v => Lifting bin pred finit v -> CFG -> CFG
is_consecutive :: Eq a => a -> a -> [a] -> Bool
is_edge :: CFG -> Int -> Int -> Bool

module WithAbstractPredicates.GenerateInvariants

-- | Start propagation at the given entry address with the given initial
--   predicate. Returns a set of invariants, i.e., a mapping of instruction
--   addresses to predicates.
--   
--   Assumes blockID 0 is start of function
generate_invariants :: WithAbstractPredicates bin pred finit v => LiftingEntry bin pred finit v -> CFG -> finit -> (IntMap pred, VCS v)
invs_to_PA :: WithAbstractPredicates bin pred finit v => LiftingEntry bin pred finit v -> CFG -> IntMap pred -> IntMap (PointerAnalysisResult v)
invs_to_post :: WithAbstractPredicates bin pred finit v => LiftingEntry bin pred finit v -> CFG -> IntMap pred -> Postcondition pred
withEntry :: d -> (a, b, c) -> (a, b, c, d)
withoutEntry :: (a, b, c, d) -> (a, b, c)
get_postcondition_for_block :: WithAbstractPredicates bin pred finit v => LiftingEntry bin pred finit v -> Int -> [Instruction] -> IntMap pred -> (pred, VCS v)
propagate :: WithAbstractPredicates bin pred finit v => LiftingEntry bin pred finit v -> CFG -> State (IntMap pred, Set (Int, Int), VCS v) ()
out_edges :: CFG -> Int -> Set (Int, Key)

module WithAbstractPredicates.ContextSensitiveAnalysis
type WithLifting bin pred finit v = StateT (L0 pred finit v) (ReaderT (bin, Config) IO)
type Invariants pred = IntMap pred
type Recursions = IntMap IntSet
data AnalysisResult pred finit v
FoundNewCalls :: IntMap finit -> AnalysisResult pred finit v
AnalyzedWithResult :: FResult pred v -> AnalysisResult pred finit v
lift_to_L0 :: WithAbstractPredicates bin pred finit v => Config -> bin -> finit -> IO (L0 pred finit v)
exploreFunctionEntries :: WithAbstractPredicates bin pred finit v => Graph -> Recursions -> WithLifting bin pred finit v ()
exploreDanglingFunctionPointers :: WithAbstractPredicates bin pred finit v => WithLifting bin pred finit v ()
exploreDanglingRelocations :: WithAbstractPredicates bin pred finit v => WithLifting bin pred finit v ()
exploreFunctionEntry :: WithAbstractPredicates bin pred finit v => Graph -> Recursions -> Word64 -> WithLifting bin pred finit v ()
entry_has_been_done :: Recursions -> Word64 -> WithLifting bin pred finit v Bool
reconsider_mutual_recursive_call :: Recursions -> WithLifting bin pred finit v (Maybe (Int, IntSet))
mark_mutual_recursive_calls :: Word64 -> FResult pred v -> Recursions -> WithLifting bin pred finit v Recursions
mk_static :: WithLifting bin pred finit v (Lifting bin pred finit v)
analyze_entry :: WithAbstractPredicates bin pred finit v => Word64 -> WithLifting bin pred finit v (AnalysisResult pred finit v)
finishExploration :: WithAbstractPredicates bin pred finit v => WithLifting bin pred finit v ()

module WithAbstractSymbolicValues.Class
data SymbolicOperation v
SO_Op :: Opcode -> Int -> Maybe Int -> [v] -> SymbolicOperation v
SO_Bit :: Int -> v -> SymbolicOperation v
SO_SExtend :: Int -> Int -> v -> SymbolicOperation v
SO_Overwrite :: Int -> v -> v -> SymbolicOperation v
SO_Plus :: v -> v -> SymbolicOperation v
SO_Minus :: v -> v -> SymbolicOperation v
SO_Times :: v -> v -> SymbolicOperation v

-- | A statepart is either a register or a region in memory
data SStatePart p

-- | A register
SSP_Reg :: Register -> SStatePart p

-- | A region with a symbolic address and an immediate size.
SSP_Mem :: p -> Int -> SStatePart p
data Sstate v p
Sstate :: Map Register v -> Map (p, Maybe ByteSize) v -> FlagStatus -> Sstate v p
[sregs] :: Sstate v p -> Map Register v
[smem] :: Sstate v p -> Map (p, Maybe ByteSize) v
[sflags] :: Sstate v p -> FlagStatus

-- | A function initialisation consists of a mapping of state parts to
--   values, and memory relations
data MemRelation
Separate :: MemRelation
Aliassing :: MemRelation
Unknown :: MemRelation
data FInit v p
FInit :: Set (SStatePart p, v) -> Map (SStatePart p, SStatePart p) MemRelation -> FInit v p
empty_finit :: FInit v p
unknownSize :: Maybe a
class (Ord v, Eq v, Show v, Eq p, Ord p, Show p) => WithAbstractSymbolicValues ctxt v p | ctxt -> v p
sseparate :: WithAbstractSymbolicValues ctxt v p => ctxt -> String -> p -> Maybe ByteSize -> p -> Maybe ByteSize -> Bool
senclosed :: WithAbstractSymbolicValues ctxt v p => ctxt -> p -> Maybe ByteSize -> p -> Maybe ByteSize -> Bool
salias :: WithAbstractSymbolicValues ctxt v p => ctxt -> p -> Maybe ByteSize -> p -> Maybe ByteSize -> Bool
ssensitive :: WithAbstractSymbolicValues ctxt v p => ctxt -> p -> Maybe ByteSize -> v -> Bool
sread_from_ro_data :: WithAbstractSymbolicValues ctxt v p => ctxt -> p -> Maybe ByteSize -> Maybe v
smk_mem_addresses :: WithAbstractSymbolicValues ctxt v p => ctxt -> String -> v -> Set p
sjoin_values :: (WithAbstractSymbolicValues ctxt v p, Foldable t) => ctxt -> String -> t v -> v
swiden_values :: WithAbstractSymbolicValues ctxt v p => ctxt -> String -> v -> v
sjoin_pointers :: WithAbstractSymbolicValues ctxt v p => ctxt -> [p] -> [p]
top :: WithAbstractSymbolicValues ctxt v p => ctxt -> String -> v
ssemantics :: WithAbstractSymbolicValues ctxt v p => ctxt -> String -> SymbolicOperation v -> v
sflg_semantics :: WithAbstractSymbolicValues ctxt v p => ctxt -> v -> Instruction -> FlagStatus -> FlagStatus
simmediate :: (WithAbstractSymbolicValues ctxt v p, Integral i) => ctxt -> i -> v
smk_init_reg_value :: WithAbstractSymbolicValues ctxt v p => ctxt -> Register -> v
smk_init_mem_value :: WithAbstractSymbolicValues ctxt v p => ctxt -> String -> p -> Maybe ByteSize -> v
scall :: WithAbstractSymbolicValues ctxt v p => ctxt -> Instruction -> State (Sstate v p, VCS v) ()
sjump :: WithAbstractSymbolicValues ctxt v p => ctxt -> Instruction -> State (Sstate v p, VCS v) ()
saddress_has_instruction :: WithAbstractSymbolicValues ctxt v p => ctxt -> Word64 -> Bool
skeep_for_finit :: WithAbstractSymbolicValues ctxt v p => ctxt -> SStatePart p -> v -> Maybe (Set p)
stry_jump_targets :: WithAbstractSymbolicValues ctxt v p => ctxt -> v -> Maybe (Set ResolvedJumpTarget)
stry_resolve_error_call :: WithAbstractSymbolicValues ctxt v p => ctxt -> Instruction -> v -> Maybe Indirection
stry_immediate :: WithAbstractSymbolicValues ctxt v p => ctxt -> v -> Maybe Word64
sis_deterministic :: WithAbstractSymbolicValues ctxt v p => ctxt -> v -> Bool
scheck_regs_in_postcondition :: WithAbstractSymbolicValues ctxt v p => ctxt -> v -> v -> Bool
instance GHC.Generics.Generic (WithAbstractSymbolicValues.Class.SStatePart p)
instance GHC.Classes.Ord p => GHC.Classes.Ord (WithAbstractSymbolicValues.Class.SStatePart p)
instance GHC.Classes.Eq p => GHC.Classes.Eq (WithAbstractSymbolicValues.Class.SStatePart p)
instance GHC.Generics.Generic (WithAbstractSymbolicValues.Class.Sstate v p)
instance (GHC.Classes.Ord v, GHC.Classes.Ord p) => GHC.Classes.Ord (WithAbstractSymbolicValues.Class.Sstate v p)
instance (GHC.Classes.Eq v, GHC.Classes.Eq p) => GHC.Classes.Eq (WithAbstractSymbolicValues.Class.Sstate v p)
instance GHC.Show.Show WithAbstractSymbolicValues.Class.MemRelation
instance GHC.Classes.Ord WithAbstractSymbolicValues.Class.MemRelation
instance GHC.Classes.Eq WithAbstractSymbolicValues.Class.MemRelation
instance GHC.Generics.Generic WithAbstractSymbolicValues.Class.MemRelation
instance (GHC.Classes.Ord p, GHC.Classes.Ord v) => GHC.Classes.Ord (WithAbstractSymbolicValues.Class.FInit v p)
instance (GHC.Classes.Eq p, GHC.Classes.Eq v) => GHC.Classes.Eq (WithAbstractSymbolicValues.Class.FInit v p)
instance GHC.Generics.Generic (WithAbstractSymbolicValues.Class.FInit v p)
instance (Data.Serialize.Serialize v, Data.Serialize.Serialize p, GHC.Classes.Ord p, GHC.Classes.Ord v) => Data.Serialize.Serialize (WithAbstractSymbolicValues.Class.FInit v p)
instance (Control.DeepSeq.NFData p, Control.DeepSeq.NFData v) => Control.DeepSeq.NFData (WithAbstractSymbolicValues.Class.FInit v p)
instance Data.Serialize.Serialize WithAbstractSymbolicValues.Class.MemRelation
instance Control.DeepSeq.NFData WithAbstractSymbolicValues.Class.MemRelation
instance (GHC.Classes.Ord v, Data.Serialize.Serialize v, GHC.Classes.Ord p, Data.Serialize.Serialize p) => Data.Serialize.Serialize (WithAbstractSymbolicValues.Class.Sstate v p)
instance (Control.DeepSeq.NFData v, Control.DeepSeq.NFData p) => Control.DeepSeq.NFData (WithAbstractSymbolicValues.Class.Sstate v p)
instance (GHC.Show.Show v, GHC.Show.Show p) => GHC.Show.Show (WithAbstractSymbolicValues.Class.Sstate v p)
instance Data.Serialize.Serialize p => Data.Serialize.Serialize (WithAbstractSymbolicValues.Class.SStatePart p)
instance Control.DeepSeq.NFData p => Control.DeepSeq.NFData (WithAbstractSymbolicValues.Class.SStatePart p)


module OutputGeneration.NASM.L0ToNASM

-- | Lift an L0 representation to position-independent NASM
lift_L0_to_NASM :: BinaryClass bin => LiftedC bin -> NASM

-- | Rendering NASM to a String
render_NASM :: (BinaryClass a, Eq pred) => (a, Config, L0 pred finit v) -> NASM -> [Char]

-- | get the external functions and objects
externals :: BinaryClass a => (a, b, c) -> Set String

-- | get the external objects
external_objects :: BinaryClass a => (a, b, c) -> [String]

-- | Creating labels Given the entry address of the current function, the
--   blockID of the current basic block, map an address to a label. First,
--   try to see if it matches the _start symbol. Then, try to map the
--   address to a known internal synbol (unstripped binaries may have such
--   symbols available) Then, try to see if at the address a relocation is
--   stored, and use that lavel if so. Otherwise, make a new custom label.
block_label :: (Show p, Integral p, Num p, Eq p, BinaryClass a) => (a, b, c) -> p -> Word64 -> p -> NASM_Label

-- | Information on sections TODO: get from Binary interface
is_ro_data_section :: (String, String, c, d, e) -> Bool

-- | convert a given function entry to a NASM text section
entry_to_NASM :: BinaryClass bin => LiftedC bin -> Word64 -> NASM_Section

-- | convert a list of basic blocks to NASM instructions Note that the
--   order dictates if additional jumps need to be inserted
cfg_blocks_to_NASM :: BinaryClass bin => LiftedC bin -> Word64 -> CFG -> [Int] -> [(Int, [NASM_Line])]

-- | convert a single basic block to NASM instructions A block is
--   translated to a header and its instructions
cfg_block_to_NASM :: BinaryClass bin => LiftedC bin -> Word64 -> CFG -> Int -> Maybe Int -> [NASM_Line]

-- | convert an instruction to a NASM instruction
instr_to_NASM :: BinaryClass bin => (bin, Config, L0 (Sstate SValue SPointer) (FInit SValue SPointer) SValue) -> Word64 -> CFG -> Int -> Instruction -> [NASM_Line]

-- | convert an operand to a NASM operand Return both the translation (a
--   String) as well as an optional annotation
operand_to_NASM :: (BinaryClass bin, Integral t) => (bin, Config, L0 (Sstate SValue SPointer) (FInit SValue SPointer) SValue) -> t -> CFG -> Instruction -> Bool -> Operand -> (NASM_Operand, [(Word64, NASM_Label, Word64)])

-- | convert the address of an operand to a NASM address -- TODO remove
--   this
address_to_NASM :: Operand -> NASM_Address_Computation

-- | convert size directive of an operand to a NASM size directive
size_directive_to_NASM :: Instruction -> Int -> (Int, Bool)

-- | convert opcode to a NASM opcode
opcode_to_NASM :: Opcode -> Maybe Opcode

-- | Symbolization of an address of an operand Return an optional
--   annotation as well.
symbolize_address :: (BinaryClass bin, Integral a) => (bin, Config, L0 (Sstate SValue SPointer) (FInit SValue SPointer) SValue) -> a -> CFG -> Instruction -> Operand -> (NASM_Address, [(Word64, NASM_Label, Word64)])

-- | Symbolization of an immediate value that is used as an address
symbolize_immediate :: BinaryClass bin => LiftedC bin -> Maybe (Int, CFG) -> Bool -> Word64 -> Maybe (NASM_Address, Annot)

-- | Symbolize (try to) an immediate address falling into the range of a
--   section
try_symbolize_base :: BinaryClass bin => LiftedC bin -> Bool -> Word64 -> Maybe (NASM_Address, Annot)

-- | There is one specific symbol frequently encountered for which we
--   cannot find the appropiate library to load. It is related to debugging
--   information (the -g option of GCC). We therefore pvodie our own
--   implementation: just a dummy, which is what the real function seems to
--   do as well.
__gmon_start_implementation :: String

module WithAbstractSymbolicValues.Sstate
execSstate :: State (Sstate v p, VCS v) b -> Sstate v p -> Sstate v p
evalSstate :: State (Sstate v p, VCS v) a -> Sstate v p -> a

-- | Read from a register
sread_rreg :: WithAbstractSymbolicValues ctxt v p => ctxt -> Register -> (Sstate v p, b) -> v
sread_reg :: WithAbstractSymbolicValues ctxt v p => ctxt -> Register -> State (Sstate v p, VCS v) v

-- | Write to a register
swrite_rreg :: WithAbstractSymbolicValues ctxt v p => ctxt -> String -> Register -> v -> State (Sstate v p, VCS v) ()
soverwrite_reg :: WithAbstractSymbolicValues ctxt v p => ctxt -> String -> Bool -> Register -> v -> State (Sstate v p, VCS v) ()
swrite_reg :: WithAbstractSymbolicValues ctxt v p => ctxt -> String -> Register -> v -> State (Sstate v p, VCS v) ()

-- | Read from memory
sread_mem :: WithAbstractSymbolicValues ctxt v p => ctxt -> String -> v -> Maybe ByteSize -> State (Sstate v p, VCS v) v
sread_mem_from_ptr :: WithAbstractSymbolicValues ctxt v p => ctxt -> String -> p -> Maybe ByteSize -> State (Sstate v p, VCS v) v

-- | Write to memory
swrite_mem :: WithAbstractSymbolicValues ctxt v p => ctxt -> Bool -> v -> Maybe ByteSize -> v -> State (Sstate v p, VCS v) ()
swrite_mem_to_ptr :: WithAbstractSymbolicValues ctxt v p => ctxt -> Bool -> p -> Maybe ByteSize -> v -> State (Sstate v p, VCS v) ()
swrite_flags :: WithAbstractSymbolicValues ctxt v p => ctxt -> v -> Instruction -> State (Sstate v p, VCS v) ()
clean_flg :: SStatePart p -> FlagStatus -> FlagStatus
write_sp :: WithAbstractSymbolicValues ctxt v p => ctxt -> SStatePart p -> v -> State (Sstate v p, VCS v) ()
read_sp :: WithAbstractSymbolicValues ctxt v p => ctxt -> SStatePart p -> State (Sstate v p, VCS v) v

module WithAbstractSymbolicValues.FInit

-- | The initial predicate.
finit_to_init_sstate :: WithAbstractSymbolicValues ctxt v p => ctxt -> FInit v p -> Sstate v p

-- | Convert the current invariant into a function initialisation
sstate_to_finit :: WithAbstractSymbolicValues ctxt v p => ctxt -> Sstate v p -> FInit v p

-- | The join between two function initialisations
join_finit :: WithAbstractSymbolicValues ctxt v p => ctxt -> FInit v p -> FInit v p -> FInit v p
pp_finitC :: (Show p, Show v, Ord p) => FInit v p -> String
instance (GHC.Classes.Eq v, GHC.Show.Show v, GHC.Show.Show p) => GHC.Show.Show (WithAbstractSymbolicValues.Class.FInit v p)
instance GHC.Show.Show p => GHC.Show.Show (WithAbstractSymbolicValues.Class.SStatePart p)

module WithAbstractSymbolicValues.SymbolicExecution

-- | Add a function_pointer_intro to the given symbolic predicate
add_function_pointer :: Ord v => Word64 -> Key -> (a, Set (VerificationCondition v)) -> (a, Set (VerificationCondition v))
add_pa_result :: Ord v => Word64 -> PointerAnalysisResult v -> (a, Set (VerificationCondition v)) -> (a, Set (VerificationCondition v))

-- | Given the address of an operand of an instruction, resolve it given
--   the current state.
sresolve_address :: WithAbstractSymbolicValues ctxt v p => ctxt -> Operand -> State (Sstate v p, VCS v) v
add_base_displ :: (Integral a, WithAbstractSymbolicValues ctxt a p) => ctxt -> Register -> a -> StateT (Sstate a p, VCS a) Identity a
sread_operand :: WithAbstractSymbolicValues ctxt v p => ctxt -> String -> Operand -> State (Sstate v p, VCS v) v
swrite_operand :: WithAbstractSymbolicValues ctxt v p => ctxt -> Instruction -> Bool -> Operand -> v -> State (Sstate v p, VCS v) ()
add_jump_to_pred :: Instruction -> Instruction -> FlagStatus -> FlagStatus
sreturn :: WithAbstractSymbolicValues ctxt v p => ctxt -> Instruction -> State (Sstate v p, VCS v) ()
slea :: WithAbstractSymbolicValues ctxt v p => ctxt -> Instruction -> Operand -> Operand -> State (Sstate v p, VCS v) ()
smov :: WithAbstractSymbolicValues ctxt v p => ctxt -> a -> Instruction -> State (Sstate v p, VCS v) ()
sgeneric_cinstr :: WithAbstractSymbolicValues ctxt v p => ctxt -> Instruction -> State (Sstate v p, VCS v) ()
maybe_operand_size :: [Operand] -> Maybe ByteSize
sexec_cinstr :: WithAbstractSymbolicValues ctxt v p => ctxt -> Instruction -> State (Sstate v p, VCS v) ()
sset_rip :: WithAbstractSymbolicValues ctxt v p => ctxt -> Instruction -> State (Sstate v p, VCS v) ()
sexec_instr :: WithAbstractSymbolicValues ctxt v p => ctxt -> Bool -> Instruction -> State (Sstate v p, VCS v) ()
sexec_block :: WithAbstractSymbolicValues ctxt v p => ctxt -> Bool -> [Instruction] -> Maybe [Instruction] -> State (Sstate v p, VCS v) ()
sjoin_mem :: WithAbstractSymbolicValues ctxt v p => ctxt -> String -> Sstate v p -> Sstate v p -> Map (p, Maybe ByteSize) v
sjoin_regs :: WithAbstractSymbolicValues ctxt v p => ctxt -> Map Register v -> Map Register v -> Map Register v
sjoin_states :: WithAbstractSymbolicValues p v p => p -> [Char] -> Sstate v p -> Sstate v p -> Sstate v p

-- | The supremum of a list of predicates
supremum :: WithAbstractSymbolicValues ctxt v p => ctxt -> [Sstate v p] -> Sstate v p
simplies :: WithAbstractSymbolicValues p v p => p -> Sstate v p -> Sstate v p -> Bool
sverify_postcondition :: WithAbstractSymbolicValues ctxt v p => ctxt -> Sstate v p -> Bool

module WithAbstractSymbolicValues.ResolveIndirections
stry_resolve_indirection :: WithAbstractSymbolicValues ctxt v p => ctxt -> Sstate v p -> [Instruction] -> Indirections

module WithAbstractSymbolicValues.InstanceOfAbstractPredicates
instance (GHC.Show.Show v, GHC.Classes.Ord v, Binary.Generic.BinaryClass bin, WithAbstractSymbolicValues.Class.WithAbstractSymbolicValues (bin, Config.Config, Data.L0.L0 (WithAbstractSymbolicValues.Class.Sstate v p) (WithAbstractSymbolicValues.Class.FInit v p) v, GHC.Word.Word64) v p) => WithAbstractPredicates.Class.WithAbstractPredicates bin (WithAbstractSymbolicValues.Class.Sstate v p) (WithAbstractSymbolicValues.Class.FInit v p) v


module WithNoAbstraction.Pointers

-- | An abstract domain for pointers
data PointerDomain
Domain_Bases :: NESet PointerBase -> PointerDomain
Domain_Sources :: NESet BotSrc -> PointerDomain

-- | Returns true iff a symbol is associated with the address.
address_has_external_symbol :: (BinaryClass a, Integral a) => a -> a -> Bool

-- | Returns true iff the expression is an immediate address falling into
--   the range of sections of the binary
expr_is_global_immediate :: BinaryClass bin => bin -> SimpleExpr -> Bool

-- | Returns true if the expression has a local pointerbase
expr_is_highly_likely_local_pointer :: BinaryClass bin => bin -> SimpleExpr -> Bool
expr_is_maybe_local_pointer :: BinaryClass bin => bin -> SimpleExpr -> Bool
expr_is_highly_likely_global_pointer :: BinaryClass bin => bin -> SimpleExpr -> Bool
expr_is_maybe_global_pointer :: BinaryClass bin => bin -> SimpleExpr -> Bool
no_finit :: FInit v p

-- | Returns true iff the give domain is highly likely local to the current
--   function
is_local_pointer_domain :: Bool -> PointerDomain -> Bool

-- | Returns true iff the give domain is highly likely global
is_global_pointer_domain :: Bool -> PointerDomain -> Bool

-- | Returns true if the expression has known pointerbases.
expr_highly_likely_pointer :: BinaryClass bin => bin -> FInit SValue SPointer -> SimpleExpr -> Bool

-- | Returns true iff the given symbolic regions are necessarily separate.
--   TODO: add VCS, not necc
necessarily_separate :: BinaryClass p => p -> FInit SValue SPointer -> String -> SimpleExpr -> Maybe SimpleExpr -> SimpleExpr -> Maybe SimpleExpr -> Bool
necessarily_separate_no_size :: BinaryClass p => p -> FInit SValue SPointer -> String -> SimpleExpr -> SimpleExpr -> Bool

-- | Returns true iff the given symbolic regions are necessarily equal.
necessarily_equal :: SimpleExpr -> SimpleExpr -> Bool

-- | Returns true iff the given symbolic regions are ncessarily separate.
--   For example: <tt>[RSP-16,4]</tt> is separate from <tt>[RSP-12,8]</tt>
--   <tt>[RSP+8,4]</tt> is separate from <tt>[RSP,8]</tt>
--   
--   If none of the cases apply where it can be shjown arithmetically that
--   the expressions are separate, we check whether the expressions can be
--   proven separate based on their domains (see
--   <a>separate_pointer_domains</a>).
necessarily_separate_expressions :: (Ord b, Num b) => SimpleExpr -> b -> SimpleExpr -> b -> Bool

-- | Returns true iff the given symbolic region is necessarily enclosed in
--   the other. For example: <tt>[RSP-16,4]</tt> is enclosed in
--   <tt>[RSP-18,8]</tt> <tt>[RSP+4,4]</tt> is enclosed in <tt>[RSP,8]</tt>
--   
--   Will return <tt>False</tt> if the expressions contain bottom.
necessarily_enclosed :: Integral p => SimpleExpr -> p -> SimpleExpr -> p -> Bool
get_pointer_domain :: BinaryClass bin => bin -> FInit SValue SPointer -> SimpleExpr -> Maybe PointerDomain
get_pointer_base_set :: BinaryClass bin => bin -> FInit SValue SPointer -> SimpleExpr -> Set PointerBase

-- | Returns true iff the two given expressions can be shown to be separate
--   based on their domains.
separate_pointer_domains :: BinaryClass p => p -> FInit SValue SPointer -> SimpleExpr -> SimpleExpr -> (Bool, Bool)

-- | Two pointerbases are separate if they refer to completely different
--   parts of the memory. We assume Stackframe, Global address space, and
--   Heap are separate. Two different <tt>malloc</tt>'s point to different
--   regions.
pointer_bases_separate :: p -> FInit v SPointer -> p -> PointerBase -> PointerBase -> Bool
pointer_bases_separate_necessarily :: p -> FInit v SPointer -> PointerBase -> PointerBase -> Bool
pointer_bases_separate_possibly :: p -> FInit v SPointer -> PointerBase -> PointerBase -> Bool

-- | Returns true iff the two given expressions have global pointerbases in
--   different segments/sections of the binary. We do not assume that such
--   pointers are separate, but do assert it.
pointers_from_different_global_section :: (BinaryClass bin, Integral a, Integral a) => bin -> a -> a -> Bool
srcs_of_expr :: BinaryClass t => t -> SimpleExpr -> Set BotSrc

-- | Returns the set of sources of the bottom type
srcs_of_bottyp :: BinaryClass t => t -> BotTyp -> Set BotSrc

-- | Returns the set of sources of the pointerbase
srcs_of_base :: BinaryClass t => t -> PointerBase -> Set BotSrc
source_sets_separate :: p -> FInit v SPointer -> Bool -> Set BotSrc -> Set BotSrc -> Bool

-- | Two sources are inputs for separate pointers if, e.g., one of them is
--   the stackpointer and the other a malloc-return-value.
sources_separate :: p -> FInit v SPointer -> Bool -> BotSrc -> BotSrc -> Bool
sources_separate_necessarily :: p -> FInit v SPointer -> BotSrc -> BotSrc -> Bool
sources_separate_possibly :: p -> FInit v SPointer -> BotSrc -> BotSrc -> Bool
instance GHC.Show.Show WithNoAbstraction.Pointers.PointerDomain
instance GHC.Classes.Ord WithNoAbstraction.Pointers.PointerDomain
instance GHC.Classes.Eq WithNoAbstraction.Pointers.PointerDomain
instance GHC.Generics.Generic WithNoAbstraction.Pointers.PointerDomain


module OutputGeneration.Reconstruction

module OutputGeneration.Metrics
mk_metrics :: BinaryClass p => p -> L0 pred finit SValue -> [Char]
mk_metric_pointerDesignations :: (BinaryClass p, Num a) => p -> IntMap (PointerAnalysisResult SValue) -> Map String a
get_pointer_specifity_cpointer :: BinaryClass p => p -> SValue -> String
get_types :: (Foldable t, BinaryClass p) => p -> t SimpleExpr -> [Char]
designations_to_percentages :: Map String Int -> Map String Double
intDiv :: (Integral a, Integral b) => a -> b -> Double


module WithNoAbstraction.SymbolicExecution
type Static bin v = LiftingEntry bin (Sstate SValue SPointer) (FInit SValue SPointer) v
traceTop :: p -> a -> a
mk_top :: String -> SValue
ctry_immediate :: SValue -> Maybe Word64
cis_deterministic :: SValue -> Bool
mk_concrete :: BinaryClass bin => Static bin v -> String -> NESet SimpleExpr -> SValue
mk_concreteS :: BinaryClass bin => Static bin v -> SimpleExpr -> SValue
mk_saddends :: BinaryClass bin => (bin, Config, L0 (Sstate SValue SPointer) (FInit SValue SPointer) v, Word64) -> NESet SimpleExpr -> SValue
group_immediates :: BinaryClass bin => Static bin v -> NESet SimpleExpr -> NESet SimpleExpr
cimmediate :: (Integral i, BinaryClass bin) => Static bin v -> i -> SValue
cwiden :: BinaryClass bin => Static bin v -> String -> SValue -> SValue
expr_to_addends :: BinaryClass bin => Static bin v -> SimpleExpr -> [SimpleExpr]
cjoin :: BinaryClass bin => (bin, Config, L0 (Sstate SValue SPointer) (FInit SValue SPointer) v, Word64) -> [Char] -> SValue -> SValue -> SValue
cjoin_all :: Foldable t => BinaryClass bin => Static bin v -> String -> t SValue -> SValue
cjoin_pointers :: BinaryClass bin => Static bin v -> [SPointer] -> [SPointer]
mk_expr :: BinaryClass bin => Static bin v -> SimpleExpr -> SimpleExpr
svalue_plus :: BinaryClass bin => Static bin v -> Int -> SValue -> SValue -> SValue
svalue_minus :: BinaryClass bin => Static bin v -> Int -> SValue -> SValue -> SValue
svalue_and :: BinaryClass bin => Static bin v -> Int -> SValue -> SValue -> SValue
svalue_unop :: BinaryClass bin => Static bin v -> String -> (SimpleExpr -> SimpleExpr) -> SValue -> SValue
svalue_takebits :: BinaryClass bin => Static bin v -> Int -> SValue -> SValue
svalue_sextend :: BinaryClass bin => Static bin v -> Int -> Int -> SValue -> SValue
svalue_apply :: BinaryClass bin => Static bin v -> String -> ([SimpleExpr] -> SimpleExpr) -> [SValue] -> SValue
data CSemantics
ApplyPlus :: Int -> CSemantics
ApplyMinus :: Int -> CSemantics
ApplyNeg :: Int -> CSemantics
ApplyDec :: Int -> CSemantics
ApplyInc :: Int -> CSemantics
ApplyAnd :: Int -> CSemantics
ApplyMov :: CSemantics
ApplyCMov :: CSemantics
ApplySExtend :: Int -> Int -> CSemantics
Apply :: ([SimpleExpr] -> SimpleExpr) -> CSemantics
SetXX :: CSemantics
SExtension_HI :: CSemantics
NoSemantics :: CSemantics
csemantics :: BinaryClass bin => Static bin v -> String -> SymbolicOperation SValue -> SValue
mnemonic_to_semantics :: Opcode -> Int -> Maybe Int -> CSemantics
replace_rip_in_operand :: Integral a => a -> Operand -> Operand
cflg_semantics :: BinaryClass bin => Static bin v -> a -> Instruction -> FlagStatus -> FlagStatus
try_get_base :: BinaryClass bin => Static bin v -> SimpleExpr -> Maybe SimpleExpr
base_to_expr :: PointerBase -> SimpleExpr
cmk_mem_addresses :: BinaryClass bin => Static bin v -> String -> SValue -> Set SPointer
cmk_init_reg_value :: BinaryClass bin => Static bin v -> Register -> SValue
cmk_init_mem_value :: BinaryClass bin => Static bin v -> String -> SPointer -> Maybe ByteSize -> SValue
cseparate :: BinaryClass bin => Static bin v -> String -> SPointer -> Maybe ByteSize -> SPointer -> Maybe ByteSize -> Bool
lookup_finit :: Integral a => (a, b, L0 pred finit v, a) -> finit
calias :: (Eq a, Eq a) => p -> a -> a -> a -> a -> Bool
cnecessarily_enclosed :: p -> SPointer -> Maybe ByteSize -> SPointer -> Maybe ByteSize -> Bool
csensitive :: BinaryClass p => (p, b, c, d) -> SPointer -> Maybe ByteSize -> SValue -> Bool
cread_from_ro_data :: BinaryClass bin => Static bin v -> SPointer -> Maybe ByteSize -> Maybe SValue
cis_local :: BinaryClass bin => (bin, b, c, d) -> SPointer -> Bool
ckeep_for_finit :: BinaryClass bin => (bin, Config, L0 (Sstate SValue SPointer) (FInit SValue SPointer) v, Word64) -> SStatePart SPointer -> SValue -> Maybe (Set SPointer)
is_function_pointer :: BinaryClass p => p -> SValue -> Bool
check_regs_in_postcondition :: BinaryClass bin => Static bin v -> SValue -> SValue -> Bool
ctry_resolve_error_call :: BinaryClass bin => (bin, Config, L0 pred finit v, d) -> Instruction -> SValue -> Maybe Indirection
mapMaybeS :: Ord b => (a -> Maybe b) -> Set a -> Set b
mapMaybeNES :: Ord b => (a -> Maybe b) -> NESet a -> Set b
data ExternalFunctionOutput
FreshPointer :: ExternalFunctionOutput
UnknownReturnValue :: ExternalFunctionOutput
Input :: Register -> ExternalFunctionOutput
data ExternalFunctionBehavior
ExternalFunctionBehavior :: [Register] -> ExternalFunctionOutput -> ExternalFunctionBehavior
[f_inputs] :: ExternalFunctionBehavior -> [Register]
[f_output] :: ExternalFunctionBehavior -> ExternalFunctionOutput
param :: (Eq a, Num a) => a -> Register
pure_and_fresh :: ExternalFunctionBehavior
pure_and_unknown :: ExternalFunctionBehavior

-- | a list of some function that return a heap-pointer through RAX. The
--   pointer is assumed to be fresh.
external_function_behavior :: String -> ExternalFunctionBehavior

-- | Backward transposition Let p be the current predicate and let the
--   equality sp == v be from the predicate after execution of an internal
--   function. For example, p contains: RSP == RSP0 - 64 RSI == 10
--   
--   And after execution of the function, we have: *[RSP0+16,8] == RSI0
--   
--   Transposing this equality produces: *[RSP0-40,8] == 10
transpose_bw_svalue :: BinaryClass bin => Static bin v -> Sstate SValue SPointer -> SValue -> SValue
transpose_bw_addends :: BinaryClass bin => (bin, Config, L0 (Sstate SValue SPointer) (FInit SValue SPointer) v, Word64) -> Sstate SValue SPointer -> SimpleExpr -> SValue
transpose_bw_spointer :: BinaryClass bin => Static bin v -> Sstate SValue SPointer -> SPointer -> Set SPointer
transpose_bw_reg :: BinaryClass bin => Static bin v -> Sstate SValue SPointer -> (Register, SValue) -> Maybe (Register, SValue)
transpose_bw_mem :: BinaryClass bin => Static bin v -> Sstate SValue SPointer -> ((SPointer, Maybe ByteSize), SValue) -> [((SPointer, Maybe ByteSize), SValue)]
transpose_bw_e :: BinaryClass bin => Static bin v -> Sstate SValue SPointer -> SimpleExpr -> SValue
transpose_bw_sp :: BinaryClass bin => Static bin v -> Sstate SValue SPointer -> StatePart -> SValue
data FunctionType
AnalyzedInternalFunction :: Sstate SValue SPointer -> FunctionType
ExternalFunction :: FunctionType
AnalyzedInternalFunctionTerminates :: FunctionType
AnalyzedInternalFunctionUnknown :: FunctionType
get_function_type :: BinaryClass bin => Static bin v -> Instruction -> String -> FunctionType

-- | Executes semantics for external functions.
call :: BinaryClass bin => Static bin v -> Instruction -> State (Sstate SValue SPointer, VCS SValue) ()
is_top_stackframe :: SimpleExpr -> Maybe ByteSize -> Bool
jump :: BinaryClass bin => Static bin v -> Instruction -> State (Sstate SValue SPointer, VCS SValue) ()
ctry_jump_targets :: BinaryClass bin => Static bin v -> SValue -> Maybe (Set ResolvedJumpTarget)
instance Binary.Generic.BinaryClass bin => WithAbstractSymbolicValues.Class.WithAbstractSymbolicValues (WithNoAbstraction.SymbolicExecution.Static bin v) Data.SValue.SValue Data.SPointer.SPointer
