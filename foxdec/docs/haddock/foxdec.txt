-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Formaly Verified x86-64 Decompilation
--   
--   This package contains tools for decompilation based on formal methods.
@package foxdec
@version 0.1.0.0

module ParserCalls
isWhiteSpace :: Char -> Bool
whitespace :: ParsecT String u Identity Char
whitespaces :: ParsecT String u Identity ()
call :: ParsecT String u Identity (Key, Bool)
calls :: ParsecT String u Identity (IntMap Bool)
parse_calls :: String -> IO (Either ParseError (IntMap Bool))

module ParserDump
isWhiteSpace :: Char -> Bool
whitespace :: ParsecT [Char] u Identity Char
whitespaces :: ParsecT [Char] u Identity ()
bytes :: ParsecT [Char] u Identity [Word8]
data_line :: ParsecT [Char] u Identity [(Key, Word8)]
dump :: ParsecT [Char] u Identity (IntMap Word8)
dumps :: ParsecT [Char] u Identity (IntMap Word8)
parse_dump :: String -> IO (Either ParseError (IntMap Word8))
ignored_line :: ParsecT [Char] u Identity Char

module ParserIndirections
isWhiteSpace :: Char -> Bool
whitespace :: ParsecT String u Identity Char
whitespaces :: ParsecT String u Identity ()
indirection :: ParsecT String u Identity (Key, IntSet)
indirections :: ParsecT String u Identity (IntMap IntSet)
parse_indirections :: String -> IO (Either ParseError (IntMap IntSet))


-- | (<b>DATA,</b>common) | addr = 0x00000001000041d0 | size =
--   0x0000000000000010
module ParserSections
isWhiteSpace :: Char -> Bool
whitespace :: ParsecT String u Identity Char
whitespaces :: ParsecT String u Identity ()
hexnum_with_0x :: ParsecT [Char] u Identity Int
section_info :: ParsecT String u Identity ([Char], [Char], Int, Int)
sections_info :: ParsecT String u Identity [([Char], [Char], Int, Int)]
parse_sections :: String -> IO (Either ParseError [(String, String, Int, Int)])

module ParserSymbols
isWhiteSpace :: Char -> Bool
whitespace :: ParsecT [Char] u Identity Char
whitespaces :: ParsecT [Char] u Identity ()
hexnum_with_0x :: ParsecT [Char] u Identity Key
symb :: ParsecT [Char] u Identity (Key, [Char])
symbols :: ParsecT [Char] u Identity (IntMap [Char])
parse_symbols :: String -> IO (Either ParseError (IntMap String))

module SCC
class IntGraph g
intgraph_post :: IntGraph g => g -> Int -> IntSet
intgraph_V :: IntGraph g => g -> IntSet
data SCC_state
SCC_State :: IntMap Int -> IntMap Int -> Int -> [Int] -> [IntSet] -> SCC_state
[scc_indices] :: SCC_state -> IntMap Int
[scc_lowlinks] :: SCC_state -> IntMap Int
[scc_index] :: SCC_state -> Int
[scc_stack] :: SCC_state -> [Int]
[scc_return] :: SCC_state -> [IntSet]
set_index_of :: Key -> (SCC_state -> Int) -> SCC_state -> SCC_state
set_lowlink_of :: Key -> (SCC_state -> Int) -> SCC_state -> SCC_state
set_index :: (SCC_state -> Int) -> SCC_state -> SCC_state
push :: Int -> SCC_state -> SCC_state
pop_and_return :: Int -> SCC_state -> SCC_state
strongconnect :: IntGraph g => g -> Int -> IntSet -> State SCC_state ()
compute_all_sccs :: IntGraph g => g -> IntSet -> State SCC_state ()
init_scc_state :: SCC_state
scc_of :: IntGraph g => g -> Int -> IntSet -> [IntSet]
all_sccs :: IntGraph g => g -> IntSet -> [IntSet]

module Base
showHex :: (Integral a, Show a) => a -> String
showHex_list :: (Integral a, Show a) => [a] -> [Char]
showHex_set :: IntSet -> [Char]
showHex_option :: (Integral a, Show a) => Maybe a -> [Char]
readHex' :: (Eq a, Num a) => String -> a
im_lookup :: [Char] -> IntMap p -> Key -> p
findString :: Eq a => [a] -> [a] -> Maybe Int
strip_parentheses :: [Char] -> [Char]
bytes_to_word :: [Word8] -> Word64
word_to_sint :: Int -> Word64 -> Int
data Graph
Edges :: IntMap IntSet -> Graph
graph_add_edges :: Graph -> Key -> IntSet -> Graph
graph_delete :: Graph -> Key -> Graph
graph_is_parent :: Graph -> Key -> Bool
graph_is_edge :: Graph -> Key -> Key -> Bool
graph_nontrivial_scc :: Graph -> IntSet
graph_find_next :: Graph -> Maybe Int
hex_color_of_text :: String -> String
hex_colors :: [[Char]]
instance GHC.Generics.Generic Base.Graph
instance Data.Serialize.Serialize Base.Graph
instance SCC.IntGraph Base.Graph

module X86_Datastructures
data Instr
Instr :: Int -> Maybe Prefix -> Opcode -> Maybe Operand -> Maybe Operand -> Maybe Operand -> Maybe String -> Int -> Instr
[i_addr] :: Instr -> Int
[i_prefix] :: Instr -> Maybe Prefix
[i_opcode] :: Instr -> Opcode
[i_op1] :: Instr -> Maybe Operand
[i_op2] :: Instr -> Maybe Operand
[i_op3] :: Instr -> Maybe Operand
[i_annot] :: Instr -> Maybe String
[i_size] :: Instr -> Int
data Prefix
InvalidPrefix :: Prefix
REP :: Prefix
REPZ :: Prefix
LOCK :: Prefix
BND :: Prefix
data Register
InvalidRegister :: Register
RIP :: Register
EIP :: Register
RAX :: Register
EAX :: Register
AX :: Register
AH :: Register
AL :: Register
RBX :: Register
EBX :: Register
BX :: Register
BH :: Register
BL :: Register
RCX :: Register
ECX :: Register
CX :: Register
CH :: Register
CL :: Register
RDX :: Register
EDX :: Register
DX :: Register
DH :: Register
DL :: Register
RDI :: Register
EDI :: Register
DI :: Register
DIL :: Register
RSI :: Register
ESI :: Register
SI :: Register
SIL :: Register
RSP :: Register
ESP :: Register
SP :: Register
SPL :: Register
RBP :: Register
EBP :: Register
BP :: Register
BPL :: Register
R15 :: Register
R15D :: Register
R15W :: Register
R15B :: Register
R14 :: Register
R14D :: Register
R14W :: Register
R14B :: Register
R13 :: Register
R13D :: Register
R13W :: Register
R13B :: Register
R12 :: Register
R12D :: Register
R12W :: Register
R12B :: Register
R11 :: Register
R11D :: Register
R11W :: Register
R11B :: Register
R10 :: Register
R10D :: Register
R10W :: Register
R10B :: Register
R9 :: Register
R9D :: Register
R9W :: Register
R9B :: Register
R8 :: Register
R8D :: Register
R8W :: Register
R8B :: Register
CS :: Register
DS :: Register
ES :: Register
FS :: Register
GS :: Register
SS :: Register
EIZ :: Register
RIZ :: Register
ST0 :: Register
ST1 :: Register
ST2 :: Register
ST3 :: Register
ST4 :: Register
ST5 :: Register
ST6 :: Register
ST7 :: Register
XMM0 :: Register
XMM1 :: Register
XMM2 :: Register
XMM3 :: Register
XMM4 :: Register
XMM5 :: Register
XMM6 :: Register
XMM7 :: Register
XMM8 :: Register
XMM9 :: Register
XMM10 :: Register
XMM11 :: Register
XMM12 :: Register
XMM13 :: Register
XMM14 :: Register
XMM15 :: Register
XMM0_L :: Register
XMM1_L :: Register
XMM2_L :: Register
XMM3_L :: Register
XMM4_L :: Register
XMM5_L :: Register
XMM6_L :: Register
XMM7_L :: Register
XMM8_L :: Register
XMM9_L :: Register
XMM10_L :: Register
XMM11_L :: Register
XMM12_L :: Register
XMM13_L :: Register
XMM14_L :: Register
XMM15_L :: Register
data Flag
ZF :: Flag
CF :: Flag
SF :: Flag
OF :: Flag
PF :: Flag
InvalidFlag :: Flag
data Address
FromReg :: Register -> Address
AddrImm :: Int -> Address
AddrMinus :: Address -> Address -> Address
AddrPlus :: Address -> Address -> Address
AddrTimes :: Address -> Address -> Address
SizeDir :: Int -> Address -> Address
data Operand
Address :: Address -> Operand
Reg :: Register -> Operand
Immediate :: Word64 -> Operand
data Opcode
InvalidOpcode :: Opcode
AAA :: Opcode
AAD :: Opcode
AAM :: Opcode
AAS :: Opcode
ADC :: Opcode
ADD :: Opcode
ADDPD :: Opcode
ADDPS :: Opcode
ADDSD :: Opcode
ADDSS :: Opcode
ADDSUBPD :: Opcode
ADDUBPS :: Opcode
AND :: Opcode
ANDNPD :: Opcode
ANDNPS :: Opcode
ANDPD :: Opcode
ANDPS :: Opcode
ARPL :: Opcode
BLENDVPS :: Opcode
BOUND :: Opcode
BSF :: Opcode
BSR :: Opcode
BT :: Opcode
BTC :: Opcode
BTR :: Opcode
BTS :: Opcode
CALL :: Opcode
CALLF :: Opcode
CBW :: Opcode
CDQ :: Opcode
CDQE :: Opcode
CLC :: Opcode
CLD :: Opcode
CLFLUSH :: Opcode
CLI :: Opcode
CLTS :: Opcode
CMC :: Opcode
CMOVA :: Opcode
CMOVAE :: Opcode
CMOVB :: Opcode
CMOVBE :: Opcode
CMOVC :: Opcode
CMOVE :: Opcode
CMOVG :: Opcode
CMOVGE :: Opcode
CMOVL :: Opcode
CMOVLE :: Opcode
CMOVNA :: Opcode
CMOVNAE :: Opcode
CMOVNB :: Opcode
CMOVNBE :: Opcode
CMOVNC :: Opcode
CMOVNE :: Opcode
CMOVNG :: Opcode
CMOVNGE :: Opcode
CMOVNL :: Opcode
CMOVNLE :: Opcode
CMOVNO :: Opcode
CMOVNP :: Opcode
CMOVNS :: Opcode
CMOVNZ :: Opcode
CMOVO :: Opcode
CMOVP :: Opcode
CMOVPE :: Opcode
CMOVPO :: Opcode
CMOVS :: Opcode
CMOVZ :: Opcode
CMP :: Opcode
CMPEQSD :: Opcode
CMPNEQSD :: Opcode
CMPLTSD :: Opcode
CMPS :: Opcode
CMPSB :: Opcode
CMPSD :: Opcode
CMPXCHG :: Opcode
CMPXCHG16B :: Opcode
CMPXCHG8B :: Opcode
COMISD :: Opcode
COMISS :: Opcode
CPUID :: Opcode
CQO :: Opcode
CVTDQ2PD :: Opcode
CVTSD2SS :: Opcode
CVTSI2SD :: Opcode
CVTSI2SS :: Opcode
CVTSS2SD :: Opcode
CVTTSD2SI :: Opcode
CVTTSS2SI :: Opcode
CVTTPD2DQ :: Opcode
CWD :: Opcode
CWDE :: Opcode
DAA :: Opcode
DAS :: Opcode
DEC :: Opcode
DIV :: Opcode
DIVPD :: Opcode
DIVPS :: Opcode
DIVSD :: Opcode
DIVSS :: Opcode
EMMS :: Opcode
ENDBR64 :: Opcode
ENTER :: Opcode
EXTRACTPS :: Opcode
FABS :: Opcode
FADD :: Opcode
FADDP :: Opcode
FBLD :: Opcode
FBSTP :: Opcode
FCHS :: Opcode
FCLEX :: Opcode
FCMOVB :: Opcode
FCMOVBE :: Opcode
FCMOVE :: Opcode
FCMOVNB :: Opcode
FCMOVNBE :: Opcode
FCMOVNE :: Opcode
FCMOVNU :: Opcode
FCMOVU :: Opcode
FCOM :: Opcode
FCOMI :: Opcode
FCOMIP :: Opcode
FCOMP :: Opcode
FCOMPI :: Opcode
FCOMPP :: Opcode
FCOS :: Opcode
FDIV :: Opcode
FDIVP :: Opcode
FDIVR :: Opcode
FDIVRP :: Opcode
FFREE :: Opcode
FRNDINT :: Opcode
FIADD :: Opcode
FICOM :: Opcode
FICOMP :: Opcode
FIDIV :: Opcode
FIDIVR :: Opcode
FILD :: Opcode
FIMUL :: Opcode
FINIT :: Opcode
FIST :: Opcode
FISTP :: Opcode
FISTPP :: Opcode
FISTTP :: Opcode
FISUB :: Opcode
FISUBR :: Opcode
FLD :: Opcode
FLD1 :: Opcode
FLDCW :: Opcode
FLDENV :: Opcode
FLDL2E :: Opcode
FLDL2T :: Opcode
FLDLG2 :: Opcode
FLDLN2 :: Opcode
FLDPI :: Opcode
FLDZ :: Opcode
FMUL :: Opcode
FMULP :: Opcode
FNOP :: Opcode
FNINIT :: Opcode
FNSTCW :: Opcode
FPREM1 :: Opcode
FRSTOR :: Opcode
FSAVE :: Opcode
FSIN :: Opcode
FSINCOS :: Opcode
FSCALE :: Opcode
FSQRT :: Opcode
FST :: Opcode
FSTCW :: Opcode
FSTENV :: Opcode
FSTP :: Opcode
FSTSW :: Opcode
FSUB :: Opcode
FSUBP :: Opcode
FSUBR :: Opcode
FSUBRP :: Opcode
FTST :: Opcode
FUCOM :: Opcode
FUCOMI :: Opcode
FUCOMIP :: Opcode
FUCOMP :: Opcode
FUCOMPI :: Opcode
FUCOMPP :: Opcode
FXAM :: Opcode
FXCH :: Opcode
FXRSTOR :: Opcode
FXSAVE :: Opcode
FXTRACT :: Opcode
HADDPD :: Opcode
HADDPS :: Opcode
HLT :: Opcode
HSUBPD :: Opcode
HSUBPS :: Opcode
IDIV :: Opcode
IMUL :: Opcode
BSWAP :: Opcode
IN :: Opcode
INC :: Opcode
INS :: Opcode
INSD :: Opcode
INT :: Opcode
INT3 :: Opcode
INTO :: Opcode
INVD :: Opcode
INVLPG :: Opcode
INVPCID :: Opcode
IRET :: Opcode
IRETD :: Opcode
IRETQ :: Opcode
JA :: Opcode
JAE :: Opcode
JB :: Opcode
JBE :: Opcode
JC :: Opcode
JCXZ :: Opcode
JE :: Opcode
JECXZ :: Opcode
JG :: Opcode
JGE :: Opcode
JL :: Opcode
JLE :: Opcode
JMP :: Opcode
JMPF :: Opcode
JMPN :: Opcode
JNAE :: Opcode
JNA :: Opcode
JNB :: Opcode
JNBE :: Opcode
JNC :: Opcode
JNG :: Opcode
JNE :: Opcode
JNGE :: Opcode
JNLE :: Opcode
JNL :: Opcode
JNO :: Opcode
JNP :: Opcode
JNS :: Opcode
JNZ :: Opcode
JO :: Opcode
JP :: Opcode
JPE :: Opcode
JPO :: Opcode
JRCXZ :: Opcode
JS :: Opcode
JZ :: Opcode
LAHF :: Opcode
LAR :: Opcode
LDDQU :: Opcode
LDMXCSR :: Opcode
LDS :: Opcode
LEA :: Opcode
LEAVE :: Opcode
LES :: Opcode
LFENCE :: Opcode
LFS :: Opcode
LGDT :: Opcode
LGS :: Opcode
LIDT :: Opcode
LLDT :: Opcode
LMSW :: Opcode
LODS :: Opcode
LODSB :: Opcode
LODSD :: Opcode
LODSW :: Opcode
LOOP :: Opcode
LOOPE :: Opcode
LOOPNE :: Opcode
LSL :: Opcode
LSS :: Opcode
LTR :: Opcode
MASKMOVQ :: Opcode
MAXPD :: Opcode
MAXPS :: Opcode
MAXSD :: Opcode
MAXSS :: Opcode
MFENCE :: Opcode
MINPD :: Opcode
MINPS :: Opcode
MINSD :: Opcode
MINSS :: Opcode
MONITOR :: Opcode
MOV :: Opcode
MOVABS :: Opcode
MOVAPD :: Opcode
MOVAPS :: Opcode
MOVD :: Opcode
MOVDDUP :: Opcode
MOVDQA :: Opcode
MOVDQU :: Opcode
MOVHPD :: Opcode
MOVHPS :: Opcode
MOVLHPS :: Opcode
MOVLPD :: Opcode
MOVLPS :: Opcode
MOVLSDUP :: Opcode
MOVMSKPD :: Opcode
MOVMSKPS :: Opcode
MOVNTDQ :: Opcode
MOVNTPD :: Opcode
MOVNTPS :: Opcode
MOVNTQ :: Opcode
MOVQ :: Opcode
MOVS :: Opcode
MOVSD :: Opcode
MOVSLDUP :: Opcode
MOVSS :: Opcode
MOVSQ :: Opcode
MOVSX :: Opcode
MOVSXB :: Opcode
MOVSXD :: Opcode
MOVSXW :: Opcode
MOVUPD :: Opcode
MOVUPS :: Opcode
MOVZX :: Opcode
MOVZXB :: Opcode
MOVZXW :: Opcode
MUL :: Opcode
MULPD :: Opcode
MULPS :: Opcode
MULSD :: Opcode
MULSS :: Opcode
MWAIT :: Opcode
NEG :: Opcode
NOP :: Opcode
NOT :: Opcode
OR :: Opcode
ORPD :: Opcode
ORPS :: Opcode
OUT :: Opcode
OUTS :: Opcode
PACKSSDW :: Opcode
PACKSSWB :: Opcode
PADDB :: Opcode
PADDD :: Opcode
PADDQ :: Opcode
PADDSB :: Opcode
PADDSW :: Opcode
PADDUSB :: Opcode
PADDUSW :: Opcode
PADDW :: Opcode
PAND :: Opcode
PANDN :: Opcode
PAUSE :: Opcode
PAVGB :: Opcode
PAVGW :: Opcode
PCLMULQDQ :: Opcode
PCMPEQB :: Opcode
PCMPEQD :: Opcode
PCMPGTB :: Opcode
PCMPGTD :: Opcode
PEXTRB :: Opcode
PEXTRD :: Opcode
PEXTRQ :: Opcode
PINSRD :: Opcode
PINSRQ :: Opcode
PMADDWD :: Opcode
PMAXSW :: Opcode
PMAXUB :: Opcode
PMAXUD :: Opcode
PMAXUQ :: Opcode
PMINSD :: Opcode
PMINSW :: Opcode
PMINUB :: Opcode
PMINUD :: Opcode
PMOVMSKB :: Opcode
PMOVSXDQ :: Opcode
PMOVZXDQ :: Opcode
PMOVSXBD :: Opcode
PMOVZXBD :: Opcode
PMULLD :: Opcode
PMULLQ :: Opcode
PMULHUW :: Opcode
PMULHW :: Opcode
PMULLW :: Opcode
PMULUDQ :: Opcode
POP :: Opcode
POPA :: Opcode
POPAD :: Opcode
POPF :: Opcode
POPFD :: Opcode
POPFQ :: Opcode
POR :: Opcode
PREFETCHNTA :: Opcode
PREFETCHT0 :: Opcode
PREFETCHT1 :: Opcode
PREFETCHT2 :: Opcode
PSADBW :: Opcode
PSHUFB :: Opcode
PSHUFD :: Opcode
PSHUFLW :: Opcode
PSLLD :: Opcode
PSLLDQ :: Opcode
PSLLQ :: Opcode
PSLLW :: Opcode
PSRAD :: Opcode
PSRAW :: Opcode
PSRLD :: Opcode
PSRLDQ :: Opcode
PSRLQ :: Opcode
PSRLW :: Opcode
PSUBB :: Opcode
PSUBD :: Opcode
PSUBQ :: Opcode
PSUBSB :: Opcode
PSUBSQ :: Opcode
PSUBUSB :: Opcode
PSUBUSW :: Opcode
PSUBW :: Opcode
PTEST :: Opcode
PUNPCKLBW :: Opcode
PUNPCKLWD :: Opcode
PUNPCKLDQ :: Opcode
PUNPCKLQDQ :: Opcode
PUSH :: Opcode
PUSHA :: Opcode
PUSHAD :: Opcode
PUSHF :: Opcode
PUSHFD :: Opcode
PUSHFQ :: Opcode
PXOR :: Opcode
RCL :: Opcode
RCPPS :: Opcode
RCPSS :: Opcode
RCR :: Opcode
RDMSR :: Opcode
RDPMC :: Opcode
RDTSC :: Opcode
RET :: Opcode
RETF :: Opcode
RETN :: Opcode
ROL :: Opcode
ROR :: Opcode
ROUNDSD :: Opcode
ROUNDSS :: Opcode
RSM :: Opcode
RSQRTPS :: Opcode
RSQRTSS :: Opcode
SAHF :: Opcode
SAL :: Opcode
SAR :: Opcode
SBB :: Opcode
SCAS :: Opcode
SCASB :: Opcode
SCASD :: Opcode
SETA :: Opcode
SETAE :: Opcode
SETB :: Opcode
SETBE :: Opcode
SETC :: Opcode
SETE :: Opcode
SETG :: Opcode
SETGE :: Opcode
SETL :: Opcode
SETLE :: Opcode
SETNA :: Opcode
SETNAE :: Opcode
SETNB :: Opcode
SETNBE :: Opcode
SETNC :: Opcode
SETNE :: Opcode
SETNG :: Opcode
SETNGE :: Opcode
SETNL :: Opcode
SETNLE :: Opcode
SETNO :: Opcode
SETNP :: Opcode
SETNS :: Opcode
SETNZ :: Opcode
SETO :: Opcode
SETP :: Opcode
SETPE :: Opcode
SETPO :: Opcode
SETS :: Opcode
SETZ :: Opcode
SFENCE :: Opcode
SGDT :: Opcode
SHL :: Opcode
SHLD :: Opcode
SHR :: Opcode
SHRD :: Opcode
SIDT :: Opcode
SLDT :: Opcode
SMSW :: Opcode
SQRTPD :: Opcode
SQRTPS :: Opcode
SQRTSD :: Opcode
SQRTSS :: Opcode
STC :: Opcode
STD :: Opcode
STI :: Opcode
STMXCSR :: Opcode
STOS :: Opcode
STOSD :: Opcode
STR :: Opcode
SUB :: Opcode
SUBPD :: Opcode
SUBPS :: Opcode
SUBSD :: Opcode
SUBSS :: Opcode
SWAPGS :: Opcode
SYSCALL :: Opcode
SYSENTER :: Opcode
SYSEXIT :: Opcode
SYSRET :: Opcode
TEST :: Opcode
UCOMISD :: Opcode
UCOMISS :: Opcode
UD2 :: Opcode
UNPCKHPD :: Opcode
UNPCKHPS :: Opcode
UNPCKLPD :: Opcode
UNPCKLPS :: Opcode
VERR :: Opcode
VERW :: Opcode
VMCALL :: Opcode
VMCLEAR :: Opcode
VMLAUNCH :: Opcode
VMPTRLD :: Opcode
VMPTRST :: Opcode
VMREAD :: Opcode
VMRESUME :: Opcode
VMWRITE :: Opcode
VMXOFF :: Opcode
VMXON :: Opcode
WAIT :: Opcode
WBINVD :: Opcode
WRFSBASE :: Opcode
WRGSBASE :: Opcode
WRMSR :: Opcode
XADD :: Opcode
XCHG :: Opcode
XLAT :: Opcode
XLATB :: Opcode
XSETBV :: Opcode
XSAVEOPT :: Opcode
XRSTOR :: Opcode
XOR :: Opcode
XORPD :: Opcode
XORPS :: Opcode
show_address' :: Address -> [Char]
show_address :: Address -> [Char]
show_size_directive :: (Eq a, Num a, Show a) => a -> [Char]
show_operand' :: Operand -> [Char]
show_operand :: Show a => Maybe a -> [Char]
show_operand2 :: Show a => Maybe a -> [Char]
show_annot :: Maybe [Char] -> [Char]
show_prefix :: Show a => Maybe a -> [Char]
show_instruction :: Instr -> [Char]
operand_size :: Operand -> Int
is_cond_jump :: Opcode -> Bool
is_halt :: Opcode -> Bool
is_jump :: Opcode -> Bool
is_call :: Opcode -> Bool
is_ret :: Opcode -> Bool
reg128 :: [Register]
reg80 :: [Register]
reg64 :: [Register]
reg32 :: [Register]
reg16 :: [Register]
reg8 :: [Register]
reg_size :: Num p => Register -> p
real_reg :: Register -> Register
instance GHC.Generics.Generic X86_Datastructures.Prefix
instance GHC.Read.Read X86_Datastructures.Prefix
instance GHC.Classes.Ord X86_Datastructures.Prefix
instance GHC.Classes.Eq X86_Datastructures.Prefix
instance GHC.Show.Show X86_Datastructures.Prefix
instance GHC.Generics.Generic X86_Datastructures.Register
instance GHC.Classes.Ord X86_Datastructures.Register
instance GHC.Read.Read X86_Datastructures.Register
instance GHC.Classes.Eq X86_Datastructures.Register
instance GHC.Show.Show X86_Datastructures.Register
instance GHC.Classes.Ord X86_Datastructures.Flag
instance GHC.Classes.Eq X86_Datastructures.Flag
instance GHC.Show.Show X86_Datastructures.Flag
instance GHC.Generics.Generic X86_Datastructures.Address
instance GHC.Classes.Ord X86_Datastructures.Address
instance GHC.Classes.Eq X86_Datastructures.Address
instance GHC.Generics.Generic X86_Datastructures.Operand
instance GHC.Classes.Ord X86_Datastructures.Operand
instance GHC.Classes.Eq X86_Datastructures.Operand
instance GHC.Generics.Generic X86_Datastructures.Opcode
instance GHC.Classes.Ord X86_Datastructures.Opcode
instance GHC.Read.Read X86_Datastructures.Opcode
instance GHC.Classes.Eq X86_Datastructures.Opcode
instance GHC.Show.Show X86_Datastructures.Opcode
instance GHC.Generics.Generic X86_Datastructures.Instr
instance GHC.Classes.Ord X86_Datastructures.Instr
instance GHC.Classes.Eq X86_Datastructures.Instr
instance Data.Serialize.Serialize X86_Datastructures.Instr
instance GHC.Show.Show X86_Datastructures.Instr
instance Data.Serialize.Serialize X86_Datastructures.Opcode
instance Data.Serialize.Serialize X86_Datastructures.Operand
instance GHC.Show.Show X86_Datastructures.Operand
instance Data.Serialize.Serialize X86_Datastructures.Address
instance GHC.Show.Show X86_Datastructures.Address
instance Data.Serialize.Serialize X86_Datastructures.Register
instance Data.Serialize.Serialize X86_Datastructures.Prefix

module SimplePred
data BotTyp
FromAbstraction :: BotTyp
FromBitMode :: BotTyp
FromOverlap :: BotTyp
FromCall :: BotTyp
FromSemantics :: BotTyp
FromUninitializedMemory :: BotTyp
FromMemWrite :: BotTyp
FromNonDeterminism :: Set SimpleExpr -> BotTyp
data AddrType
Heap :: AddrType
Global :: AddrType
Local :: AddrType
data BotSrc
Src_SP :: StatePart -> BotSrc
Src_Function :: String -> BotSrc
data Operator
Plus :: Int -> Operator
Minus :: Int -> Operator
Times :: Int -> Operator
And :: Int -> Operator
Or :: Int -> Operator
Xor :: Int -> Operator
Not :: Int -> Operator
SetXX :: Operator
Bsr :: Int -> Operator
Div_Rem :: Int -> Operator
Div :: Int -> Operator
Shl :: Int -> Operator
Shr :: Int -> Operator
Sar :: Int -> Operator
Udiv :: Int -> Operator
Ror :: Int -> Operator
Rol :: Int -> Operator
Bswap :: Int -> Operator
Pextr :: Int -> Operator
data SimpleExpr
Bottom :: BotTyp -> Set BotSrc -> SimpleExpr
SE_Var :: StatePart -> SimpleExpr
SE_Immediate :: Word64 -> SimpleExpr
SE_StatePart :: StatePart -> SimpleExpr
SE_Op :: Operator -> [SimpleExpr] -> SimpleExpr
SE_Bit :: Int -> SimpleExpr -> SimpleExpr
SE_SExtend :: Int -> Int -> SimpleExpr -> SimpleExpr
SE_Overwrite :: Int -> SimpleExpr -> SimpleExpr -> SimpleExpr
data StatePart
SP_Reg :: Register -> StatePart
SP_Mem :: SimpleExpr -> Int -> StatePart
expr_size :: (Num a, Ord a) => SimpleExpr -> a
expr_size_sp :: (Num a, Ord a) => StatePart -> a
expr_size_src :: (Num a, Ord a) => BotSrc -> a
contains_bot :: SimpleExpr -> Bool
contains_bot_sp :: StatePart -> Bool
regs_of :: SimpleExpr -> Set Register
regs_of_sp :: StatePart -> Set Register
is_imm_expr :: SimpleExpr -> Bool
all_bot_satisfy :: (BotTyp -> Set BotSrc -> Bool) -> SimpleExpr -> Bool
all_bot_satisfy_sp :: (BotTyp -> Set BotSrc -> Bool) -> StatePart -> Bool
srcs_of_expr :: SimpleExpr -> Set BotSrc
srcs_of_sp :: StatePart -> Set BotSrc
srcs_of_exprs :: SimpleExpr -> SimpleExpr -> Set BotSrc
srcs_of_expr_bounded :: SimpleExpr -> Set BotSrc
trim_expr :: SimpleExpr -> SimpleExpr
sextend_32_64 :: (Bits p, Num p) => p -> p
sextend_16_64 :: (Bits p, Num p) => p -> p
sextend_8_64 :: (Bits p, Num p) => p -> p
simp :: SimpleExpr -> SimpleExpr
simp_sp :: StatePart -> StatePart
data FlagStatus
None :: FlagStatus
FS_CMP :: Maybe Bool -> Operand -> Operand -> FlagStatus
data VerificationCondition
Precondition :: SimpleExpr -> Int -> SimpleExpr -> Int -> VerificationCondition
Assertion :: SimpleExpr -> SimpleExpr -> Int -> SimpleExpr -> Int -> VerificationCondition
FunctionConstraint :: String -> [(Register, SimpleExpr)] -> VerificationCondition
is_assertion :: VerificationCondition -> Bool
is_precondition :: VerificationCondition -> Bool
is_func_constraint :: VerificationCondition -> Bool
count_instructions_with_assertions :: Set VerificationCondition -> Int
data StateMuddleStatus
Clean :: StateMuddleStatus
ExternalOnly :: StateMuddleStatus
Muddled :: StateMuddleStatus
data Pred
Predicate :: Map StatePart SimpleExpr -> FlagStatus -> Set VerificationCondition -> StateMuddleStatus -> Pred
add_precondition :: SimpleExpr -> Int -> SimpleExpr -> Int -> Pred -> Pred
add_assertion :: SimpleExpr -> SimpleExpr -> Int -> SimpleExpr -> Int -> Pred -> Pred
add_function_constraint :: String -> [(Register, SimpleExpr)] -> Pred -> Pred
instance GHC.Generics.Generic SimplePred.AddrType
instance GHC.Classes.Ord SimplePred.AddrType
instance GHC.Classes.Eq SimplePred.AddrType
instance GHC.Generics.Generic SimplePred.Operator
instance GHC.Classes.Ord SimplePred.Operator
instance GHC.Classes.Eq SimplePred.Operator
instance GHC.Generics.Generic SimplePred.BotTyp
instance GHC.Classes.Ord SimplePred.BotTyp
instance GHC.Classes.Eq SimplePred.BotTyp
instance GHC.Generics.Generic SimplePred.BotSrc
instance GHC.Classes.Ord SimplePred.BotSrc
instance GHC.Classes.Eq SimplePred.BotSrc
instance GHC.Generics.Generic SimplePred.SimpleExpr
instance GHC.Classes.Ord SimplePred.SimpleExpr
instance GHC.Classes.Eq SimplePred.SimpleExpr
instance GHC.Generics.Generic SimplePred.StatePart
instance GHC.Classes.Ord SimplePred.StatePart
instance GHC.Classes.Eq SimplePred.StatePart
instance GHC.Classes.Ord SimplePred.FlagStatus
instance GHC.Classes.Eq SimplePred.FlagStatus
instance GHC.Generics.Generic SimplePred.FlagStatus
instance GHC.Classes.Ord SimplePred.VerificationCondition
instance GHC.Classes.Eq SimplePred.VerificationCondition
instance GHC.Generics.Generic SimplePred.VerificationCondition
instance GHC.Classes.Ord SimplePred.StateMuddleStatus
instance GHC.Show.Show SimplePred.StateMuddleStatus
instance GHC.Classes.Eq SimplePred.StateMuddleStatus
instance GHC.Generics.Generic SimplePred.StateMuddleStatus
instance GHC.Classes.Ord SimplePred.Pred
instance GHC.Classes.Eq SimplePred.Pred
instance GHC.Generics.Generic SimplePred.Pred
instance Data.Serialize.Serialize SimplePred.Pred
instance GHC.Show.Show SimplePred.Pred
instance Data.Serialize.Serialize SimplePred.StateMuddleStatus
instance GHC.Show.Show SimplePred.VerificationCondition
instance Data.Serialize.Serialize SimplePred.VerificationCondition
instance Data.Serialize.Serialize SimplePred.FlagStatus
instance GHC.Show.Show SimplePred.FlagStatus
instance GHC.Show.Show SimplePred.BotTyp
instance GHC.Show.Show SimplePred.BotSrc
instance GHC.Show.Show SimplePred.SimpleExpr
instance GHC.Show.Show SimplePred.StatePart
instance Data.Serialize.Serialize SimplePred.BotTyp
instance Data.Serialize.Serialize SimplePred.BotSrc
instance Data.Serialize.Serialize SimplePred.StatePart
instance Data.Serialize.Serialize SimplePred.SimpleExpr
instance GHC.Show.Show SimplePred.Operator
instance Data.Serialize.Serialize SimplePred.Operator
instance GHC.Show.Show SimplePred.AddrType
instance Data.Serialize.Serialize SimplePred.AddrType

module ParserX86Instruction
jumps_and_calls_are_relative :: Bool
isWhiteSpace :: Char -> Bool
whitespace :: ParsecT [Char] u Identity Char
whitespaces :: ParsecT [Char] u Identity ()
hexToWord64 :: [Char] -> Word64
parseMnemonic :: [Char] -> Opcode
mnemonic :: GenParser Char st Opcode
parseRegister :: [Char] -> Register
isRegisterChar :: Char -> Bool
register :: GenParser Char st Register
parsePrefix :: [Char] -> Prefix
prefix :: GenParser Char st Prefix
address_term :: ParsecT [Char] u Identity Address
size_directive :: ParsecT [Char] u Identity Int
addr_expr0 :: ParsecT [Char] u Identity Address
addr_expr1 :: ParsecT [Char] u Identity Address
address_expr_inner :: ParsecT [Char] u Identity Address
op_address :: ParsecT [Char] u Identity Operand
op_reg :: ParsecT [Char] st Identity Operand
op_immediate :: GenParser Char st Operand
op_immediate_0x :: GenParser Char st Operand
operand :: ParsecT [Char] u Identity Operand
second_operand :: ParsecT [Char] u Identity Operand
hexnum_with_0x :: ParsecT [Char] u Identity Integer
instruction :: ParsecT [Char] u Identity Instr

module DisassembleCapstone
disasm_config :: Integral a => [Word8] -> a -> Disassembler ()
mk_operands :: Show a => a -> [Char] -> [Maybe Operand]
trim :: [Char] -> [Char]
mk_instr :: CsInsn -> Instr
disassemble :: IntMap Word8 -> Int -> IO (Maybe Instr)

module Conventions
exiting_functon_calls :: [[Char]]
sections_modifiable_by_external_functions :: [([Char], [Char])]
section_is_unwritable :: ([Char], [Char]) -> Bool
callee_saved_registers :: [Register]
return_registers :: [Register]
parameter_registers :: [Register]
max_jump_table_size :: Integer


-- | A <tt><a>Context</a></tt> stores all the information retrieved from
--   the binary, as well as the command-line parameters passed to FoxDec.
--   Moreover, it stores information obtained during verification, such as
--   CFGs, invariants, etc. (see <tt><a>Context</a></tt>).
--   
--   Module <a>VerificationReportInterface</a> provides functions for
--   obtaining and interfacing with a <tt>Context</tt>.
module Context

-- | A control flow graph with blocks and edges. A blockID (represented as
--   an <tt>Int</tt>) is a unique identifier of a basic block. We store
--   basic blocks twice: once as addresses, and once as instructions.
data CFG
CFG :: IntMap [Int] -> IntMap IntSet -> IntMap Int -> Int -> IntMap [Instr] -> CFG

-- | A mapping of blockIDs to instruction addresses
[cfg_blocks] :: CFG -> IntMap [Int]

-- | A mapping of blockIDs to sets of blocKIDs
[cfg_edges] :: CFG -> IntMap IntSet

-- | A mapping of instruction addresses to blockIDs
[cfg_addr_to_blockID] :: CFG -> IntMap Int

-- | A fresh blockID
[cfg_fresh] :: CFG -> Int

-- | A mapping of blockIDs to lists of disassembled instructions.
[cfg_instrs] :: CFG -> IntMap [Instr]

-- | Per instruction address, a set of jump targets.
type Indirections = IntMap IntSet

-- | Sections: segment names, section names, addresses and sizes.
type SectionsInfo = [(String, String, Int, Int)]

-- | An enumeration indicating the result of verification over a function
data VerificationResult

-- | Function was succesfully verified
VerificationSuccess :: VerificationResult

-- | Function was succesfully verified, but required assertions
VerificationSuccesWithAssertions :: VerificationResult

-- | Function contains an unresolved indirection
VerificationUnresolvedIndirection :: VerificationResult

-- | There was some verification error, e.g., return adresss overwrite
VerificationError :: VerificationResult

-- | The function has not been verified.
Unverified :: VerificationResult

-- | Invariants: a mapping of blockIDs to predicates
type Invariants = IntMap Pred

-- | For each leaf-node in a CFG we store the following info.
data NodeInfo

-- | The basic block behaves normally, e.g., a ret
Normal :: NodeInfo

-- | The basic block ends in an unresolved indirection
UnresolvedIndirection :: NodeInfo

-- | The basic blocks ends with, e.g., a call to exit()
Terminal :: NodeInfo

-- | Per function, we report on:
data Report
Report :: CFG -> Invariants -> Set (NodeInfo, Pred) -> VerificationResult -> Set VerificationCondition -> Report

-- | The control flow graph
[report_cfg] :: Report -> CFG

-- | The invariants
[report_invs] :: Report -> Invariants

-- | The postcondition(s)
[report_posts] :: Report -> Set (NodeInfo, Pred)

-- | The verification result
[report_result] :: Report -> VerificationResult

-- | The verification conditions
[report_vcs] :: Report -> Set VerificationCondition

-- | The context datastructure.
--   
--   <b>S</b>: Information <b>S</b>tatically obtained by reading from the
--   binary
--   
--   <b>D</b>: Information <b>D</b>ynamically updated during verification
data Context
Context :: IntMap Word8 -> IntMap String -> IntMap Bool -> Graph -> SectionsInfo -> String -> String -> Bool -> Indirections -> IntMap Report -> Context

-- | <b>S</b>: mapping from addresses to bytes (data and instructions from
--   the binary/executable)
[ctxt_dump] :: Context -> IntMap Word8

-- | <b>S</b>: the symbol table: a mapping of addresses to function names
--   for external functions
[ctxt_syms] :: Context -> IntMap String

-- | <b>D</b>: the currently known and verified entry addresses of
--   functions (true iff always terminating, i.e., non-returning)
[ctxt_calls] :: Context -> IntMap Bool

-- | <b>D</b>: a graph with an edge (e0,e1) if entry address e0 calls entry
--   address e1, and e0 and e1 have not been verified yet
[ctxt_entries] :: Context -> Graph

-- | <b>S</b>: information on segments/section
[ctxt_sections] :: Context -> SectionsInfo

-- | <b>S</b>: the name of the directory where the .dump, .entry, .sections
--   and .symbols files reside
[ctxt_dirname] :: Context -> String

-- | <b>S</b>: the name of the binary
[ctxt_name] :: Context -> String

-- | <b>S</b>: do we call graphviz to generate PDFs from .dot files?
[ctxt_generate_pdfs] :: Context -> Bool

-- | <b>D</b>: the currently known indirections
[ctxt_inds] :: Context -> Indirections

-- | <b>D</b>: a mapping from function entries to reports storing
--   verification results
[ctxt_report] :: Context -> IntMap Report

-- | Reading from a data section.
--   
--   Reads maximally up to 8 bytes. Returns <tt>Nothing</tt> if the given
--   address is out-of-range.
read_from_datasection :: Context -> Word64 -> Int -> Maybe Word64

-- | Find a section for an address (see <tt><a>SectionsInfo</a></tt>)
find_section_for_address :: Context -> Int -> Maybe (String, String, Int, Int)

-- | Fetching an instruction
--   
--   Returns <tt>Nothing</tt> if the given address is out-of-range.
fetch_instruction :: Context -> Int -> IO (Maybe Instr)

-- | Pretty printing an instruction
pp_instruction :: Context -> Instr -> String
instance GHC.Generics.Generic Context.CFG
instance GHC.Show.Show Context.CFG
instance GHC.Generics.Generic Context.VerificationResult
instance GHC.Classes.Eq Context.VerificationResult
instance GHC.Show.Show Context.VerificationResult
instance GHC.Classes.Ord Context.NodeInfo
instance GHC.Classes.Eq Context.NodeInfo
instance GHC.Generics.Generic Context.NodeInfo
instance GHC.Show.Show Context.NodeInfo
instance GHC.Generics.Generic Context.Report
instance GHC.Generics.Generic Context.Context
instance Data.Serialize.Serialize Context.Context
instance Data.Serialize.Serialize Context.Report
instance Data.Serialize.Serialize Context.NodeInfo
instance Data.Serialize.Serialize Context.VerificationResult
instance Data.Serialize.Serialize Context.CFG

module Propagation
class (Show pred) => Propagator ctxt pred
tau :: Propagator ctxt pred => ctxt -> CFG -> Int -> Maybe Int -> pred -> pred
join :: Propagator ctxt pred => ctxt -> pred -> pred -> pred
implies :: Propagator ctxt pred => ctxt -> pred -> pred -> Bool
supremum :: Propagator ctxt pred => ctxt -> [pred] -> pred
post :: CFG -> Key -> IntSet
out_edges :: CFG -> Int -> Set (Int, Key)
pick_edge_from_bag :: State (IntMap pred, Set (Int, Int)) (Maybe ((Int, Int), Set (Int, Int)))
prop :: Propagator ctxt pred => ctxt -> CFG -> State (IntMap pred, Set (Int, Int)) ()
do_prop :: Propagator ctxt pred => ctxt -> CFG -> Int -> pred -> IntMap pred

module MachineState
is_global_expr :: Context -> SimpleExpr -> Bool
expr_to_addr_type :: Context -> SimpleExpr -> Set AddrType
read_rreg :: Register -> State Pred SimpleExpr
read_reg :: Register -> State Pred SimpleExpr
write_rreg :: Register -> SimpleExpr -> State Pred ()
write_reg :: Register -> SimpleExpr -> State Pred ()
clean_flg :: StatePart -> FlagStatus -> FlagStatus
necessarily_enclosed :: Integral a => SimpleExpr -> a -> SimpleExpr -> a -> Bool
necessarily_separate :: (Ord a, Num a) => Context -> SimpleExpr -> a -> SimpleExpr -> a -> Bool
compare_srcs :: Context -> SimpleExpr -> SimpleExpr -> Bool
necessarily_equal :: SimpleExpr -> SimpleExpr -> Bool
necessarily_equal_stateparts :: StatePart -> StatePart -> Bool
resolve_address :: Address -> State Pred SimpleExpr
read_from_datasection_expr :: Context -> SimpleExpr -> Int -> Maybe SimpleExpr
generate_assertion :: Address -> State Pred SimpleExpr
get_section_of_address :: Context -> Int -> Maybe (String, String, Int, Int)
address_is_unwritable :: Context -> SimpleExpr -> Bool
address_is_unmodifiable_by_external_functions :: Context -> SimpleExpr -> Bool
is_return_value_of_call :: SimpleExpr -> Bool
is_preconditionable :: Context -> SimpleExpr -> SimpleExpr -> Bool
read_from_address :: Context -> Address -> SimpleExpr -> Int -> State Pred SimpleExpr
read_mem :: Context -> Address -> State Pred SimpleExpr
remove_region :: SimpleExpr -> Int -> State Pred ()
write_region :: SimpleExpr -> Int -> SimpleExpr -> State Pred ()
write_mem :: Context -> Address -> SimpleExpr -> Int -> SimpleExpr -> State Pred ()
read_operand :: Context -> Operand -> State Pred SimpleExpr
write_operand :: Context -> Operand -> SimpleExpr -> State Pred ()

module CFG_Gen
split_graph' :: Key -> CFG -> Maybe CFG
split_graph :: Key -> CFG -> Maybe CFG
add_edge_to_graph :: Key -> Key -> CFG -> Maybe CFG
add_to_intset :: Key -> Maybe IntSet -> Maybe IntSet
append_to_list :: a -> Maybe [a] -> Maybe [a]
add_edge :: Int -> Int -> CFG -> CFG
add_edges :: [(Int, Int)] -> CFG -> CFG
init_cfg :: Int -> CFG
is_consecutive :: Eq a => a -> a -> [a] -> Bool
is_edge :: CFG -> Int -> Int -> Bool
address_has_instruction :: Integral a => Context -> a -> Bool
address_has_symbol :: Integral a => Context -> a -> Bool
address_is_external :: Integral a => Context -> a -> Bool
data ResolvedJumpTarget
Unresolved :: ResolvedJumpTarget
External :: String -> ResolvedJumpTarget
ImmediateAddress :: Word64 -> ResolvedJumpTarget
operand_static_resolve :: Context -> Instr -> Maybe Operand -> ResolvedJumpTarget
static_resolve_rip_expr :: Integral a => Context -> Instr -> (Int -> a) -> Int -> ResolvedJumpTarget
resolve_jump_target :: Context -> Instr -> [ResolvedJumpTarget]
instruction_jumps_to_external :: Context -> Instr -> Bool
function_name_of_entry :: Context -> Int -> String
function_name_of_instruction :: Context -> Instr -> String
resolve_call :: Context -> Int -> Instr -> Either IntSet [Int]
stepA :: Context -> Int -> Int -> IO (Either IntSet [Int])
get_internal_addresses :: Num a => ResolvedJumpTarget -> [a]
mk_graph :: Context -> Int -> Set (Int, Int) -> CFG -> IntSet -> IO (IntSet, CFG)
fromJust' :: (Integral a, Show a) => [a] -> Maybe p -> p
cfg_add_instrs :: Context -> CFG -> IO CFG
cfg_gen :: Context -> Int -> IO (Either IntSet CFG)
is_end_node :: CFG -> Key -> Bool
is_unresolved_indirection :: Context -> Instr -> Bool
node_info_of :: Context -> CFG -> Key -> NodeInfo
fetch_block :: CFG -> Int -> [Instr]
show_block :: CFG -> Int -> String
show_invariants :: CFG -> Invariants -> String
cfg_to_dot :: Context -> CFG -> String
hex_color_of :: Key -> [IntSet] -> [Char]
instance GHC.Show.Show CFG_Gen.ResolvedJumpTarget
instance GHC.Classes.Eq CFG_Gen.ResolvedJumpTarget

module SymbolicExecution
push :: Context -> Operand -> State Pred ()
pop :: Context -> Operand -> State Pred ()
lea :: Context -> Operand -> Operand -> State Pred ()
leave :: Context -> State Pred ()
add_call_verification_conditions :: Context -> Instr -> State Pred ()
call :: Context -> Instr -> State Pred ()
statepart_after_function_call :: Context -> Instr -> StatePart -> SimpleExpr -> SimpleExpr
statepart_is_preserved_after_function_call :: Context -> Instr -> StatePart -> Bool
mk_bottom_after_function_call :: Context -> Instr -> Set BotSrc -> SimpleExpr
ret :: Context -> State Pred ()
sysret :: Context -> StateT Pred Identity ()
jmp :: Context -> Instr -> StateT Pred Identity ()
write_flags :: (Operand -> Operand -> FlagStatus) -> Operand -> Operand -> State Pred ()
mov_with_func_op2_to_op1 :: Context -> (SimpleExpr -> SimpleExpr) -> Operand -> Operand -> State Pred ()
mk_bottom :: [SimpleExpr] -> SimpleExpr
mov_with_func1 :: Context -> ([SimpleExpr] -> SimpleExpr) -> Bool -> Operand -> State Pred ()
mov_with_func :: Context -> ([SimpleExpr] -> SimpleExpr) -> Bool -> Operand -> Operand -> State Pred ()
mov_with_func3 :: Context -> ([SimpleExpr] -> SimpleExpr) -> Bool -> Operand -> Operand -> Operand -> State Pred ()
nop :: Monad m => p -> m ()
ud2 :: Monad m => p -> m ()
hlt :: Monad m => p -> m ()
wait :: Monad m => p -> m ()
mfence :: Monad m => p -> m ()
clflush :: Monad m => p -> m ()
mov :: Context -> Operand -> Operand -> State Pred ()
movzx :: Context -> Operand -> Operand -> StateT Pred Identity ()
movsx :: Context -> Operand -> Operand -> StateT Pred Identity ()
movsxd :: Context -> Operand -> Operand -> StateT Pred Identity ()
movsd :: Context -> Operand -> Operand -> State Pred ()
movss :: Context -> Operand -> Operand -> State Pred ()
movaps :: Context -> Operand -> Operand -> State Pred ()
movapd :: Context -> Operand -> Operand -> State Pred ()
movups :: Context -> Operand -> Operand -> State Pred ()
movupd :: Context -> Operand -> Operand -> State Pred ()
movabs :: Context -> Operand -> Operand -> State Pred ()
movdqu :: Context -> Operand -> Operand -> State Pred ()
movdqa :: Context -> Operand -> Operand -> State Pred ()
movlpd :: Context -> Operand -> Operand -> State Pred ()
movlps :: Context -> Operand -> Operand -> State Pred ()
movd :: Context -> Operand -> Operand -> State Pred ()
movq :: Context -> Operand -> Operand -> State Pred ()
cmov :: Context -> Operand -> Operand -> StateT Pred Identity ()
xchg :: Context -> Operand -> Operand -> State Pred ()
cmp :: p -> Operand -> Operand -> State Pred ()
add :: Context -> Operand -> Operand -> State Pred ()
sub :: Context -> Operand -> Operand -> State Pred ()
neg :: Context -> Operand -> State Pred ()
test :: p -> Operand -> Operand -> State Pred ()
ucomisd :: p -> Operand -> Operand -> State Pred ()
ucomiss :: p -> Operand -> Operand -> State Pred ()
inc :: Context -> Operand -> State Pred ()
dec :: Context -> Operand -> State Pred ()
or' :: Context -> Operand -> Operand -> State Pred ()
and' :: Context -> Operand -> Operand -> State Pred ()
not' :: Context -> Operand -> State Pred ()
xor :: Context -> Operand -> Operand -> State Pred ()
setxx :: Context -> Operand -> State Pred ()
pxor :: Context -> Operand -> Operand -> State Pred ()
pand :: Context -> Operand -> Operand -> State Pred ()
pandn :: Context -> Operand -> Operand -> State Pred ()
por :: Context -> Operand -> Operand -> State Pred ()
ptest :: Context -> Operand -> Operand -> State Pred ()
xorpd :: Context -> Operand -> Operand -> State Pred ()
xorps :: Context -> Operand -> Operand -> State Pred ()
andpd :: Context -> Operand -> Operand -> State Pred ()
andnpd :: Context -> Operand -> Operand -> State Pred ()
orpd :: Context -> Operand -> Operand -> State Pred ()
subpd :: Context -> Operand -> Operand -> State Pred ()
addpd :: Context -> Operand -> Operand -> State Pred ()
subss :: Context -> Operand -> Operand -> State Pred ()
addss :: Context -> Operand -> Operand -> State Pred ()
mulss :: Context -> Operand -> Operand -> State Pred ()
divss :: Context -> Operand -> Operand -> State Pred ()
roundss :: Context -> Operand -> Operand -> State Pred ()
subsd :: Context -> Operand -> Operand -> State Pred ()
addsd :: Context -> Operand -> Operand -> State Pred ()
mulsd :: Context -> Operand -> Operand -> State Pred ()
divsd :: Context -> Operand -> Operand -> State Pred ()
roundsd :: Context -> Operand -> Operand -> State Pred ()
bt :: Context -> Operand -> Operand -> State Pred ()
btc :: Context -> Operand -> Operand -> State Pred ()
btr :: Context -> Operand -> Operand -> State Pred ()
bsr :: Context -> Operand -> Operand -> StateT Pred Identity ()
bsf :: Context -> Operand -> Operand -> State Pred ()
bts :: Context -> Operand -> Operand -> State Pred ()
paddd :: Context -> Operand -> Operand -> State Pred ()
paddb :: Context -> Operand -> Operand -> State Pred ()
paddq :: Context -> Operand -> Operand -> State Pred ()
psubd :: Context -> Operand -> Operand -> State Pred ()
psubb :: Context -> Operand -> Operand -> State Pred ()
psubq :: Context -> Operand -> Operand -> State Pred ()
psrld :: Context -> Operand -> Operand -> State Pred ()
psrlw :: Context -> Operand -> Operand -> State Pred ()
psrldq :: Context -> Operand -> Operand -> State Pred ()
pslldq :: Context -> Operand -> Operand -> State Pred ()
psllq :: Context -> Operand -> Operand -> State Pred ()
psrlq :: Context -> Operand -> Operand -> State Pred ()
pmulld :: Context -> Operand -> Operand -> State Pred ()
pminud :: Context -> Operand -> Operand -> State Pred ()
pminsd :: Context -> Operand -> Operand -> State Pred ()
pmaxud :: Context -> Operand -> Operand -> State Pred ()
pmaxuq :: Context -> Operand -> Operand -> State Pred ()
psubusb :: Context -> Operand -> Operand -> State Pred ()
psubusw :: Context -> Operand -> Operand -> State Pred ()
packssdw :: Context -> Operand -> Operand -> State Pred ()
packsswb :: Context -> Operand -> Operand -> State Pred ()
cvtss2sd :: Context -> Operand -> Operand -> State Pred ()
cvtsd2ss :: Context -> Operand -> Operand -> State Pred ()
cvtsi2sd :: Context -> Operand -> Operand -> State Pred ()
cvtsi2ss :: Context -> Operand -> Operand -> State Pred ()
cvttss2si :: Context -> Operand -> Operand -> State Pred ()
cvttsd2si :: Context -> Operand -> Operand -> State Pred ()
cvttpd2dq :: Context -> Operand -> Operand -> State Pred ()
cvtdq2pd :: Context -> Operand -> Operand -> State Pred ()
is_st_reg_operand :: Operand -> Bool
fst' :: Context -> Operand -> StateT Pred Identity ()
fstp :: Context -> Operand -> StateT Pred Identity ()
fld :: Monad m => p1 -> p2 -> m ()
fld1 :: Monad m => p -> m ()
fldz :: Monad m => p -> m ()
fild :: Context -> Operand -> State Pred ()
fxch :: Monad m => p -> m ()
fchs :: Monad m => p -> m ()
fucom :: Monad m => p -> m ()
fucomi :: Monad m => p -> m ()
fucomip :: Monad m => p -> m ()
fucomp :: Monad m => p -> m ()
fucompi :: Monad m => p -> m ()
fucompp :: Monad m => p -> m ()
finit :: Monad m => p -> m ()
fninit :: Monad m => p -> m ()
fnstcw :: Context -> Operand -> State Pred ()
fstcw :: Context -> Operand -> State Pred ()
fadd1 :: Monad m => p1 -> p2 -> m ()
fadd2 :: Monad m => p1 -> p2 -> p3 -> m ()
fmul1 :: Monad m => p1 -> p2 -> m ()
fmul2 :: Monad m => p1 -> p2 -> p3 -> m ()
fmulp1 :: Monad m => p1 -> p2 -> m ()
fmulp2 :: Monad m => p1 -> p2 -> p3 -> m ()
fdivr1 :: Monad m => p1 -> p2 -> m ()
fdivr2 :: Monad m => p1 -> p2 -> p3 -> m ()
fdivrp1 :: Monad m => p1 -> p2 -> m ()
fdivrp2 :: Monad m => p1 -> p2 -> p3 -> m ()
fisub :: Monad m => p1 -> p2 -> m ()
fcmovxx :: Monad m => p -> m ()
fisttp :: Context -> Operand -> State Pred ()
idiv :: Context -> Operand -> State Pred ()
div1 :: Context -> Operand -> State Pred ()
cdq :: Context -> State Pred ()
cqo :: Context -> State Pred ()
cdqe :: Context -> State Pred ()
cbw :: Context -> State Pred ()
cwde :: Context -> State Pred ()
shl :: Context -> Operand -> Operand -> State Pred ()
shr :: Context -> Operand -> Operand -> State Pred ()
sar :: Context -> Operand -> Operand -> StateT Pred Identity ()
shld :: Context -> Operand -> Operand -> Operand -> State Pred ()
shrd :: Context -> Operand -> Operand -> Operand -> State Pred ()
rol :: Context -> Operand -> Operand -> State Pred ()
ror :: Context -> Operand -> Operand -> State Pred ()
adc :: Context -> Operand -> Operand -> State Pred ()
sbb :: Context -> Operand -> Operand -> State Pred ()
mul1 :: Context -> Operand -> State Pred ()
mul2 :: Context -> Operand -> Operand -> State Pred ()
imul1 :: Context -> Operand -> State Pred ()
imul2 :: Context -> Operand -> Operand -> State Pred ()
imul3 :: Context -> Operand -> Operand -> Operand -> State Pred ()
bswap :: Context -> Operand -> State Pred ()
pextrb :: Context -> Operand -> Operand -> Operand -> State Pred ()
pextrd :: Context -> Operand -> Operand -> Operand -> State Pred ()
pextrq :: Context -> Operand -> Operand -> Operand -> State Pred ()
haddpd :: Context -> Operand -> Operand -> State Pred ()
pinsrq :: Context -> Operand -> Operand -> Operand -> State Pred ()
pinsrd :: Context -> Operand -> Operand -> Operand -> State Pred ()
pshufb :: Context -> Operand -> Operand -> State Pred ()
pshufd :: Context -> Operand -> Operand -> State Pred ()
pshuflw :: Context -> Operand -> Operand -> Operand -> State Pred ()
pclmulqdq :: Context -> Operand -> Operand -> Operand -> State Pred ()
pcmpeqb :: Context -> Operand -> Operand -> State Pred ()
pcmpeqd :: Context -> Operand -> Operand -> State Pred ()
pcmpgtb :: Context -> Operand -> Operand -> State Pred ()
pcmpgtd :: Context -> Operand -> Operand -> State Pred ()
movmskps :: Context -> Operand -> Operand -> State Pred ()
pmovsxdq :: Context -> Operand -> Operand -> State Pred ()
pmovzxdq :: Context -> Operand -> Operand -> State Pred ()
pmovsxbd :: Context -> Operand -> Operand -> State Pred ()
pmovzxbd :: Context -> Operand -> Operand -> State Pred ()
movmskpd :: Context -> Operand -> Operand -> State Pred ()
unpcklps :: Context -> Operand -> Operand -> State Pred ()
cmpltsd :: Context -> Operand -> Operand -> State Pred ()
cmpeqsd :: Context -> Operand -> Operand -> State Pred ()
cmpneqsd :: Context -> Operand -> Operand -> State Pred ()
punpcklqdq :: Context -> Operand -> Operand -> State Pred ()
punpckldq :: Context -> Operand -> Operand -> State Pred ()
punpcklbw :: Context -> Operand -> Operand -> State Pred ()
blendvps :: Context -> Operand -> Operand -> Operand -> State Pred ()
extractps :: Context -> Operand -> Operand -> Operand -> State Pred ()
movsd_string :: Monad m => p1 -> p2 -> p3 -> p4 -> m ()
movsq :: Monad m => p1 -> p2 -> p3 -> p4 -> m ()
x86_in :: Context -> Operand -> State Pred ()
x86_out :: Context -> Operand -> State Pred ()
cli :: Monad m => p -> m ()
clts :: Monad m => p -> m ()
cpuid :: Context -> State Pred ()
invpcid :: Monad m => p -> m ()
lgdt :: Monad m => p -> m ()
lidt :: Monad m => p -> m ()
lldt :: Monad m => p -> m ()
ltr :: Monad m => p -> m ()
rdmsr :: Context -> StateT Pred Identity ()
wrmsr :: Context -> StateT Pred Identity ()
rdtsc :: Context -> StateT Pred Identity ()
swapgs :: Context -> State Pred ()
xsetbv :: Monad m => p -> m ()
xsaveopt :: Monad m => p -> m ()
xrstor :: Monad m => p -> m ()
wrfsbase :: Context -> State Pred ()
wrgsbase :: Context -> State Pred ()
xadd :: Context -> Operand -> Operand -> State Pred ()
cmpxchg :: Context -> Operand -> Operand -> State Pred ()
tau_i :: Context -> Instr -> State Pred ()
tau_b :: Context -> [Instr] -> State Pred ()
add_jump_to_pred :: Instr -> Instr -> FlagStatus -> FlagStatus
tau_blockID :: Context -> CFG -> Int -> Maybe Int -> Pred -> Pred
tau_blockID' :: Context -> CFG -> Int -> Maybe Int -> Bool -> Pred -> Pred
expr_highly_likely_pointer :: Context -> SimpleExpr -> Bool
join_expr :: Context -> SimpleExpr -> SimpleExpr -> SimpleExpr
join_muddle_status :: StateMuddleStatus -> StateMuddleStatus -> StateMuddleStatus
join_preds :: Context -> Pred -> Pred -> Pred
is_initial :: StatePart -> SimpleExpr -> Bool
implies_preds :: Context -> Pred -> Pred -> Bool
init_pred :: Invariants -> Set (NodeInfo, Pred) -> Pred
get_stateparts_of_preds :: Set Pred -> Set StatePart
get_stateparts_of_pred :: Pred -> Set StatePart
gather_stateparts :: IntMap Pred -> Set (a, Pred) -> Set StatePart
instance Propagation.Propagator Context.Context SimplePred.Pred

module Isabelle
generate_isa_main_thy :: MonadIO m => [Char] -> FilePath -> [[Char]] -> m ()
generate_isa_thy :: (MonadState Context m, MonadIO m, Integral a1, Show a1) => [Char] -> a1 -> FilePath -> CFG -> IntMap Pred -> Set (a2, Pred) -> Set VerificationCondition -> m [Char]
isa_file_header :: [Char] -> [Char]
isa_file_end :: [Char]
block_to_hoare_triples :: (MonadIO m, Integral a, Show a, Foldable t, MonadState Context m) => p -> FilePath -> a -> Set VerificationCondition -> Set VerificationCondition -> IntMap Pred -> (Key, t Instr) -> m ()
instr_to_hoare_triple :: (MonadState Context m, MonadIO m) => p -> FilePath -> Set VerificationCondition -> Set VerificationCondition -> Pred -> Instr -> m Pred
mk_isa_separation :: (Show a1, Show a2) => SimpleExpr -> a1 -> SimpleExpr -> a2 -> [Char]
mk_isa_preconditions :: Set VerificationCondition -> [Char]
mk_isa_precondition :: VerificationCondition -> [Char]
mk_isa_asserts :: Instr -> Set VerificationCondition -> [Char]
mk_assertion :: VerificationCondition -> [Char]
mk_pred_for_hoare_triple :: Pred -> [Char]
mk_instr :: Context -> Instr -> [Char]
mk_fcs :: Context -> Instr -> Pred -> [Char]
all_preconditions :: Context -> IntMap Pred -> Set (a, Pred) -> Set VerificationCondition -> Set VerificationCondition
get_relevant_precs_for :: Pred -> Instr -> VerificationCondition -> Set VerificationCondition
mk_safe_isa_fun_name :: [Char] -> [Char]
expr_to_isa :: SimpleExpr -> [Char]
sp_to_isa :: StatePart -> [Char]
src_to_isa :: BotSrc -> [Char]
parens :: [Char] -> [Char]
mk_quote :: [Char] -> [Char]
mk_block :: [Char] -> [Char]
mk_isa_comment :: [Char] -> [Char]

module CallGraph
calls_of_cfg :: Context -> CFG -> IntSet
summarize_verification_conditions :: Context -> Set VerificationCondition -> [Char]
callgraph_to_dot :: Context -> Graph -> String


-- | After running FoxDec, a "verification report" (an object of type
--   <tt><a>Context</a></tt>) can be retrieved from the generated .report
--   file (see function <tt>ctxt_read_report</tt>). Essentially, this
--   module provides hooks into some of the information retrieved and
--   derived from the binary, including instructions, invariants, function
--   entry points, etc.
--   
--   A verification report is represented by the type
--   <tt><a>Context</a></tt>, as internally it is just the context passed
--   around and maintained during verification.
--   
--   The main flow is to read the .report file and use these functions to
--   retrieve information. The following example reads in a .report file
--   provided as first command-line parameter and outputs the function
--   entries:
--   
--   <pre>
--   main = do
--     args &lt;- getArgs
--     ctxt &lt;- ctxt_read_report $ head args
--     putStrLn $ show $ ctxt_get_function_entries ctxt
--   </pre>
--   
--   Some of the information is automatically also exported in plain-text
--   format, for easy access.
module VerificationReportInterface

-- | The return type when retrieving information from a verification
--   report: either an error message or a result.
type Retrieve a = Context -> Either String a

-- | Function Entries are simply integers
type FunctionEntry = Int

-- | Instruction Addresses are simply integers
type InstructionAddress = Int

-- | Read in the .report file from a file with the given file name. May
--   produce an error if no report can be read from the file. Returns the
--   verification report stored in the .report file.
ctxt_read_report :: String -> IO Context

-- | Retrieve all function entries.
--   
--   Returns a set of funtion entries.
ctxt_get_function_entries :: Retrieve (Set FunctionEntry)

-- | Retrieve all instruction addresses.
--   
--   Returns a set of instruction addresses.
ctxt_get_instruction_addresses :: Retrieve (Set InstructionAddress)

-- | Retrieve all indirections
--   
--   Returns, a mapping that provides for some instruction addresses a set
--   of jump targets.
ctxt_get_indirections :: Retrieve Indirections

-- | Retrieve instruction for a given instruction address, both as
--   datastructure and pretty-printed
ctxt_get_instruction :: InstructionAddress -> Retrieve (Instr, String)

-- | Retrieve invariant for a given function entry and instruction address
--   
--   An invariant is a predicate provding information over registers,
--   memory, flags, and verification conditions.
ctxt_get_invariant :: FunctionEntry -> InstructionAddress -> Retrieve Pred

-- | Retrieve all internal function calls for a given function entry
--   
--   Returns a set of function entries.
ctxt_get_internal_function_calls :: FunctionEntry -> Retrieve (Set FunctionEntry)

-- | Retrieve a CFG for a given function entry
ctxt_get_cfg :: FunctionEntry -> Retrieve CFG
