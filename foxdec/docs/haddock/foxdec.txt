-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Formally Verified x86-64 Decompilation
--   
--   This package contains tools for decompilation based on formal methods.
@package foxdec
@version 0.1.0.0


module Config

-- | When encountering an unknown instruction do we either 1.) report it to
--   stderr but continue (True), or 2.) exit with an error message (False)?
continue_on_unknown_instruction :: Bool

-- | The maximum number of separate concrete cases considered
--   non-deterministically, before abstraction is applied.
max_num_of_cases :: Int

-- | The maximum number of pointer bases a bottom-expression may have,
--   before more asbtraction is applied.
max_num_of_bases :: Int

-- | The maximum number of sources a bottom-expression may have, before
--   resoring to rock-bottom.
max_num_of_sources :: Int

-- | A coarse overapproximation of the maximum number of entries in a jump
--   table. Does not affect soundness, but if the value is set too low,
--   then more indirections may be left unresolved.
max_jump_table_size :: Integer


module Base

-- | Show the integer in hex.
showHex :: (Integral a, Show a) => a -> String

-- | Show an integer list as hex-list.
showHex_list :: (Integral a, Show a) => [a] -> [Char]

-- | Show an integer set as hex-list.
showHex_set :: IntSet -> [Char]

-- | Show an optional integer as an optional hex.
showHex_option :: (Integral a, Show a) => Maybe a -> [Char]

-- | Read an int from a string storing a hex.
readHex' :: (Eq a, Num a) => String -> a

-- | Lookup and produce error message if key does not exists in map.
im_lookup :: [Char] -> IntMap p -> Key -> p

-- | use a default value in case of <tt>Nothing</tt>
orElse :: Maybe p -> p -> p

-- | Find the index of one string in another.
findString :: Eq a => [a] -> [a] -> Maybe Int

-- | Strip outer parentheses from a string, if it has them.
strip_parentheses :: [Char] -> [Char]

-- | In little endian, convert a byte-list to a 64 bit word. Assume the
--   list is at most length 8.
bytes_to_word :: [Word8] -> Word64

-- | Convert first <tt>n</tt> bytes of a word to an integer. Assume
--   <tt>n&lt;8</tt>.
word_to_sint :: Int -> Word64 -> Int

-- | Generic graph with ints as vertices.
data Graph
Edges :: IntMap IntSet -> Graph

-- | add edges from v to all vertices vs
graph_add_edges :: Graph -> Key -> IntSet -> Graph

-- | delete all edges with v as parent or child
graph_delete :: Graph -> Key -> Graph

-- | is v parent of an edge?
graph_is_parent :: Graph -> Key -> Bool

-- | is v a vertex in the graph?
graph_is_vertex :: Graph -> Key -> Bool

-- | is (v0,v1) an edge?
graph_is_edge :: Graph -> Key -> Key -> Bool

-- | retrieve a non-trivial SCC, if any exists
graph_nontrivial_scc :: Graph -> IntSet

-- | find next vertex to consider: either a terminal vertex (if any) or the
--   head of an SCC
graph_find_next :: Graph -> Maybe Int

-- | decide whether text should be white or black based on background color
hex_color_of_text :: String -> String

-- | A list of RGB colors
hex_colors :: [[Char]]
instance GHC.Show.Show Base.Graph
instance GHC.Generics.Generic Base.Graph
instance Data.Serialize.Serialize Base.Graph
instance SCC.IntGraph Base.Graph


module X86_Datastructures

-- | An instruction
data Instr
Instr :: Int -> Maybe Prefix -> Opcode -> Maybe Operand -> Maybe Operand -> Maybe Operand -> Maybe String -> Int -> Instr

-- | address
[i_addr] :: Instr -> Int

-- | prefix, e.g., lock or repz
[i_prefix] :: Instr -> Maybe Prefix

-- | opcode (see data Opcode)
[i_opcode] :: Instr -> Opcode

-- | optional: operand
[i_op1] :: Instr -> Maybe Operand

-- | optional: operand
[i_op2] :: Instr -> Maybe Operand

-- | optional: operand
[i_op3] :: Instr -> Maybe Operand

-- | annotation, e.g., <a>+ 10</a>
[i_annot] :: Instr -> Maybe String

-- | size of instruction
[i_size] :: Instr -> Int

-- | Instruction prefixes
data Prefix
InvalidPrefix :: Prefix
REP :: Prefix
REPZ :: Prefix
LOCK :: Prefix
BND :: Prefix

-- | Registers
data Register
InvalidRegister :: Register
RIP :: Register
EIP :: Register
RAX :: Register
EAX :: Register
AX :: Register
AH :: Register
AL :: Register
RBX :: Register
EBX :: Register
BX :: Register
BH :: Register
BL :: Register
RCX :: Register
ECX :: Register
CX :: Register
CH :: Register
CL :: Register
RDX :: Register
EDX :: Register
DX :: Register
DH :: Register
DL :: Register
RDI :: Register
EDI :: Register
DI :: Register
DIL :: Register
RSI :: Register
ESI :: Register
SI :: Register
SIL :: Register
RSP :: Register
ESP :: Register
SP :: Register
SPL :: Register
RBP :: Register
EBP :: Register
BP :: Register
BPL :: Register
R15 :: Register
R15D :: Register
R15W :: Register
R15B :: Register
R14 :: Register
R14D :: Register
R14W :: Register
R14B :: Register
R13 :: Register
R13D :: Register
R13W :: Register
R13B :: Register
R12 :: Register
R12D :: Register
R12W :: Register
R12B :: Register
R11 :: Register
R11D :: Register
R11W :: Register
R11B :: Register
R10 :: Register
R10D :: Register
R10W :: Register
R10B :: Register
R9 :: Register
R9D :: Register
R9W :: Register
R9B :: Register
R8 :: Register
R8D :: Register
R8W :: Register
R8B :: Register
CS :: Register
DS :: Register
ES :: Register
FS :: Register
GS :: Register
SS :: Register
EIZ :: Register
RIZ :: Register
ST0 :: Register
ST1 :: Register
ST2 :: Register
ST3 :: Register
ST4 :: Register
ST5 :: Register
ST6 :: Register
ST7 :: Register
YMM0 :: Register
YMM1 :: Register
YMM2 :: Register
YMM3 :: Register
YMM4 :: Register
YMM5 :: Register
YMM6 :: Register
YMM7 :: Register
YMM8 :: Register
YMM9 :: Register
YMM10 :: Register
YMM11 :: Register
YMM12 :: Register
YMM13 :: Register
YMM14 :: Register
YMM15 :: Register
XMM0 :: Register
XMM1 :: Register
XMM2 :: Register
XMM3 :: Register
XMM4 :: Register
XMM5 :: Register
XMM6 :: Register
XMM7 :: Register
XMM8 :: Register
XMM9 :: Register
XMM10 :: Register
XMM11 :: Register
XMM12 :: Register
XMM13 :: Register
XMM14 :: Register
XMM15 :: Register

-- | Flags
data Flag
ZF :: Flag
CF :: Flag
SF :: Flag
OF :: Flag
PF :: Flag
InvalidFlag :: Flag

-- | An unresolved address, within the operand of an instruction.
data Address

-- | Reading a pointer from a register
FromReg :: Register -> Address

-- | Immediate address
AddrImm :: Int -> Address

-- | Minus
AddrMinus :: Address -> Address -> Address

-- | Plus
AddrPlus :: Address -> Address -> Address

-- | Times
AddrTimes :: Address -> Address -> Address

-- | Size directive, e.g., qword ptr, in bytes
SizeDir :: Int -> Address -> Address

-- | Operands of an instruction
data Operand

-- | Unresolved addresses
Address :: Address -> Operand

-- | Registers
Reg :: Register -> Operand

-- | Immediates
Immediate :: Word64 -> Operand

-- | Opcodes / mnemonics
data Opcode
InvalidOpcode :: Opcode
AAA :: Opcode
AAD :: Opcode
AAM :: Opcode
AAS :: Opcode
ADC :: Opcode
ADD :: Opcode
ADDPD :: Opcode
ADDPS :: Opcode
ADDSD :: Opcode
ADDSS :: Opcode
ADDSUBPD :: Opcode
ADDUBPS :: Opcode
AND :: Opcode
ANDNPD :: Opcode
ANDNPS :: Opcode
ANDPD :: Opcode
ANDPS :: Opcode
ARPL :: Opcode
BLENDVPS :: Opcode
BOUND :: Opcode
BSF :: Opcode
BSR :: Opcode
BT :: Opcode
BTC :: Opcode
BTR :: Opcode
BTS :: Opcode
CALL :: Opcode
CALLF :: Opcode
CBW :: Opcode
CDQ :: Opcode
CDQE :: Opcode
CLC :: Opcode
CLD :: Opcode
CLFLUSH :: Opcode
CLI :: Opcode
CLTS :: Opcode
CMC :: Opcode
CMOVA :: Opcode
CMOVAE :: Opcode
CMOVB :: Opcode
CMOVBE :: Opcode
CMOVC :: Opcode
CMOVE :: Opcode
CMOVG :: Opcode
CMOVGE :: Opcode
CMOVL :: Opcode
CMOVLE :: Opcode
CMOVNA :: Opcode
CMOVNAE :: Opcode
CMOVNB :: Opcode
CMOVNBE :: Opcode
CMOVNC :: Opcode
CMOVNE :: Opcode
CMOVNG :: Opcode
CMOVNGE :: Opcode
CMOVNL :: Opcode
CMOVNLE :: Opcode
CMOVNO :: Opcode
CMOVNP :: Opcode
CMOVNS :: Opcode
CMOVNZ :: Opcode
CMOVO :: Opcode
CMOVP :: Opcode
CMOVPE :: Opcode
CMOVPO :: Opcode
CMOVS :: Opcode
CMOVZ :: Opcode
CMP :: Opcode
CMPEQSD :: Opcode
CMPNEQSD :: Opcode
CMPLTSD :: Opcode
CMPS :: Opcode
CMPSB :: Opcode
CMPSD :: Opcode
CMPXCHG :: Opcode
CMPXCHG16B :: Opcode
CMPXCHG8B :: Opcode
COMISD :: Opcode
COMISS :: Opcode
CPUID :: Opcode
CQO :: Opcode
CVTDQ2PD :: Opcode
CVTSD2SS :: Opcode
CVTSI2SD :: Opcode
CVTSI2SS :: Opcode
CVTSS2SD :: Opcode
CVTTSD2SI :: Opcode
CVTTSS2SI :: Opcode
CVTTPD2DQ :: Opcode
CWD :: Opcode
CWDE :: Opcode
DAA :: Opcode
DAS :: Opcode
DEC :: Opcode
DIV :: Opcode
DIVPD :: Opcode
DIVPS :: Opcode
DIVSD :: Opcode
DIVSS :: Opcode
EMMS :: Opcode
ENDBR64 :: Opcode
ENTER :: Opcode
EXTRACTPS :: Opcode
FABS :: Opcode
FADD :: Opcode
FADDP :: Opcode
FBLD :: Opcode
FBSTP :: Opcode
FCHS :: Opcode
FCLEX :: Opcode
FCMOVB :: Opcode
FCMOVBE :: Opcode
FCMOVE :: Opcode
FCMOVNB :: Opcode
FCMOVNBE :: Opcode
FCMOVNE :: Opcode
FCMOVNU :: Opcode
FCMOVU :: Opcode
FCOM :: Opcode
FCOMI :: Opcode
FCOMIP :: Opcode
FCOMP :: Opcode
FCOMPI :: Opcode
FCOMPP :: Opcode
FCOS :: Opcode
FDIV :: Opcode
FDIVP :: Opcode
FDIVR :: Opcode
FDIVRP :: Opcode
FFREE :: Opcode
FRNDINT :: Opcode
FIADD :: Opcode
FICOM :: Opcode
FICOMP :: Opcode
FIDIV :: Opcode
FIDIVR :: Opcode
FILD :: Opcode
FIMUL :: Opcode
FINIT :: Opcode
FIST :: Opcode
FISTP :: Opcode
FISTPP :: Opcode
FISTTP :: Opcode
FISUB :: Opcode
FISUBR :: Opcode
FLD :: Opcode
FLD1 :: Opcode
FLDCW :: Opcode
FLDENV :: Opcode
FLDL2E :: Opcode
FLDL2T :: Opcode
FLDLG2 :: Opcode
FLDLN2 :: Opcode
FLDPI :: Opcode
FLDZ :: Opcode
FMUL :: Opcode
FMULP :: Opcode
FNOP :: Opcode
FNINIT :: Opcode
FNSTCW :: Opcode
FPREM1 :: Opcode
FRSTOR :: Opcode
FSAVE :: Opcode
FSIN :: Opcode
FSINCOS :: Opcode
FSCALE :: Opcode
FSQRT :: Opcode
FST :: Opcode
FSTCW :: Opcode
FSTENV :: Opcode
FSTP :: Opcode
FSTSW :: Opcode
FSUB :: Opcode
FSUBP :: Opcode
FSUBR :: Opcode
FSUBRP :: Opcode
FTST :: Opcode
FUCOM :: Opcode
FUCOMI :: Opcode
FUCOMIP :: Opcode
FUCOMP :: Opcode
FUCOMPI :: Opcode
FUCOMPP :: Opcode
FXAM :: Opcode
FXCH :: Opcode
FXRSTOR :: Opcode
FXSAVE :: Opcode
FXTRACT :: Opcode
HADDPD :: Opcode
HADDPS :: Opcode
HLT :: Opcode
HSUBPD :: Opcode
HSUBPS :: Opcode
IDIV :: Opcode
IMUL :: Opcode
BSWAP :: Opcode
IN :: Opcode
INC :: Opcode
INS :: Opcode
INSD :: Opcode
INT :: Opcode
INT3 :: Opcode
INTO :: Opcode
INVD :: Opcode
INVLPG :: Opcode
INVPCID :: Opcode
IRET :: Opcode
IRETD :: Opcode
IRETQ :: Opcode
JA :: Opcode
JAE :: Opcode
JB :: Opcode
JBE :: Opcode
JC :: Opcode
JCXZ :: Opcode
JE :: Opcode
JECXZ :: Opcode
JG :: Opcode
JGE :: Opcode
JL :: Opcode
JLE :: Opcode
JMP :: Opcode
JMPF :: Opcode
JMPN :: Opcode
JNAE :: Opcode
JNA :: Opcode
JNB :: Opcode
JNBE :: Opcode
JNC :: Opcode
JNG :: Opcode
JNE :: Opcode
JNGE :: Opcode
JNLE :: Opcode
JNL :: Opcode
JNO :: Opcode
JNP :: Opcode
JNS :: Opcode
JNZ :: Opcode
JO :: Opcode
JP :: Opcode
JPE :: Opcode
JPO :: Opcode
JRCXZ :: Opcode
JS :: Opcode
JZ :: Opcode
LAHF :: Opcode
LAR :: Opcode
LDDQU :: Opcode
LDMXCSR :: Opcode
LDS :: Opcode
LEA :: Opcode
LEAVE :: Opcode
LES :: Opcode
LFENCE :: Opcode
LFS :: Opcode
LGDT :: Opcode
LGS :: Opcode
LIDT :: Opcode
LLDT :: Opcode
LMSW :: Opcode
LODS :: Opcode
LODSB :: Opcode
LODSD :: Opcode
LODSW :: Opcode
LOOP :: Opcode
LOOPE :: Opcode
LOOPNE :: Opcode
LSL :: Opcode
LSS :: Opcode
LTR :: Opcode
MASKMOVQ :: Opcode
MAXPD :: Opcode
MAXPS :: Opcode
MAXSD :: Opcode
MAXSS :: Opcode
MFENCE :: Opcode
MINPD :: Opcode
MINPS :: Opcode
MINSD :: Opcode
MINSS :: Opcode
MONITOR :: Opcode
MOV :: Opcode
MOVABS :: Opcode
MOVAPD :: Opcode
MOVAPS :: Opcode
MOVD :: Opcode
MOVDDUP :: Opcode
MOVDQA :: Opcode
MOVDQU :: Opcode
MOVHLPS :: Opcode
MOVHPD :: Opcode
MOVHPS :: Opcode
MOVLHPS :: Opcode
MOVLPD :: Opcode
MOVLPS :: Opcode
MOVLSDUP :: Opcode
MOVMSKPD :: Opcode
MOVMSKPS :: Opcode
MOVNTDQ :: Opcode
MOVNTPD :: Opcode
MOVNTPS :: Opcode
MOVNTQ :: Opcode
MOVQ :: Opcode
MOVS :: Opcode
MOVSD :: Opcode
MOVSLDUP :: Opcode
MOVSS :: Opcode
MOVSQ :: Opcode
MOVSX :: Opcode
MOVSXB :: Opcode
MOVSXD :: Opcode
MOVSXW :: Opcode
MOVUPD :: Opcode
MOVUPS :: Opcode
MOVZX :: Opcode
MOVZXB :: Opcode
MOVZXW :: Opcode
MUL :: Opcode
MULPD :: Opcode
MULPS :: Opcode
MULSD :: Opcode
MULSS :: Opcode
MWAIT :: Opcode
NEG :: Opcode
NOP :: Opcode
NOT :: Opcode
OR :: Opcode
ORPD :: Opcode
ORPS :: Opcode
OUT :: Opcode
OUTS :: Opcode
PALIGNR :: Opcode
PACKSSDW :: Opcode
PACKSSWB :: Opcode
PADDB :: Opcode
PADDD :: Opcode
PADDQ :: Opcode
PADDSB :: Opcode
PADDSW :: Opcode
PADDUSB :: Opcode
PADDUSW :: Opcode
PADDW :: Opcode
PAND :: Opcode
PANDN :: Opcode
PAUSE :: Opcode
PAVGB :: Opcode
PAVGW :: Opcode
PCLMULQDQ :: Opcode
PCMPEQB :: Opcode
PCMPEQD :: Opcode
PCMPGTB :: Opcode
PCMPGTD :: Opcode
PEXTRB :: Opcode
PEXTRD :: Opcode
PEXTRQ :: Opcode
PINSRD :: Opcode
PINSRQ :: Opcode
PMADDWD :: Opcode
PMAXSW :: Opcode
PMAXUB :: Opcode
PMAXUD :: Opcode
PMAXUQ :: Opcode
PMINSD :: Opcode
PMINSW :: Opcode
PMINUB :: Opcode
PMINUD :: Opcode
PMOVMSKB :: Opcode
PMOVSXDQ :: Opcode
PMOVZXDQ :: Opcode
PMOVSXBD :: Opcode
PMOVZXBD :: Opcode
PMULLD :: Opcode
PMULLQ :: Opcode
PMULHUW :: Opcode
PMULHW :: Opcode
PMULLW :: Opcode
PMULUDQ :: Opcode
POP :: Opcode
POPA :: Opcode
POPAD :: Opcode
POPF :: Opcode
POPFD :: Opcode
POPFQ :: Opcode
POR :: Opcode
PREFETCHNTA :: Opcode
PREFETCHT0 :: Opcode
PREFETCHT1 :: Opcode
PREFETCHT2 :: Opcode
PSADBW :: Opcode
PSHUFB :: Opcode
PSHUFD :: Opcode
PSHUFLW :: Opcode
PSLLD :: Opcode
PSLLDQ :: Opcode
PSLLQ :: Opcode
PSLLW :: Opcode
PSRAD :: Opcode
PSRAW :: Opcode
PSRLD :: Opcode
PSRLDQ :: Opcode
PSRLQ :: Opcode
PSRLW :: Opcode
PSUBB :: Opcode
PSUBD :: Opcode
PSUBQ :: Opcode
PSUBSB :: Opcode
PSUBSQ :: Opcode
PSUBUSB :: Opcode
PSUBUSW :: Opcode
PSUBW :: Opcode
PTEST :: Opcode
PUNPCKLBW :: Opcode
PUNPCKLWD :: Opcode
PUNPCKLDQ :: Opcode
PUNPCKLQDQ :: Opcode
PUSH :: Opcode
PUSHA :: Opcode
PUSHAD :: Opcode
PUSHF :: Opcode
PUSHFD :: Opcode
PUSHFQ :: Opcode
PXOR :: Opcode
RCL :: Opcode
RCPPS :: Opcode
RCPSS :: Opcode
RCR :: Opcode
RDMSR :: Opcode
RDPMC :: Opcode
RDTSC :: Opcode
RET :: Opcode
RETF :: Opcode
RETN :: Opcode
ROL :: Opcode
ROR :: Opcode
ROUNDSD :: Opcode
ROUNDSS :: Opcode
RSM :: Opcode
RSQRTPS :: Opcode
RSQRTSS :: Opcode
SAHF :: Opcode
SAL :: Opcode
SAR :: Opcode
SBB :: Opcode
SCAS :: Opcode
SCASB :: Opcode
SCASD :: Opcode
SETA :: Opcode
SETAE :: Opcode
SETB :: Opcode
SETBE :: Opcode
SETC :: Opcode
SETE :: Opcode
SETG :: Opcode
SETGE :: Opcode
SETL :: Opcode
SETLE :: Opcode
SETNA :: Opcode
SETNAE :: Opcode
SETNB :: Opcode
SETNBE :: Opcode
SETNC :: Opcode
SETNE :: Opcode
SETNG :: Opcode
SETNGE :: Opcode
SETNL :: Opcode
SETNLE :: Opcode
SETNO :: Opcode
SETNP :: Opcode
SETNS :: Opcode
SETNZ :: Opcode
SETO :: Opcode
SETP :: Opcode
SETPE :: Opcode
SETPO :: Opcode
SETS :: Opcode
SETZ :: Opcode
SFENCE :: Opcode
SGDT :: Opcode
SHL :: Opcode
SHLD :: Opcode
SHR :: Opcode
SHRD :: Opcode
SHUFPS :: Opcode
SIDT :: Opcode
SLDT :: Opcode
SMSW :: Opcode
SQRTPD :: Opcode
SQRTPS :: Opcode
SQRTSD :: Opcode
SQRTSS :: Opcode
STC :: Opcode
STD :: Opcode
STI :: Opcode
STMXCSR :: Opcode
STOS :: Opcode
STOSD :: Opcode
STR :: Opcode
SUB :: Opcode
SUBPD :: Opcode
SUBPS :: Opcode
SUBSD :: Opcode
SUBSS :: Opcode
SWAPGS :: Opcode
SYSCALL :: Opcode
SYSENTER :: Opcode
SYSEXIT :: Opcode
SYSRET :: Opcode
TEST :: Opcode
UCOMISD :: Opcode
UCOMISS :: Opcode
UD2 :: Opcode
UNPCKHPD :: Opcode
UNPCKHPS :: Opcode
UNPCKLPD :: Opcode
UNPCKLPS :: Opcode
VANDPD :: Opcode
VANDPS :: Opcode
VADDPD :: Opcode
VADDPS :: Opcode
VBLENDPS :: Opcode
VERR :: Opcode
VERW :: Opcode
VEXTRACTI128 :: Opcode
VEXTRACTF128 :: Opcode
VINSERTF128 :: Opcode
VMCALL :: Opcode
VMCLEAR :: Opcode
VMLAUNCH :: Opcode
VMOVAPD :: Opcode
VMOVAPS :: Opcode
VMOVHPS :: Opcode
VMOVD :: Opcode
VMOVDQA :: Opcode
VMOVDQU :: Opcode
VMOVLHPS :: Opcode
VMPTRLD :: Opcode
VMPTRST :: Opcode
VMREAD :: Opcode
VMRESUME :: Opcode
VMWRITE :: Opcode
VMULPD :: Opcode
VMULPS :: Opcode
VMXOFF :: Opcode
VMXON :: Opcode
VPALIGNR :: Opcode
VPAND :: Opcode
VPANDN :: Opcode
VPCMPEQB :: Opcode
VPCMPEQW :: Opcode
VPERM2F128 :: Opcode
VPERM2I128 :: Opcode
VPERMILPS :: Opcode
VPOR :: Opcode
VPSHUFB :: Opcode
VPSHUFD :: Opcode
VPSLLW :: Opcode
VSHUFPS :: Opcode
VSHUFPD :: Opcode
VPXOR :: Opcode
VPUNPCKLWD :: Opcode
VPUNPCKHWD :: Opcode
VSUBPD :: Opcode
VSUBPS :: Opcode
VUNPCKHPS :: Opcode
VUNPCKLPS :: Opcode
VXORPD :: Opcode
VXORPS :: Opcode
VZEROUPPER :: Opcode
WAIT :: Opcode
WBINVD :: Opcode
WRFSBASE :: Opcode
WRGSBASE :: Opcode
WRMSR :: Opcode
XADD :: Opcode
XCHG :: Opcode
XLAT :: Opcode
XLATB :: Opcode
XSETBV :: Opcode
XSAVEOPT :: Opcode
XRSTOR :: Opcode
XOR :: Opcode
XORPD :: Opcode
XORPS :: Opcode

-- | Showing unresolved address (inner part within a ptr[...])
show_address' :: Address -> [Char]

-- | Showing unresolved address
show_address :: Address -> [Char]

-- | Showing a size directive
show_size_directive :: (Eq a, Num a, Show a) => a -> [Char]

-- | Showing an operand
show_operand' :: Operand -> [Char]

-- | Showing an optional operand
show_operand :: Show a => Maybe a -> [Char]

-- | Showing an optional annotation
show_annot :: Maybe [Char] -> [Char]

-- | Showing an optional prefix
show_prefix :: Show a => Maybe a -> [Char]

-- | Showing an instruction
show_instruction :: Instr -> [Char]

-- | The size of the operand, in bytes
operand_size :: Operand -> Int

-- | Returns true iff m is the mnemonic of a conditional jump
is_cond_jump :: Opcode -> Bool

-- | Returns true iff m is the mnemonic of a halting instruction
is_halt :: Opcode -> Bool

-- | Returns true iff m is the mnemonic of a jump
is_jump :: Opcode -> Bool

-- | Returns true iff m is the mnemonic of a call
is_call :: Opcode -> Bool

-- | Returns true iff m is the mnemonic of a return
is_ret :: Opcode -> Bool

-- | List of 256 bit registers
reg256 :: [Register]

-- | List of 128 bit registers
reg128 :: [Register]

-- | List of 80 bit registers
reg80 :: [Register]

-- | List of 64 bit registers
reg64 :: [Register]

-- | List of 32 bit registers
reg32 :: [Register]

-- | List of 16 bit registers
reg16 :: [Register]

-- | List of 8 bit registers
reg8 :: [Register]

-- | The size of the given register, in bytes.
reg_size :: Num p => Register -> p

-- | Matches register names to the real registers E.g.: EAX is actually a
--   part of RAX
real_reg :: Register -> Register
instance GHC.Generics.Generic X86_Datastructures.Prefix
instance GHC.Read.Read X86_Datastructures.Prefix
instance GHC.Classes.Ord X86_Datastructures.Prefix
instance GHC.Classes.Eq X86_Datastructures.Prefix
instance GHC.Show.Show X86_Datastructures.Prefix
instance GHC.Generics.Generic X86_Datastructures.Register
instance GHC.Classes.Ord X86_Datastructures.Register
instance GHC.Read.Read X86_Datastructures.Register
instance GHC.Classes.Eq X86_Datastructures.Register
instance GHC.Show.Show X86_Datastructures.Register
instance GHC.Classes.Ord X86_Datastructures.Flag
instance GHC.Classes.Eq X86_Datastructures.Flag
instance GHC.Show.Show X86_Datastructures.Flag
instance GHC.Generics.Generic X86_Datastructures.Address
instance GHC.Classes.Ord X86_Datastructures.Address
instance GHC.Classes.Eq X86_Datastructures.Address
instance GHC.Generics.Generic X86_Datastructures.Operand
instance GHC.Classes.Ord X86_Datastructures.Operand
instance GHC.Classes.Eq X86_Datastructures.Operand
instance GHC.Generics.Generic X86_Datastructures.Opcode
instance GHC.Classes.Ord X86_Datastructures.Opcode
instance GHC.Read.Read X86_Datastructures.Opcode
instance GHC.Classes.Eq X86_Datastructures.Opcode
instance GHC.Show.Show X86_Datastructures.Opcode
instance GHC.Generics.Generic X86_Datastructures.Instr
instance GHC.Classes.Ord X86_Datastructures.Instr
instance GHC.Classes.Eq X86_Datastructures.Instr
instance Data.Serialize.Serialize X86_Datastructures.Instr
instance GHC.Show.Show X86_Datastructures.Instr
instance Data.Serialize.Serialize X86_Datastructures.Opcode
instance Data.Serialize.Serialize X86_Datastructures.Operand
instance GHC.Show.Show X86_Datastructures.Operand
instance Data.Serialize.Serialize X86_Datastructures.Address
instance GHC.Show.Show X86_Datastructures.Address
instance Data.Serialize.Serialize X86_Datastructures.Register
instance Data.Serialize.Serialize X86_Datastructures.Prefix


-- | A datatype for symbolic predicates, tailored to storing information on
--   equalities between the current values stored in state parts (lhs) and
--   constant expressions (rhs).
module SimplePred

-- | A symbolic predicate consists of:
--   
--   <ul>
--   <li>A mapping from stateparts to symbolic expressions.</li>
--   <li>The status of the flags.</li>
--   <li>A set of verification conditions.</li>
--   <li>The <tt><a>StateMuddleStatus</a></tt></li>
--   </ul>
data Pred
Predicate :: Map StatePart SimpleExpr -> FlagStatus -> StateMuddleStatus -> Pred

-- | A statepart is either a register or a region in memory
data StatePart

-- | A register
SP_Reg :: Register -> StatePart

-- | A region with a symbolic address and an immediate size.
SP_Mem :: SimpleExpr -> Int -> StatePart

-- | A symbolic expression with as leafs either immediates, variables, live
--   values of stateparts, or malloced addresses. A variable is a constant
--   representing some initial value, e.g., RDI_0, or [RSP_0,8]_0. A
--   statepart evaluates to its current value, e.g., RDI or [RSP,8].
data SimpleExpr

-- | An immediate word
SE_Immediate :: Word64 -> SimpleExpr

-- | A variable representing the initial value stored in the statepart
--   (e.g., RSP0)
SE_Var :: StatePart -> SimpleExpr

-- | The value stored currently in the statepart
SE_StatePart :: StatePart -> SimpleExpr

-- | A malloc return value with possibly an ID
SE_Malloc :: Maybe Int -> Maybe String -> SimpleExpr

-- | Application of an <tt><a>Operator</a></tt> to the list of arguments
SE_Op :: Operator -> [SimpleExpr] -> SimpleExpr

-- | Taking the lower bits of a value
SE_Bit :: Int -> SimpleExpr -> SimpleExpr

-- | Sign extension
SE_SExtend :: Int -> Int -> SimpleExpr -> SimpleExpr

-- | Overwriting certain bits of a value with bits from another value
SE_Overwrite :: Int -> SimpleExpr -> SimpleExpr -> SimpleExpr

-- | Bottom (unknown value)
Bottom :: BotTyp -> SimpleExpr

-- | Symbolically represent the status of all flags in the current state
data FlagStatus

-- | No information known, flags could have any value
None :: FlagStatus

-- | The flags are set by the x86 CMP instruction applied to the given
--   operands.
FS_CMP :: Maybe Bool -> Operand -> Operand -> FlagStatus

-- | Have functions been called by the current function?
data StateMuddleStatus

-- | No function calls have been executed
Clean :: StateMuddleStatus

-- | All function calls were to external functions
ExternalOnly :: StateMuddleStatus

-- | At least one internal function has been called
Muddled :: StateMuddleStatus

-- | Bot represents an unknown (bottom) value. We annotate each occurence
--   of Bot with a BotTyp. This type indicates where the bottom value
--   originates from. The latter six are all equal, we just use them for
--   debugging and information. They indicate that the value is unknown,
--   but was computed using the set of sources.
data BotTyp

-- | The expression evaluates to one of the expressions in the set
FromNonDeterminism :: Set SimpleExpr -> BotTyp

-- | The expression is a pointer-computation with known base(s)
FromPointerBases :: Set PointerBase -> BotTyp

-- | Return value of a function call
FromCall :: String -> BotTyp

-- | The expression is some computation based on sources.
FromSources :: Set BotSrc -> BotTyp

-- | A read from two possibly overlapping regions
FromOverlap :: Set BotSrc -> BotTyp

-- | A write to two possibly overlapping regions
FromMemWrite :: Set BotSrc -> BotTyp

-- | An instruction with unknown semantics
FromSemantics :: Set BotSrc -> BotTyp

-- | Should not happen, but if a register writes to a registeralias with
--   unknown bit size
FromBitMode :: Set BotSrc -> BotTyp

-- | Reading from memory not written to yet
FromUninitializedMemory :: Set BotSrc -> BotTyp

-- | Sources that may be used to compute an expression. That is, the inputs
--   to an expression.
data BotSrc
Src_Var :: StatePart -> BotSrc
Src_Malloc :: Maybe Int -> Maybe String -> BotSrc
Src_Function :: String -> BotSrc

-- | An operator is a pure operation over bit-vectors, annotated with the
--   bit-size of its operands. For example, <tt>Plus 64</tt> denotes 64-bit
--   addition. <tt>Udiv</tt> and <tt>Times</tt> are operators op type <tt>w
--   -&gt; w -&gt; w</tt> with all words same length. <tt>Div</tt> and
--   <tt>Div_Rem</tt> are operators of type <tt>w -&gt; w -&gt; w -&gt;
--   w</tt> performing concatenation of the first two words and then doing
--   division/remainder.
data Operator
Minus :: Int -> Operator
Plus :: Int -> Operator
Times :: Int -> Operator
And :: Int -> Operator
Or :: Int -> Operator
Xor :: Int -> Operator
Not :: Int -> Operator
SetXX :: Operator
Bsr :: Int -> Operator
Div_Rem :: Int -> Operator
Div :: Int -> Operator
Shl :: Int -> Operator
Shr :: Int -> Operator
Sar :: Int -> Operator
Udiv :: Int -> Operator
Ror :: Int -> Operator
Rol :: Int -> Operator
Bswap :: Int -> Operator
Pextr :: Int -> Operator

-- | A pointerbase is a positive addend of a symbolic expression that may
--   represent a pointer.
data PointerBase

-- | The stackpointer, for <i>local</i> variables
StackPointer :: PointerBase

-- | A malloc (at the <i>heap</i>) at a given address (hash is unused for
--   now)
Malloc :: Maybe Int -> Maybe String -> PointerBase

-- | A <i>global</i> address in the range of the sections of the binary.
GlobalAddress :: Word64 -> PointerBase

-- | An address with an associated symbol.
PointerToSymbol :: Word64 -> String -> PointerBase

-- | n expresion without identifiable pointerbase,
Unknown :: SimpleExpr -> PointerBase

-- | Returns true iff the expression is an immediate value
is_immediate :: SimpleExpr -> Bool

-- | Is the statepart memory?
is_mem_sp :: StatePart -> Bool

-- | Is the statepart a register?
is_reg_sp :: StatePart -> Bool

-- | Returns true iff the expression contains Bot
contains_bot :: SimpleExpr -> Bool

-- | Returns true iff the statepart contains Bot
contains_bot_sp :: StatePart -> Bool

-- | Do all occurences of Bottom satisfy the given predicate?
all_bot_satisfy :: (BotTyp -> Bool) -> SimpleExpr -> Bool

-- | Simplification of symbolic expressions.
--   
--   Must always produce an expression logically equivalent to the
--   original.
simp :: SimpleExpr -> SimpleExpr

-- | The lowest botom element
rock_bottom :: SimpleExpr

-- | If the size of an expression becomes too large, we simply turn it into
--   Bottom.
trim_expr :: SimpleExpr -> SimpleExpr

-- | Pretty print expression, showing Bottom expressions only as Bot
pp_expr :: SimpleExpr -> [Char]

-- | Pretty print predicate, showing Bottom expressions only as Bot
pp_pred :: Pred -> String

-- | Unfold an expression with non-determinisism to a list of expressions.
--   Keep an eye on the produced size, as this may cause blow-up.
unfold_non_determinism :: SimpleExpr -> [SimpleExpr]

expr_size :: SimpleExpr -> Int
max_expr_size :: Int
instance GHC.Generics.Generic SimplePred.Operator
instance GHC.Classes.Ord SimplePred.Operator
instance GHC.Classes.Eq SimplePred.Operator
instance GHC.Classes.Ord SimplePred.PointerBase
instance GHC.Classes.Eq SimplePred.PointerBase
instance GHC.Generics.Generic SimplePred.PointerBase
instance GHC.Generics.Generic SimplePred.BotSrc
instance GHC.Classes.Ord SimplePred.BotSrc
instance GHC.Classes.Eq SimplePred.BotSrc
instance GHC.Generics.Generic SimplePred.BotTyp
instance GHC.Classes.Ord SimplePred.BotTyp
instance GHC.Classes.Eq SimplePred.BotTyp
instance GHC.Generics.Generic SimplePred.SimpleExpr
instance GHC.Classes.Ord SimplePred.SimpleExpr
instance GHC.Classes.Eq SimplePred.SimpleExpr
instance GHC.Generics.Generic SimplePred.StatePart
instance GHC.Classes.Ord SimplePred.StatePart
instance GHC.Classes.Eq SimplePred.StatePart
instance GHC.Classes.Ord SimplePred.FlagStatus
instance GHC.Classes.Eq SimplePred.FlagStatus
instance GHC.Generics.Generic SimplePred.FlagStatus
instance GHC.Classes.Ord SimplePred.StateMuddleStatus
instance GHC.Show.Show SimplePred.StateMuddleStatus
instance GHC.Classes.Eq SimplePred.StateMuddleStatus
instance GHC.Generics.Generic SimplePred.StateMuddleStatus
instance GHC.Classes.Ord SimplePred.Pred
instance GHC.Classes.Eq SimplePred.Pred
instance GHC.Generics.Generic SimplePred.Pred
instance Data.Serialize.Serialize SimplePred.Pred
instance GHC.Show.Show SimplePred.Pred
instance Data.Serialize.Serialize SimplePred.StateMuddleStatus
instance Data.Serialize.Serialize SimplePred.FlagStatus
instance GHC.Show.Show SimplePred.FlagStatus
instance GHC.Show.Show SimplePred.BotSrc
instance GHC.Show.Show SimplePred.BotTyp
instance GHC.Show.Show SimplePred.SimpleExpr
instance GHC.Show.Show SimplePred.StatePart
instance GHC.Show.Show SimplePred.PointerBase
instance Data.Serialize.Serialize SimplePred.PointerBase
instance Data.Serialize.Serialize SimplePred.BotTyp
instance Data.Serialize.Serialize SimplePred.BotSrc
instance Data.Serialize.Serialize SimplePred.StatePart
instance Data.Serialize.Serialize SimplePred.SimpleExpr
instance GHC.Show.Show SimplePred.Operator
instance Data.Serialize.Serialize SimplePred.Operator


module Conventions

-- | A list of function names of functions that never return.
exiting_function_calls :: [[Char]]

-- | Overview of sections with instructions.
sections_with_instructions :: [([Char], [Char])]

-- | Sections in the following list are assumed not to be modifiable during
--   execution, i.e., constant.
section_is_unwritable :: ([Char], [Char]) -> Bool

-- | A list if registers that are non-volatile, i.e., that must be
--   preserved by a function (callee-saved)
callee_saved_registers :: [Register]

-- | A list of registers that may be used for return values
return_registers :: [Register]

-- | A list of registers used as parameters
parameter_registers :: [Register]


-- | The context stores, among others, information obtained during
--   verification, such as CFGs, invariants, etc. (see
--   <tt><a>Context</a></tt>). Module <a>VerificationReportInterface</a>
--   provides functions for obtaining and interfacing with a
--   <tt>Context</tt>.
module Context

-- | A control flow graph with blocks and edges. A blockID (represented as
--   an <tt>Int</tt>) is a unique identifier of a basic block. We store
--   basic blocks twice: once as addresses, and once as instructions.
data CFG
CFG :: IntMap [Int] -> IntMap IntSet -> IntMap Int -> Int -> IntMap [Instr] -> CFG

-- | A mapping of blockIDs to instruction addresses
[cfg_blocks] :: CFG -> IntMap [Int]

-- | A mapping of blockIDs to sets of blocKIDs
[cfg_edges] :: CFG -> IntMap IntSet

-- | A mapping of instruction addresses to blockIDs
[cfg_addr_to_blockID] :: CFG -> IntMap Int

-- | A fresh blockID
[cfg_fresh] :: CFG -> Int

-- | A mapping of blockIDs to lists of disassembled instructions.
[cfg_instrs] :: CFG -> IntMap [Instr]

-- | Per instruction address, a set of jump targets.
type Indirections = IntMap IntSet

-- | Sections: segment names, section names, addresses and sizes.
type SectionsInfo = [(String, String, Int, Int)]

-- | An enumeration indicating the result of verification over a function
data VerificationResult

-- | Function was succesfully verified
VerificationSuccess :: VerificationResult

-- | Function was succesfully verified, but required assertions
VerificationSuccesWithAssumptions :: VerificationResult

-- | Function contains an unresolved indirection
VerificationUnresolvedIndirection :: VerificationResult

-- | There was some verification error, e.g., return adresss overwrite
VerificationError :: String -> VerificationResult

-- | The function has not been verified.
Unverified :: VerificationResult

-- | Invariants: a mapping of blockIDs to predicates
type Invariants = IntMap Pred

-- | For each leaf-node in a CFG we store the following info.
data NodeInfo

-- | The basic block behaves normally, e.g., a ret
Normal :: NodeInfo

-- | The basic block ends in an unresolved indirection
UnresolvedIndirection :: NodeInfo

-- | The basic blocks ends with, e.g., a call to exit()
Terminal :: NodeInfo

-- | Postconditions: for each final block the <tt>NodeInfo</tt> and the
--   final predicate after execution of the block
type Postconditions = Set (NodeInfo, Pred)

-- | Identifies where a memwrite occurred
data MemWriteIdentifier

-- | A function with <tt>name</tt> at address <tt>i_a</tt> wrote to a
--   statepart
MemWriteFunction :: String -> Int -> StatePart -> MemWriteIdentifier

-- | An instruction wrote to an operand, resolving to an address
MemWriteInstruction :: Int -> Address -> SimpleExpr -> MemWriteIdentifier

-- | A verification condition is either: * A precondition of the form: &gt;
--   Precondition (a0,si0) (a1,si1) This formulates that at the initial
--   state the two regions must be separate. * An assertion of the form:
--   &gt; Assertion a (a0,si0) (a1,si1) This formulates that dynamically,
--   whenever address a is executed, the two regions are asserted to be
--   separate. * A function constraint of the form: &gt; FunctionConstraint
--   foo [(RDI, v0), (RSI, v1), ...] { sp0,sp1,... } This formulates that a
--   function call to function foo with values v0, v1, ... stored in the
--   registers should not overwrite certain state parts.
data VerificationCondition

-- | Precondition: lhs SEP rhs
Precondition :: SimpleExpr -> Int -> SimpleExpr -> Int -> VerificationCondition

-- | Assertion: @address, lhs SEP rhs
Assertion :: SimpleExpr -> SimpleExpr -> Int -> SimpleExpr -> Int -> VerificationCondition

-- | Function name, address, of call, with param registers
FunctionConstraint :: String -> Int -> [(Register, SimpleExpr)] -> Set StatePart -> VerificationCondition

-- | A memory write for which no information was available
SourcelessMemWrite :: MemWriteIdentifier -> VerificationCondition

-- | An acornym for a set of verification conditions
type VCS = Set VerificationCondition

-- | A function initialisation consists of a mapping of stateparts to
--   expressions.
type FInit = Map StatePart SimpleExpr

-- | A function call
data FReturnBehavior

-- | The function does never return
Terminating :: FReturnBehavior

-- | The function returns withg the symbolic changes stored in the
--   predicate
ReturningWith :: Pred -> FReturnBehavior

-- | It is unknown whether the function returns or not
UnknownRetBehavior :: FReturnBehavior

-- | The context datastructure.
--   
--   <b>S</b>: Information <b>S</b>tatically obtained by reading from the
--   binary
--   
--   <b>D</b>: Information <b>D</b>ynamically updated during verification
data Context
Context :: IntMap Word8 -> IntMap String -> SectionsInfo -> String -> String -> Bool -> Graph -> IntMap CFG -> IntMap FReturnBehavior -> IntMap Invariants -> IntMap Postconditions -> Indirections -> IntMap FInit -> IntMap VCS -> IntMap VerificationResult -> IntMap IntSet -> Context

-- | <b>S</b>: mapping from addresses to bytes (data and instructions from
--   the binary/executable)
[ctxt_dump] :: Context -> IntMap Word8

-- | <b>S</b>: the symbol table: a mapping of addresses to function names
--   for external functions
[ctxt_syms] :: Context -> IntMap String

-- | <b>S</b>: information on segments/section
[ctxt_sections] :: Context -> SectionsInfo

-- | <b>S</b>: the name of the directory where the .dump, .entry, .sections
--   and .symbols files reside
[ctxt_dirname] :: Context -> String

-- | <b>S</b>: the name of the binary
[ctxt_name] :: Context -> String

-- | <b>S</b>: do we call graphviz to generate PDFs from .dot files?
[ctxt_generate_pdfs] :: Context -> Bool

-- | <b>D</b>: a graph with an edge (e0,e1) if entry address e0 calls entry
--   address e1, and e0 and e1 have not been verified yet
[ctxt_entries] :: Context -> Graph

-- | <b>D</b>: the currently known control flow graphs per function entry
[ctxt_cfgs] :: Context -> IntMap CFG

-- | <b>D</b>: the currently known and verified entry addresses of
--   functions mapped to return-information
[ctxt_calls] :: Context -> IntMap FReturnBehavior

-- | <b>D</b>: the currently known invariants
[ctxt_invs] :: Context -> IntMap Invariants

-- | <b>D</b>: the currently known postconditions
[ctxt_posts] :: Context -> IntMap Postconditions

-- | <b>D</b>: the currently known indirections
[ctxt_inds] :: Context -> Indirections

-- | <b>D</b>: the currently known function initialisations
[ctxt_finits] :: Context -> IntMap FInit

-- | <b>D</b>: the verification conditions
[ctxt_vcs] :: Context -> IntMap VCS

-- | <b>D</b>: the verification result
[ctxt_results] :: Context -> IntMap VerificationResult
[ctxt_recursions] :: Context -> IntMap IntSet

-- | Reading from a data section.
--   
--   Reads maximally up to 8 bytes. Returns <tt>Nothing</tt> if the given
--   address is out-of-range.
read_from_datasection :: Context -> Word64 -> Int -> Maybe Word64

-- | Find a section for an address (see <tt><a>SectionsInfo</a></tt>)
find_section_for_address :: Context -> Int -> Maybe (String, String, Int, Int)

-- | Fetching an instruction
--   
--   Returns <tt>Nothing</tt> if the given address is out-of-range.
fetch_instruction :: Context -> Int -> IO (Maybe Instr)

-- | Pretty printing an instruction
pp_instruction :: Context -> Instr -> String

-- | Show function initialisation
show_finit :: (Show a1, Show a2) => Map a1 a2 -> [Char]

-- | Is the given verification condition an assertion?
is_assertion :: VerificationCondition -> Bool

-- | Is the given verification condition a precondition?
is_precondition :: VerificationCondition -> Bool

-- | Is the given verification condition a function constraint?
is_func_constraint :: VerificationCondition -> Bool

-- | Is the given verification condition a sourceless memwrite?
is_sourceless_memwrite :: VerificationCondition -> Bool

-- | Count the number of assertions in the set of verification conditions.
count_instructions_with_assertions :: Set VerificationCondition -> Int

-- | Count the number of sourceless memory writes in the set of
--   verification conditions.
count_sourceless_memwrites :: Set VerificationCondition -> Int
instance GHC.Classes.Eq Context.CFG
instance GHC.Generics.Generic Context.CFG
instance GHC.Show.Show Context.CFG
instance GHC.Generics.Generic Context.VerificationResult
instance GHC.Classes.Eq Context.VerificationResult
instance GHC.Classes.Ord Context.NodeInfo
instance GHC.Classes.Eq Context.NodeInfo
instance GHC.Generics.Generic Context.NodeInfo
instance GHC.Show.Show Context.NodeInfo
instance GHC.Classes.Ord Context.MemWriteIdentifier
instance GHC.Classes.Eq Context.MemWriteIdentifier
instance GHC.Generics.Generic Context.MemWriteIdentifier
instance GHC.Classes.Ord Context.VerificationCondition
instance GHC.Classes.Eq Context.VerificationCondition
instance GHC.Generics.Generic Context.VerificationCondition
instance GHC.Classes.Ord Context.FReturnBehavior
instance GHC.Classes.Eq Context.FReturnBehavior
instance GHC.Generics.Generic Context.FReturnBehavior
instance GHC.Show.Show Context.FReturnBehavior
instance GHC.Generics.Generic Context.Context
instance Data.Serialize.Serialize Context.Context
instance Data.Serialize.Serialize Context.FReturnBehavior
instance Data.Serialize.Serialize Context.VerificationCondition
instance GHC.Show.Show Context.VerificationCondition
instance Data.Serialize.Serialize Context.MemWriteIdentifier
instance GHC.Show.Show Context.MemWriteIdentifier
instance Data.Serialize.Serialize Context.NodeInfo
instance Data.Serialize.Serialize Context.VerificationResult
instance GHC.Show.Show Context.VerificationResult
instance Data.Serialize.Serialize Context.CFG


-- | Contains function relating to control flow, including functions for
--   resolving the targets of jumps and calls.
module ControlFlow

-- | Resolving the operand of a jump/call can produce one of the following.
data ResolvedJumpTarget

-- | An indirect branch that has not been resolved yet
Unresolved :: ResolvedJumpTarget

-- | A call to external function f
External :: String -> ResolvedJumpTarget

-- | An internal call to the given address
ImmediateAddress :: Word64 -> ResolvedJumpTarget

-- | The set of next blocks from the given block
post :: CFG -> Key -> IntSet

-- | Fetching an instruction list given a block ID
fetch_block :: CFG -> Int -> [Instr]

-- | Returns true iff an instruction can be fetched from the address.
address_has_instruction :: Integral a => Context -> a -> Bool

-- | Returns true iff a symbol is associated with the address.
address_has_symbol :: Integral a => Context -> a -> Bool

-- | Returns truee if the adress is external, i.e., has no instruction or
--   has a symbol.
address_is_external :: Integral a => Context -> a -> Bool

-- | many operands can statically be resolved, even though technically they
--   are indirect (relative to RIP). Examples:
--   
--   <tt>10005464e: call RIP + 1751660</tt> resolves to an immediate jump
--   target by resolving the RIP-relative addressing.
--   
--   <tt>10005464e: call qword ptr [RIP + 1751660]</tt> read from address
--   1002000c0, but address has a symbol associated to it. This function
--   call will resolve to an external function.
operand_static_resolve :: Context -> Instr -> Maybe Operand -> ResolvedJumpTarget

-- | Resolves the first operand of a call or jump instruction. First tries
--   to see if the instruction is an indirection, that has already been
--   resolved. If not, try to statically resolve the first operand using
--   <tt><a>operand_static_resolve</a></tt>. If that resolves to an
--   external symbol <tt>libc_start_main</tt>, then this call is actually
--   an indirection (and thus currently unresolved). If that resolves to an
--   immediate value, see if that immediate value corresponds to an
--   external function or an internal function.
--   
--   Returns a list of <tt><a>ResolvedJumpTarget</a></tt>, since an
--   indirection may be resolved to multiple targets.
resolve_jump_target :: Context -> Instr -> [ResolvedJumpTarget]

-- | Given a resolved jump target, get a possibly empty list of internal
--   addresses to which the jump target can jump.
get_internal_addresses :: ResolvedJumpTarget -> [Int]

-- | Returns true iff the instruction resolves to external targets only.
instruction_jumps_to_external :: Context -> Instr -> Bool

-- | Shows the block associated to the givern blockID.
show_block :: CFG -> Int -> String

-- | Shows invariants.
show_invariants :: CFG -> Invariants -> String

-- | Tries to retrieve a function name with an entry address. If the entry
--   matches a known symbol, return that. Otherwise, simply return the
--   entry address itself in hexadecimal notation. However, there is one
--   exception: if the first instruction at the entry address immediately
--   jumps to an external function, return the name of that external
--   function instead. This happens in a <tt>.got</tt> section.
function_name_of_entry :: Context -> Int -> String

-- | Tries to retrieve a function name for a <tt>call</tt>-instruction (see
--   <tt><a>function_name_of_entry</a></tt>).
--   
--   Returns the empty string if the given instruction is not a call or a
--   jump.
function_name_of_instruction :: Context -> Instr -> String
instance GHC.Show.Show ControlFlow.ResolvedJumpTarget
instance GHC.Classes.Eq ControlFlow.ResolvedJumpTarget
instance SCC.IntGraph Context.CFG


-- | We assume a class where we can do predicate transformation through
--   function <tt>tau</tt>, and we can merge two predicates through
--   function <tt>join</tt>. Moreover, we assume an implementation of a
--   function <tt>implies</tt> that implements symbolic implication. Given
--   these functions, we provide a generic abstract interpretation
--   algorithm.
module Propagation

-- | A class that allows propagation of predicates over a CFG.
class (Show pred) => Propagator ctxt pred

-- | Predicate transformation for an edge in in a CFG, over a basic blocks.
tau :: Propagator ctxt pred => ctxt -> [Instr] -> Maybe [Instr] -> pred -> (pred, Set VerificationCondition)

-- | A lattice-join
join :: Propagator ctxt pred => ctxt -> pred -> pred -> pred

-- | Symbolic implication
implies :: Propagator ctxt pred => ctxt -> pred -> pred -> Bool

-- | Start propagation at the given entry address with the given initial
--   predicate. Returns a set of invariants, i.e., a mapping of instruction
--   addresses to predicates.
do_prop :: Propagator ctxt pred => ctxt -> CFG -> Int -> pred -> (IntMap pred, Set VerificationCondition)

-- | The supremum of a list of predicates
supremum :: Propagator ctxt pred => ctxt -> [pred] -> pred


module Pointers

-- | A <a>PointerBase</a> is a positive addend of a symbolic expression
--   that may represent a pointer. Retrieves the pointer bases from a
--   symbolic expression. They are either 1.) all known, or 2.) all
--   unknown.
get_pointer_bases :: Context -> SimpleExpr -> Set PointerBase

-- | Returns the set of known pointerbases, or the empty set if none.
get_known_pointer_bases :: Context -> SimpleExpr -> Set PointerBase

-- | Returns true if the expression has known pointerbases.
expr_highly_likely_pointer :: Context -> SimpleExpr -> Bool

-- | Returns true if the expression has a global pointerbase.
expr_is_global_pointer :: Context -> SimpleExpr -> Bool

-- | Returns true if the expression has a local pointerbase, and no others.
expr_is_highly_likely_local_pointer :: Context -> SimpleExpr -> Bool

-- | Returns true if the expression has a local pointerbase, but maybe
--   other pointerbases as well.
expr_is_possibly_local_pointer :: Context -> SimpleExpr -> Bool

-- | Returns true iff the expression is an immediate address falling into
--   the range of sections of the binary
expr_is_global_immediate :: Context -> SimpleExpr -> Bool

-- | Returns the set of sources (inputs used to compute the expression) of
--   an expression.
srcs_of_expr :: Context -> SimpleExpr -> Set BotSrc

-- | Returns the set of sources (state parts used to compute the
--   expression) of two expressions.
srcs_of_exprs :: Context -> [SimpleExpr] -> Set BotSrc

-- | Returns true iff the two given expressions have global pointerbases in
--   different segments/sections of the binary. We do not assume that such
--   pointers are separate, but do assert it.
pointers_from_different_global_section :: Context -> SimpleExpr -> SimpleExpr -> Bool

-- | Returns true iff the two given expressions can be shown to be
--   separate. This means that either: * They both have known pointerbases
--   that are assumed to be separate (see <a>pointer_bases_separate</a>). *
--   They both have sources that are all separate (see
--   <a>sources_separate</a>) * One of them is an immediate and the other
--   is local.
separate_pointer_domains :: Context -> SimpleExpr -> SimpleExpr -> Bool

-- | Given a set of expressions, produce an expression that resembles the
--   join of the entire set. That is, the produced expression should be
--   coarser than the disjunction of all input-expressions.
--   
--   <ol>
--   <li>First, just use non-determinism, i.e., <tt>a join b</tt> becomes
--   <tt>{a,b}</tt>. This is precise, but doesn't guarantee
--   termination.</li>
--   <li>If step 1 produces too many cases, join based on known
--   pointerbases. This requires all given expressions to have known
--   pointerbases.</li>
--   <li>If step 2 produces too many bases, or the given expressions have
--   no known pointerbases, join bsed on sources.</li>
--   <li>If step 3 produces too many sources, just produces
--   <a>rock_bottom</a>.</li>
--   </ol>
--   
--   TODO: joining immediates
join_exprs :: String -> Context -> [SimpleExpr] -> SimpleExpr

-- | Abstraction for a single expression, even if the expression is
--   concrete.
join_single :: Context -> SimpleExpr -> SimpleExpr

-- | Two pointerbases are separate if they refer to completely different
--   parts of the memory. We assume Stackframe, Global address space, and
--   Heap are separate. Two different <tt>malloc</tt>'s point to different
--   regions.
pointer_bases_separate :: PointerBase -> PointerBase -> Bool

-- | Two sources are inputs for separate pointers if, e.g., one of them is
--   the stackpointer and the other a malloc-return-value.
sources_separate :: BotSrc -> BotSrc -> Bool

-- | Returns true iff the given symbolic regions are necessarily equal. For
--   example: <tt>[RSP-16,4]</tt> is enclosed in <tt>[RSP-16,4]</tt>
--   
--   Will return <tt>False</tt> if the expressions contain bottom.
necessarily_equal :: SimpleExpr -> SimpleExpr -> Bool

-- | Returns true iff the given symbolic stateparts are necessarily equal.
necessarily_equal_stateparts :: StatePart -> StatePart -> Bool

-- | Returns true iff the given symbolic regions are ncessarily separate.
--   For example: <tt>[RSP-16,4]</tt> is separate from <tt>[RSP-12,8]</tt>
--   <tt>[RSP+8,4]</tt> is separate from <tt>[RSP,8]</tt>
--   
--   If none of the cases apply where it can be shjown arithmetically that
--   the expressions are separate, we check whether the expressions can be
--   proven separate based on their domains (see
--   <a>separate_pointer_domains</a>).
necessarily_separate :: (Ord a, Num a) => Context -> SimpleExpr -> a -> SimpleExpr -> a -> Bool

-- | Returns true iff the given symbolic stateparts are necessarily
--   separate.
necessarily_separate_stateparts :: Context -> StatePart -> StatePart -> Bool

-- | Returns true iff the given symbolic region is necessarily enclosed in
--   the other. For example: <tt>[RSP-16,4]</tt> is enclosed in
--   <tt>[RSP-18,8]</tt> <tt>[RSP+4,4]</tt> is enclosed in <tt>[RSP,8]</tt>
--   
--   Will return <tt>False</tt> if the expressions contain bottom.
necessarily_enclosed :: Integral a => SimpleExpr -> a -> SimpleExpr -> a -> Bool


-- | These functions are defined using the <tt>State (Pred,VCS)</tt> monad.
--   Both the read- and write function may update the current predicate, as
--   well as introduce new verification conditions.
module MachineState

-- | Read from a register
read_reg :: Context -> Register -> State (Pred, VCS) SimpleExpr

-- | Write to a register
write_reg :: Context -> Register -> SimpleExpr -> State (Pred, VCS) ()

-- | Read from memory
read_mem :: Context -> Address -> State (Pred, VCS) SimpleExpr

-- | Write to memory Each memory write is accomponied with a
--   <a>MemWriteIdentifier</a> so that we can log memory writes to unknown
--   locations.
write_mem :: Context -> MemWriteIdentifier -> SimpleExpr -> Int -> SimpleExpr -> State (Pred, VCS) ()

-- | Read from an operand of an instruction
read_operand :: Context -> Operand -> State (Pred, VCS) SimpleExpr

-- | Write to an operand of an instruction
write_operand :: Context -> Int -> Operand -> SimpleExpr -> State (Pred, VCS) ()

-- | Read from an statepart
read_sp :: Context -> StatePart -> State (Pred, VCS) SimpleExpr

-- | Write to a statepart
write_sp :: Context -> (StatePart -> MemWriteIdentifier) -> (StatePart, SimpleExpr) -> State (Pred, VCS) ()

-- | Returns true if a pointer is not suitable for writing to memory. This
--   may happen if the symbolic expression provides no information, i.e.,
--   it has <tt>Bottom</tt> without known pointerbases, and without any
--   sources.
invalid_bottom_pointer :: Context -> SimpleExpr -> Bool

-- | An address is considered "unwritable" only if it is an immediate
--   address that belongs to a section that is considered unwritable
--   according to Conventions (see <a>section_is_unwritable</a>)
address_is_unwritable :: Context -> SimpleExpr -> Bool

-- | Given the address of an operand of an instruction, resolve it given
--   the current state.
resolve_address :: Context -> Address -> State (Pred, VCS) SimpleExpr
instance GHC.Classes.Eq MachineState.SeparationStatus


module SymbolicExecution

-- | Do predicate transformation over a basic block in a CFG. Given an edge
--   in the CFG from none block to another, perform predicate
--   transformation. Parameter insts' is needed to set the flags properly.
--   If <tt>Nothing</tt> is supplied, the flags are overapproximatively set
--   to <tt><a>None</a></tt>.
tau_block :: Context -> [Instr] -> Maybe [Instr] -> Pred -> (Pred, VCS)

-- | The initial predicate.
init_pred :: Invariants -> Set (NodeInfo, Pred) -> FInit -> Pred

-- | Given the currently known invariants and postconditions, gather all
--   stateparts occurring in the current function.
gather_stateparts :: Invariants -> Set (NodeInfo, Pred) -> Set StatePart

-- | Convert the current invariant into a function initialisation
invariant_to_finit :: Context -> Pred -> FInit

-- | The join between two function initialisations
weaken_finit :: Context -> FInit -> FInit -> FInit

-- | Get the invariant for a given instruction address for a given function
--   entry
get_invariant :: Context -> Int -> Int -> Maybe Pred
instance Propagation.Propagator Context.Context SimplePred.Pred


module CFG_Gen

-- | Produce a CFG
--   
--   Given the entry point of the function, generate either a CFG, or a set
--   of new entry points to be analyzed first. The set of new entry points
--   are function entries called by the current function, but for which we
--   do not know yet whether they terminate or not. If a CFG is returned,
--   then all function calls in that CFG have already been analyzed.
cfg_gen :: Context -> Int -> IO (Set (Instr, Int), CFG)

-- | Export a CFG to .dot file
--   
--   Strongly connected components get the same color.
cfg_to_dot :: Context -> CFG -> String

-- | Returns true if the given blockID is a leaf-node in the given CFG.
is_end_node :: CFG -> Int -> Bool

-- | Returns the <tt><a>NodeInfo</a></tt> of a given blockID.
--   
--   Assumes the given blockID corresponds to a leaf-node.
node_info_of :: Context -> CFG -> Int -> NodeInfo

-- | An abstract step function
--   
--   Given the entry address of the function currently under investigation,
--   and the instruction address of the current instruction, try to get the
--   set of next instruction addresses.
--   
--   This returns either: * a set of tuples <tt>(i,a)</tt> where <tt>i</tt>
--   is an instruction and <tt>a</tt> its address. All these instructions
--   are function calls that need to be analyzed before this current
--   function entry can continue. * a list of tuples <tt>(a,b)</tt> where
--   <tt>a</tt> is an instruction address that may follow the current
--   instruction, and <tt>b</tt> is a Bool indicating whether that address
--   belongs to a <tt>call</tt>
stepA :: Context -> Int -> Int -> IO (Either (Set (Instr, Int)) [(Int, Bool)])


-- | The interface to the <tt>.report</tt> generated after running FoxDec.
--   After running FoxDec, a "verification report" (an object of type
--   <tt><a>Context</a></tt>) can be retrieved from the generated .report
--   file (see function <tt>ctxt_read_report</tt>). Essentially, this
--   module provides hooks into some of the information retrieved and
--   derived from the binary, including instructions, invariants, function
--   entry points, etc.
--   
--   A verification report is represented by the type
--   <tt><a>Context</a></tt>, as internally it is just the context passed
--   around and maintained during verification.
--   
--   The main flow is to read the .report file and use these functions to
--   retrieve information. The following example reads in a .report file
--   provided as first command-line parameter and outputs the function
--   entries:
--   
--   <pre>
--   main = do
--     args &lt;- getArgs
--     ctxt &lt;- ctxt_read_report $ head args
--     putStrLn $ show $ ctxt_get_function_entries ctxt
--   </pre>
--   
--   Some of the information is automatically also exported in plain-text
--   format, for easy access.
module VerificationReportInterface

-- | The return type when retrieving information from a verification
--   report: either an error message or a result.
type Retrieve a = Context -> Either String a

-- | Function Entries are simply integers
type FunctionEntry = Int

-- | Instruction Addresses are simply integers
type InstructionAddress = Int

-- | Read in the .report file from a file with the given file name. May
--   produce an error if no report can be read from the file. Returns the
--   verification report stored in the .report file.
ctxt_read_report :: String -> IO Context

-- | Retrieve information from a <tt><a>Context</a></tt> read from a
--   .report file, or die with an error message. For example:
--   
--   <pre>
--   do
--     ctxt &lt;- ctxt_read_report filename
--     retrieve_io $ ctxt_get_instruction a ctxt
--   </pre>
--   
--   This code reads in a .report file with the given <tt>filename</tt>,
--   and reads the instruction at address <tt>a</tt> if any.
retrieve_io :: Either String a -> IO a

-- | Retrieve all function entries.
--   
--   Returns a set of funtion entries.
ctxt_get_function_entries :: Retrieve (Set FunctionEntry)

-- | Retrieve all instruction addresses.
--   
--   Returns a set of instruction addresses.
ctxt_get_instruction_addresses :: Retrieve (Set InstructionAddress)

-- | Retrieve all indirections
--   
--   Returns a mapping that provides for some instruction addresses a set
--   of jump targets.
ctxt_get_indirections :: Retrieve Indirections

-- | Retrieve instruction for a given instruction address, both as
--   datastructure and pretty-printed
ctxt_get_instruction :: InstructionAddress -> Retrieve (Instr, String)

-- | Retrieve invariant for a given function entry and instruction address
--   
--   An invariant is a predicate provding information over registers,
--   memory, flags, and verification conditions.
ctxt_get_invariant :: FunctionEntry -> InstructionAddress -> Retrieve Pred

-- | Retrieve all internal function calls for a given function entry
--   
--   Returns a set of function entries.
ctxt_get_internal_function_calls :: FunctionEntry -> Retrieve (Set FunctionEntry)

-- | Retrieve a CFG for a given function entry
ctxt_get_cfg :: FunctionEntry -> Retrieve CFG
