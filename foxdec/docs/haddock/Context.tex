\haddockmoduleheading{Context}
\label{module:Context}
\haddockbeginheader
{\haddockverb\begin{verbatim}
module Context (
    CFG(CFG,
        cfg_instrs,
        cfg_fresh,
        cfg_addr_to_blockID,
        cfg_edges,
        cfg_blocks),
    Indirections, SectionsInfo,
    VerificationResult(Unverified,
                       VerificationError,
                       VerificationUnresolvedIndirection,
                       VerificationSuccesWithAssumptions,
                       VerificationSuccess),
    Invariants, NodeInfo(Terminal, UnresolvedIndirection, Normal),
    Postconditions,
    MemWriteIdentifier(MemWriteInstruction, MemWriteFunction),
    VerificationCondition(SourcelessMemWrite,
                          FunctionConstraint,
                          Assertion,
                          Precondition),
    VCS, FInit,
    FReturnBehavior(UnknownRetBehavior, ReturningWith, Terminating),
    Context(Context,
            ctxt_recursions,
            ctxt_results,
            ctxt_vcs,
            ctxt_finits,
            ctxt_inds,
            ctxt_posts,
            ctxt_invs,
            ctxt_calls,
            ctxt_cfgs,
            ctxt_entries,
            ctxt_generate_pdfs,
            ctxt_name,
            ctxt_dirname,
            ctxt_sections,
            ctxt_syms,
            ctxt_dump),
    read_from_datasection, find_section_for_address, fetch_instruction,
    pp_instruction, show_finit, is_assertion, is_precondition,
    is_func_constraint, is_sourceless_memwrite,
    count_instructions_with_assertions, count_sourceless_memwrites
  ) where\end{verbatim}}
\haddockendheader

The context stores, among others, information obtained during verification, such as CFGs, invariants, etc. (see \haddocktt{\haddockid{Context}}).
Module \haddocktt{VerificationReportInterface} provides functions for obtaining and interfacing with a \haddocktt{Context}.\par
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data CFG
\end{tabular}]
{\haddockbegindoc
A control flow graph with blocks and edges.
 A blockID (represented as an \haddocktt{Int}) is a unique identifier of a basic block.
 We store basic blocks twice: once as addresses, and once as instructions.\par
\enspace \emph{Constructors}\par
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{CFG} & \\
                                          & \haddocktt{\qquad \{} \haddockdecltt{cfg{\char '137}blocks :: IntMap {\char 91}Int{\char 93}} & A mapping of blockIDs to instruction addresses \\
                                          & \haddocktt{\qquad ,} \haddockdecltt{cfg{\char '137}edges :: IntMap IntSet} & A mapping of blockIDs to sets of blocKIDs \\
                                          & \haddocktt{\qquad ,} \haddockdecltt{cfg{\char '137}addr{\char '137}to{\char '137}blockID :: IntMap Int} & A mapping of instruction addresses to blockIDs \\
                                          & \haddocktt{\qquad ,} \haddockdecltt{cfg{\char '137}fresh :: Int} & A fresh blockID \\
                                          & \haddocktt{\qquad ,} \haddockdecltt{cfg{\char '137}instrs :: IntMap {\char 91}Instr{\char 93}} & A mapping of blockIDs to lists of disassembled instructions. \\ & \haddocktt{\qquad \}} \\
\end{tabulary}\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance Eq CFG\\instance Show CFG\\instance Generic CFG\\instance Serialize CFG\\type instance Rep CFG = D1 ('MetaData "CFG" "Context" "foxdec-0.1.0.0-GvYex2zEKVAHx5Xds2Usdj" 'False) (C1 ('MetaCons "CFG" 'PrefixI 'True) ((S1 ('MetaSel ('Just "cfg{\char '137}blocks") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 (IntMap {\char 91}Int{\char 93})) :*: S1 ('MetaSel ('Just "cfg{\char '137}edges") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 (IntMap IntSet))) :*: (S1 ('MetaSel ('Just "cfg{\char '137}addr{\char '137}to{\char '137}blockID") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 (IntMap Int)) :*: (S1 ('MetaSel ('Just "cfg{\char '137}fresh") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 Int) :*: S1 ('MetaSel ('Just "cfg{\char '137}instrs") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 (IntMap {\char 91}Instr{\char 93}))))))
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
type Indirections = IntMap IntSet
\end{tabular}]
{\haddockbegindoc
Per instruction address, a set of jump targets.\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
type SectionsInfo = {\char 91}(String, String, Int, Int){\char 93}
\end{tabular}]
{\haddockbegindoc
Sections: segment names, section names, addresses and sizes. \par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data VerificationResult
\end{tabular}]
{\haddockbegindoc
An enumeration indicating the result of verification over a function\par
\enspace \emph{Constructors}\par
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{VerificationSuccess} & Function was succesfully verified \\
\haddockdecltt{|} & \haddockdecltt{VerificationSuccesWithAssumptions} & Function was succesfully verified, but required assertions \\
\haddockdecltt{|} & \haddockdecltt{VerificationUnresolvedIndirection} & Function contains an unresolved indirection \\
\haddockdecltt{|} & \haddockdecltt{VerificationError String} & There was some verification error, e.g., return adresss overwrite \\
\haddockdecltt{|} & \haddockdecltt{Unverified} & The function has not been verified. \\
\end{tabulary}\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance Eq VerificationResult\\instance Show VerificationResult\\instance Generic VerificationResult\\instance Serialize VerificationResult\\type instance Rep VerificationResult = D1 ('MetaData "VerificationResult" "Context" "foxdec-0.1.0.0-GvYex2zEKVAHx5Xds2Usdj" 'False) ((C1 ('MetaCons "VerificationSuccess" 'PrefixI 'False) (U1 :: Type\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -> Type) :+: C1 ('MetaCons "VerificationSuccesWithAssumptions" 'PrefixI 'False) (U1 :: Type\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -> Type)) :+: (C1 ('MetaCons "VerificationUnresolvedIndirection" 'PrefixI 'False) (U1 :: Type\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -> Type) :+: (C1 ('MetaCons "VerificationError" 'PrefixI 'False) (S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 String)) :+: C1 ('MetaCons "Unverified" 'PrefixI 'False) (U1 :: Type\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -> Type))))
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
type Invariants = IntMap Pred
\end{tabular}]
{\haddockbegindoc
Invariants: a mapping of blockIDs to predicates\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data NodeInfo
\end{tabular}]
{\haddockbegindoc
For each leaf-node in a CFG we store the following info.\par
\enspace \emph{Constructors}\par
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{Normal} & The basic block behaves normally, e.g., a ret \\
\haddockdecltt{|} & \haddockdecltt{UnresolvedIndirection} & The basic block ends in an unresolved indirection \\
\haddockdecltt{|} & \haddockdecltt{Terminal} & The basic blocks ends with, e.g., a call to exit() \\
\end{tabulary}\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance Eq NodeInfo\\instance Ord NodeInfo\\instance Show NodeInfo\\instance Generic NodeInfo\\instance Serialize NodeInfo\\type instance Rep NodeInfo = D1 ('MetaData "NodeInfo" "Context" "foxdec-0.1.0.0-GvYex2zEKVAHx5Xds2Usdj" 'False) (C1 ('MetaCons "Normal" 'PrefixI 'False) (U1 :: Type\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -> Type) :+: (C1 ('MetaCons "UnresolvedIndirection" 'PrefixI 'False) (U1 :: Type\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -> Type) :+: C1 ('MetaCons "Terminal" 'PrefixI 'False) (U1 :: Type\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -> Type)))
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
type Postconditions = Set (NodeInfo, Pred)
\end{tabular}]
{\haddockbegindoc
Postconditions: for each final block the \haddocktt{NodeInfo} and the final predicate after execution of the block\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data MemWriteIdentifier
\end{tabular}]
{\haddockbegindoc
Identifies where a memwrite occurred\par
\enspace \emph{Constructors}\par
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{MemWriteFunction String Int StatePart} & A function with \haddocktt{name} at address \haddocktt{i{\char '137}a} wrote to a statepart \\
\haddockdecltt{|} & \haddockdecltt{MemWriteInstruction Int Address SimpleExpr} & An instruction wrote to an operand, resolving to an address \\
\end{tabulary}\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance Eq MemWriteIdentifier\\instance Ord MemWriteIdentifier\\instance Show MemWriteIdentifier\\instance Generic MemWriteIdentifier\\instance Serialize MemWriteIdentifier\\type instance Rep MemWriteIdentifier = D1 ('MetaData "MemWriteIdentifier" "Context" "foxdec-0.1.0.0-GvYex2zEKVAHx5Xds2Usdj" 'False) (C1 ('MetaCons "MemWriteFunction" 'PrefixI 'False) (S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 String) :*: (S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 Int) :*: S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 StatePart))) :+: C1 ('MetaCons "MemWriteInstruction" 'PrefixI 'False) (S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 Int) :*: (S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 Address) :*: S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 SimpleExpr))))
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data VerificationCondition
\end{tabular}]
{\haddockbegindoc
A verification condition is either:
 * A precondition of the form:
 >    Precondition (a0,si0) (a1,si1)
 This formulates that at the initial state the two regions must be separate.
 * An assertion of the form:
 >    Assertion a (a0,si0) (a1,si1)
 This formulates that dynamically, whenever address a is executed, the two regions are asserted to be separate.
 * A function constraint of the form:
 >    FunctionConstraint foo {\char 91}(RDI, v0), (RSI, v1), ...{\char 93}   {\char '173} sp0,sp1,... {\char '175}
 This formulates that a function call to function foo with values v0, v1, ... stored in the registers should not overwrite certain state parts.\par
\enspace \emph{Constructors}\par
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{Precondition SimpleExpr Int SimpleExpr Int} & Precondition:           lhs SEP rhs \\
\haddockdecltt{|} & \haddockdecltt{Assertion SimpleExpr SimpleExpr Int SimpleExpr Int} & Assertion:    @address, lhs SEP rhs \\
\haddockdecltt{|} & \haddockdecltt{FunctionConstraint String Int {\char 91}(Register, SimpleExpr){\char 93} (Set StatePart)} & Function name, address, of call, with param registers \\
\haddockdecltt{|} & \haddockdecltt{SourcelessMemWrite MemWriteIdentifier} & A memory write for which no information was available \\
\end{tabulary}\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance Eq VerificationCondition\\instance Ord VerificationCondition\\instance Show VerificationCondition\\instance Generic VerificationCondition\\instance Serialize VerificationCondition\\type instance Rep VerificationCondition = D1 ('MetaData "VerificationCondition" "Context" "foxdec-0.1.0.0-GvYex2zEKVAHx5Xds2Usdj" 'False) ((C1 ('MetaCons "Precondition" 'PrefixI 'False) ((S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 SimpleExpr) :*: S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 Int)) :*: (S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 SimpleExpr) :*: S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 Int))) :+: C1 ('MetaCons "Assertion" 'PrefixI 'False) ((S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 SimpleExpr) :*: S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 SimpleExpr)) :*: (S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 Int) :*: (S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 SimpleExpr) :*: S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 Int))))) :+: (C1 ('MetaCons "FunctionConstraint" 'PrefixI 'False) ((S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 String) :*: S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 Int)) :*: (S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 {\char 91}(Register, SimpleExpr){\char 93}) :*: S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 (Set StatePart)))) :+: C1 ('MetaCons "SourcelessMemWrite" 'PrefixI 'False) (S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 MemWriteIdentifier))))
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
type VCS = Set VerificationCondition
\end{tabular}]
{\haddockbegindoc
An acornym for a set of verification conditions\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
type FInit = Map StatePart SimpleExpr
\end{tabular}]
{\haddockbegindoc
A function initialisation consists of a mapping of stateparts to expressions.\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data FReturnBehavior
\end{tabular}]
{\haddockbegindoc
A function call \par
\enspace \emph{Constructors}\par
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{Terminating} & The function does never return \\
\haddockdecltt{|} & \haddockdecltt{ReturningWith Pred} & The function returns withg the symbolic changes stored in the predicate \\
\haddockdecltt{|} & \haddockdecltt{UnknownRetBehavior} & It is unknown whether the function returns or not \\
\end{tabulary}\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance Eq FReturnBehavior\\instance Ord FReturnBehavior\\instance Show FReturnBehavior\\instance Generic FReturnBehavior\\instance Serialize FReturnBehavior\\type instance Rep FReturnBehavior = D1 ('MetaData "FReturnBehavior" "Context" "foxdec-0.1.0.0-GvYex2zEKVAHx5Xds2Usdj" 'False) (C1 ('MetaCons "Terminating" 'PrefixI 'False) (U1 :: Type\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -> Type) :+: (C1 ('MetaCons "ReturningWith" 'PrefixI 'False) (S1 ('MetaSel ('Nothing :: Maybe Symbol) 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 Pred)) :+: C1 ('MetaCons "UnknownRetBehavior" 'PrefixI 'False) (U1 :: Type\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -> Type)))
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data Context
\end{tabular}]
{\haddockbegindoc
The context datastructure.\par
\textbf{S}: Information \textbf{S}tatically obtained by reading from the binary\par
\textbf{D}: Information \textbf{D}ynamically updated during verification\par
\enspace \emph{Constructors}\par
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{Context} & \\
                                              & \haddocktt{\qquad \{} \haddockdecltt{ctxt{\char '137}dump :: IntMap Word8} & \textbf{S}: mapping from addresses to bytes (data and instructions from the binary/executable) \\
                                              & \haddocktt{\qquad ,} \haddockdecltt{ctxt{\char '137}syms :: IntMap String} & \textbf{S}: the symbol table: a mapping of addresses to function names for external functions \\
                                              & \haddocktt{\qquad ,} \haddockdecltt{ctxt{\char '137}sections :: SectionsInfo} & \textbf{S}: information on segments/section \\
                                              & \haddocktt{\qquad ,} \haddockdecltt{ctxt{\char '137}dirname :: String} & \textbf{S}: the name of the directory where the .dump, .entry, .sections and .symbols files reside \\
                                              & \haddocktt{\qquad ,} \haddockdecltt{ctxt{\char '137}name :: String} & \textbf{S}: the name of the binary \\
                                              & \haddocktt{\qquad ,} \haddockdecltt{ctxt{\char '137}generate{\char '137}pdfs :: Bool} & \textbf{S}: do we call graphviz to generate PDFs from .dot files? \\
                                              & \haddocktt{\qquad ,} \haddockdecltt{ctxt{\char '137}entries :: Graph} & \textbf{D}: a graph with an edge (e0,e1) if entry address e0 calls entry address e1, and e0 and e1 have not been verified yet \\
                                              & \haddocktt{\qquad ,} \haddockdecltt{ctxt{\char '137}cfgs :: IntMap CFG} & \textbf{D}: the currently known control flow graphs per function entry \\
                                              & \haddocktt{\qquad ,} \haddockdecltt{ctxt{\char '137}calls :: IntMap FReturnBehavior} & \textbf{D}: the currently known and verified entry addresses of functions mapped to return-information \\
                                              & \haddocktt{\qquad ,} \haddockdecltt{ctxt{\char '137}invs :: IntMap Invariants} & \textbf{D}: the currently known invariants \\
                                              & \haddocktt{\qquad ,} \haddockdecltt{ctxt{\char '137}posts :: IntMap Postconditions} & \textbf{D}: the currently known postconditions \\
                                              & \haddocktt{\qquad ,} \haddockdecltt{ctxt{\char '137}inds :: Indirections} & \textbf{D}: the currently known indirections \\
                                              & \haddocktt{\qquad ,} \haddockdecltt{ctxt{\char '137}finits :: IntMap FInit} & \textbf{D}: the currently known function initialisations \\
                                              & \haddocktt{\qquad ,} \haddockdecltt{ctxt{\char '137}vcs :: IntMap VCS} & \textbf{D}: the verification conditions \\
                                              & \haddocktt{\qquad ,} \haddockdecltt{ctxt{\char '137}results :: IntMap VerificationResult} & \textbf{D}: the verification result \\
                                              & \haddocktt{\qquad ,} \haddockdecltt{ctxt{\char '137}recursions :: IntMap IntSet} & \\ & \haddocktt{\qquad \}} \\
\end{tabulary}\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance Generic Context\\instance Serialize Context\\instance Propagator Context Pred\\type instance Rep Context = D1 ('MetaData "Context" "Context" "foxdec-0.1.0.0-GvYex2zEKVAHx5Xds2Usdj" 'False) (C1 ('MetaCons "Context" 'PrefixI 'True) ((((S1 ('MetaSel ('Just "ctxt{\char '137}dump") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 (IntMap Word8)) :*: S1 ('MetaSel ('Just "ctxt{\char '137}syms") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 (IntMap String))) :*: (S1 ('MetaSel ('Just "ctxt{\char '137}sections") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 SectionsInfo) :*: S1 ('MetaSel ('Just "ctxt{\char '137}dirname") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 String))) :*: ((S1 ('MetaSel ('Just "ctxt{\char '137}name") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 String) :*: S1 ('MetaSel ('Just "ctxt{\char '137}generate{\char '137}pdfs") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 Bool)) :*: (S1 ('MetaSel ('Just "ctxt{\char '137}entries") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 Graph) :*: S1 ('MetaSel ('Just "ctxt{\char '137}cfgs") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 (IntMap CFG))))) :*: (((S1 ('MetaSel ('Just "ctxt{\char '137}calls") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 (IntMap FReturnBehavior)) :*: S1 ('MetaSel ('Just "ctxt{\char '137}invs") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 (IntMap Invariants))) :*: (S1 ('MetaSel ('Just "ctxt{\char '137}posts") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 (IntMap Postconditions)) :*: S1 ('MetaSel ('Just "ctxt{\char '137}inds") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 Indirections))) :*: ((S1 ('MetaSel ('Just "ctxt{\char '137}finits") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 (IntMap FInit)) :*: S1 ('MetaSel ('Just "ctxt{\char '137}vcs") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 (IntMap VCS))) :*: (S1 ('MetaSel ('Just "ctxt{\char '137}results") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 (IntMap VerificationResult)) :*: S1 ('MetaSel ('Just "ctxt{\char '137}recursions") 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedStrict) (Rec0 (IntMap IntSet)))))))
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
read{\char '137}from{\char '137}datasection
\end{tabular}]
{\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{Context} & The context  \\
\haddockdecltt{->} & \haddockdecltt{Word64} & An address \\
\haddockdecltt{->} & \haddockdecltt{Int} & Size, i.e., the number of bytes to read \\
\haddockdecltt{->} & \haddockdecltt{Maybe Word64} & \\
\end{tabulary}\par
Reading from a data section.\par
Reads maximally up to 8 bytes. Returns \haddocktt{Nothing} if the given address is out-of-range.\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
find{\char '137}section{\char '137}for{\char '137}address
\end{tabular}]
{\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{Context} & The context \\
\haddockdecltt{->} & \haddockdecltt{Int} & An address \\
\haddockdecltt{->} & \haddockdecltt{Maybe (String, String, Int, Int)} & \\
\end{tabulary}\par
Find a section for an address (see \haddocktt{\haddockid{SectionsInfo}})\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
fetch{\char '137}instruction
\end{tabular}]
{\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{Context} & The context \\
\haddockdecltt{->} & \haddockdecltt{Int} & An address \\
\haddockdecltt{->} & \haddockdecltt{IO (Maybe Instr)} & \\
\end{tabulary}\par
Fetching an instruction\par
Returns \haddocktt{Nothing} if the given address is out-of-range.\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
pp{\char '137}instruction
\end{tabular}]
{\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{Context} & The context \\
\haddockdecltt{->} & \haddockdecltt{Instr} & An instruction \\
\haddockdecltt{->} & \haddockdecltt{String} & \\
\end{tabulary}\par
Pretty printing an instruction\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
show{\char '137}finit :: FInit -> String
\end{tabular}]
{\haddockbegindoc
Show function initialisation\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
is{\char '137}assertion :: VerificationCondition -> Bool
\end{tabular}]
{\haddockbegindoc
Is the given verification condition an assertion?\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
is{\char '137}precondition :: VerificationCondition -> Bool
\end{tabular}]
{\haddockbegindoc
Is the given verification condition a precondition?\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
is{\char '137}func{\char '137}constraint :: VerificationCondition -> Bool
\end{tabular}]
{\haddockbegindoc
Is the given verification condition a function constraint?\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
is{\char '137}sourceless{\char '137}memwrite :: VerificationCondition -> Bool
\end{tabular}]
{\haddockbegindoc
Is the given verification condition a sourceless memwrite?\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
count{\char '137}instructions{\char '137}with{\char '137}assertions :: Set VerificationCondition -> Int
\end{tabular}]
{\haddockbegindoc
Count the number of assertions in the set of verification conditions.\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
count{\char '137}sourceless{\char '137}memwrites :: Set VerificationCondition -> Int
\end{tabular}]
{\haddockbegindoc
Count the number of sourceless memory writes in the set of verification conditions.\par}
\end{haddockdesc}