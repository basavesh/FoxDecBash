\haddockmoduleheading{MachineState}
\label{module:MachineState}
\haddockbeginheader
{\haddockverb\begin{verbatim}
module MachineState (
    read_reg, write_reg, read_mem, write_mem, read_operand,
    write_operand, read_sp, write_sp, invalid_bottom_pointer,
    address_is_unwritable, resolve_address
  ) where\end{verbatim}}
\haddockendheader

These functions are defined using the \haddocktt{State (Pred,VCS)} monad.
Both the read- and write function may update the current predicate, as well as introduce new verification conditions.\par
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
read{\char '137}reg :: Context -> Register -> State (Pred, VCS) SimpleExpr
\end{tabular}]
{\haddockbegindoc
Read from a register\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
write{\char '137}reg :: Context -> Register -> SimpleExpr -> State (Pred, VCS) ()
\end{tabular}]
{\haddockbegindoc
Write to a register\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
read{\char '137}mem
\end{tabular}]
{\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{Context} & The context \\
\haddockdecltt{->} & \haddockdecltt{FInit} & The function initialisation \\
\haddockdecltt{->} & \haddockdecltt{Address} & The address of an operand of an instruction \\
\haddockdecltt{->} & \haddockdecltt{State (Pred, VCS) SimpleExpr} & \\
\end{tabulary}\par
Read from memory\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
write{\char '137}mem
\end{tabular}]
{\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{Context} & The context \\
\haddockdecltt{->} & \haddockdecltt{FInit} & The function initialization \\
\haddockdecltt{->} & \haddockdecltt{MemWriteIdentifier} & An identifier where the write occurs \\
\haddockdecltt{->} & \haddockdecltt{SimpleExpr} & The symbolic address \\
\haddockdecltt{->} & \haddockdecltt{Int} & The size (in bytes) \\
\haddockdecltt{->} & \haddockdecltt{SimpleExpr} & The value to be written \\
\haddockdecltt{->} & \haddockdecltt{State (Pred, VCS) ()} & \\
\end{tabulary}\par
Write to memory
 Each memory write is accomponied with a \haddockid{MemWriteIdentifier} so that we can log memory writes to unknown locations.\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
read{\char '137}operand :: Context -> FInit -> Operand -> State (Pred, VCS) SimpleExpr
\end{tabular}]
{\haddockbegindoc
Read from an operand of an instruction\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
write{\char '137}operand
\end{tabular}]
{\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{Context} & The context \\
\haddockdecltt{->} & \haddockdecltt{FInit} & The function initialization \\
\haddockdecltt{->} & \haddockdecltt{Int} & The address of the instruction, used to build a \haddockid{MemWriteIdentifier} \\
\haddockdecltt{->} & \haddockdecltt{Operand} & The operand \\
\haddockdecltt{->} & \haddockdecltt{SimpleExpr} & The value to be written \\
\haddockdecltt{->} & \haddockdecltt{State (Pred, VCS) ()} & \\
\end{tabulary}\par
Write to an operand of an instructiofinit{\char '137}of{\char '137}entryn\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
read{\char '137}sp :: Context -> FInit -> StatePart -> State (Pred, VCS) SimpleExpr
\end{tabular}]
{\haddockbegindoc
Read from an statepart\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
write{\char '137}sp
\end{tabular}]
{\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{Context} & The context \\
\haddockdecltt{->} & \haddockdecltt{FInit} & The function initialization \\
\haddockdecltt{->} & \haddockdecltt{(StatePart -> MemWriteIdentifier)} & \\
\haddockdecltt{->} & \haddockdecltt{(StatePart, SimpleExpr)} & \\
\haddockdecltt{->} & \haddockdecltt{State (Pred, VCS) ()} & \\
\end{tabulary}\par
Write to a statepart\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
invalid{\char '137}bottom{\char '137}pointer :: Context -> SimpleExpr -> Bool
\end{tabular}]
{\haddockbegindoc
Returns true if a pointer is not suitable for writing to memory.
 This may happen if the symbolic expression provides no information, i.e., it has \haddocktt{Bottom} without known pointerbases,
 and without any sources.\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
address{\char '137}is{\char '137}unwritable :: Context -> SimpleExpr -> Bool
\end{tabular}]
{\haddockbegindoc
An address is considered "unwritable" only if it is an immediate address that belongs to a section that is considered unwritable
 according to Conventions (see \haddockid{section{\char '137}is{\char '137}unwritable})\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
resolve{\char '137}address :: Context -> Address -> State (Pred, VCS) SimpleExpr
\end{tabular}]
{\haddockbegindoc
Given the address of an operand of an instruction, resolve it given the current state.\par}
\end{haddockdesc}