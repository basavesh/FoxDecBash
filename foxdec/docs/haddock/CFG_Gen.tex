\haddockmoduleheading{CFG_Gen}
\label{module:CFG_Gen}
\haddockbeginheader
{\haddockverb\begin{verbatim}
module CFG_Gen (
    cfg_gen, cfg_to_dot, is_end_node, node_info_of, stepA
  ) where\end{verbatim}}
\haddockendheader

\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
cfg{\char '137}gen
\end{tabular}]
{\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{Context} & The context \\
\haddockdecltt{->} & \haddockdecltt{Int} & The entry point of the function \\
\haddockdecltt{->} & \haddockdecltt{IO (Set (Instr, Int), CFG)} & \\
\end{tabulary}\par
Produce a CFG\par
Given the entry point of the function, generate either a CFG, or a set of new entry points to be analyzed first.
 The set of new entry points are function entries called by the current function, but for which we do not know yet whether they terminate or not.
 If a CFG is returned, then all function calls in that CFG have already been analyzed.\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
cfg{\char '137}to{\char '137}dot
\end{tabular}]
{\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{Context} & The context \\
\haddockdecltt{->} & \haddockdecltt{CFG} & The CFG \\
\haddockdecltt{->} & \haddockdecltt{String} & \\
\end{tabulary}\par
Export a CFG to .dot file\par
Strongly connected components get the same color.\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
is{\char '137}end{\char '137}node
\end{tabular}]
{\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{CFG} & The CFG \\
\haddockdecltt{->} & \haddockdecltt{Int} & The blockID \\
\haddockdecltt{->} & \haddockdecltt{Bool} & \\
\end{tabulary}\par
Returns true if the given blockID is a leaf-node in the given CFG.\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
node{\char '137}info{\char '137}of :: Context -> CFG -> Int -> NodeInfo
\end{tabular}]
{\haddockbegindoc
Returns the \haddocktt{\haddockid{NodeInfo}} of a given blockID.\par
Assumes the given blockID corresponds to a leaf-node.\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
stepA
\end{tabular}]
{\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{Context} & The context \\
\haddockdecltt{->} & \haddockdecltt{Int} & The entry address \\
\haddockdecltt{->} & \haddockdecltt{Int} & The instruction address \\
\haddockdecltt{->} & \haddockdecltt{IO (Either (Set (Instr, Int)) {\char 91}(Int, Bool){\char 93})} & \\
\end{tabulary}\par
An abstract step function\par
Given the entry address of the function currently under investigation, and the instruction address of the current instruction,
 try to get the set of next instruction addresses.\par
This returns either:
   * a set of tuples \haddocktt{(i,a)} where \haddocktt{i} is an instruction and \haddocktt{a} its address. All these instructions are function calls that need to be analyzed before this current function entry can continue.
   * a list of tuples \haddocktt{(a,b)} where \haddocktt{a} is an instruction address that may follow the current instruction, and \haddocktt{b} is a Bool indicating whether that address belongs to a \haddocktt{call}\par
TODO the Lefts are ignored so need no to return them\par}
\end{haddockdesc}