\haddockmoduleheading{ControlFlow}
\label{module:ControlFlow}
\haddockbeginheader
{\haddockverb\begin{verbatim}
module ControlFlow (
    ResolvedJumpTarget(Unresolved, External, ImmediateAddress),
    post, fetch_block, address_has_instruction, address_has_symbol,
    address_is_external, operand_static_resolve, resolve_jump_target,
    get_internal_addresses, instruction_jumps_to_external, show_block,
    show_invariants, function_name_of_entry,
    function_name_of_instruction
  ) where\end{verbatim}}
\haddockendheader

Contains function relating to control flow, including functions for
resolving the targets of jumps and calls.\par
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data ResolvedJumpTarget
\end{tabular}]
{\haddockbegindoc
Resolving the operand of a jump/call can produce one of the following.\par
\enspace \emph{Constructors}\par
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{Unresolved} & An indirect branch that has not been resolved yet \\
\haddockdecltt{|} & \haddockdecltt{External String} & A call to external function f \\
\haddockdecltt{|} & \haddockdecltt{ImmediateAddress Word64} & An internal call to the given address \\
\end{tabulary}\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance Eq ResolvedJumpTarget\\instance Show ResolvedJumpTarget
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
post :: CFG -> Key -> IntSet
\end{tabular}]
{\haddockbegindoc
The set of next blocks from the given block in a CFG\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
fetch{\char '137}block
\end{tabular}]
{\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{CFG} & The CFG \\
\haddockdecltt{->} & \haddockdecltt{Int} & The blockID \\
\haddockdecltt{->} & \haddockdecltt{{\char 91}Instr{\char 93}} & \\
\end{tabulary}\par
Fetching an instruction list given a block ID\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
address{\char '137}has{\char '137}instruction :: Integral a => Context -> a -> Bool
\end{tabular}]
{\haddockbegindoc
Returns true iff an instruction can be fetched from the address.\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
address{\char '137}has{\char '137}symbol :: Integral a => Context -> a -> Bool
\end{tabular}]
{\haddockbegindoc
Returns true iff a symbol is associated with the address.\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
address{\char '137}is{\char '137}external :: Integral a => Context -> a -> Bool
\end{tabular}]
{\haddockbegindoc
Returns truee if the adress is external, i.e., has no instruction or has a symbol.\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
operand{\char '137}static{\char '137}resolve
\end{tabular}]
{\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{Context} & The context \\
\haddockdecltt{->} & \haddockdecltt{Instr} & The instruction \\
\haddockdecltt{->} & \haddockdecltt{Maybe Operand} & The operand of the instruction to be resolved \\
\haddockdecltt{->} & \haddockdecltt{ResolvedJumpTarget} & \\
\end{tabulary}\par
many operands can statically be resolved, even though technically they are indirect (relative to RIP).
 Examples:\par
\haddocktt{10005464e: call RIP + 1751660} resolves to an immediate jump target by resolving the RIP-relative addressing.\par
\haddocktt{10005464e: call qword ptr {\char 91}RIP + 1751660{\char 93}} read from address 1002000c0, but address has a symbol associated to it. This function call will resolve to an external function.\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
resolve{\char '137}jump{\char '137}target
\end{tabular}]
{\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{Context} & The context \\
\haddockdecltt{->} & \haddockdecltt{Instr} & The instruction \\
\haddockdecltt{->} & \haddockdecltt{{\char 91}ResolvedJumpTarget{\char 93}} & \\
\end{tabulary}\par
Resolves the first operand of a call or jump instruction.
 First tries to see if the instruction is an indirection, that has already been resolved.
 If not, try to statically resolve the first operand using \haddocktt{\haddockid{operand{\char '137}static{\char '137}resolve}}.
 If that resolves to an external symbol \haddocktt{libc{\char '137}start{\char '137}main}, then this call is actually an indirection (and thus currently unresolved).
 If that resolves to an immediate value, see if that immediate value corresponds to an external function or an internal function.\par
Returns a list of \haddocktt{\haddockid{ResolvedJumpTarget}}, since an indirection may be resolved to multiple targets.\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
get{\char '137}internal{\char '137}addresses
\end{tabular}]
{\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{ResolvedJumpTarget} & A resolved jump target \\
\haddockdecltt{->} & \haddockdecltt{{\char 91}Int{\char 93}} & \\
\end{tabulary}\par
Given a resolved jump target, get a possibly empty list of internal addresses to which the jump target can jump.\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instruction{\char '137}jumps{\char '137}to{\char '137}external
\end{tabular}]
{\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{Context} & The context \\
\haddockdecltt{->} & \haddockdecltt{Instr} & The instruction \\
\haddockdecltt{->} & \haddockdecltt{Bool} & \\
\end{tabulary}\par
Returns true iff the instruction resolves to external targets only.\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
show{\char '137}block
\end{tabular}]
{\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{CFG} & The CFG \\
\haddockdecltt{->} & \haddockdecltt{Int} & The blockID \\
\haddockdecltt{->} & \haddockdecltt{String} & \\
\end{tabulary}\par
Shows the block associated to the givern blockID.\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
show{\char '137}invariants
\end{tabular}]
{\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{CFG} & The CFG \\
\haddockdecltt{->} & \haddockdecltt{Invariants} & The invariants \\
\haddockdecltt{->} & \haddockdecltt{String} & \\
\end{tabulary}\par
Shows invariants.\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
function{\char '137}name{\char '137}of{\char '137}entry
\end{tabular}]
{\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{Context} & The context \\
\haddockdecltt{->} & \haddockdecltt{Int} & The entry address \\
\haddockdecltt{->} & \haddockdecltt{String} & \\
\end{tabulary}\par
Tries to retrieve a function name with an entry address.
 If the entry matches a known symbol, return that.
 Otherwise, simply return the entry address itself in hexadecimal notation.
 However, there is one exception: 
 	if the first instruction at the entry address immediately jumps to an external function,
 	return the name of that external function instead. This happens in a \haddocktt{.got} section.\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
function{\char '137}name{\char '137}of{\char '137}instruction
\end{tabular}]
{\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{Context} & The context \\
\haddockdecltt{->} & \haddockdecltt{Instr} & The instruction \\
\haddockdecltt{->} & \haddockdecltt{String} & \\
\end{tabulary}\par
Tries to retrieve a function name for a \haddocktt{call}-instruction (see \haddocktt{\haddockid{function{\char '137}name{\char '137}of{\char '137}entry}}).\par
Returns the empty string if the given instruction is not a call or a jump.\par}
\end{haddockdesc}